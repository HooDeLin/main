# A0124321Y
###### procrastinate\command\Add.java
``` java
package procrastinate.command;

import procrastinate.task.Task;

public abstract class Add extends CrudCmd implements FeedbackCrud {
    protected Task task;
    protected String description;

    public Add(CommandType type) {
        super(type);
    }

    public Command addDescription(String description) {
        assert description != null;

        this.description = description.trim();
        return this;
    }

    public String getDescription() {
        return description;
    }
}
```
###### procrastinate\command\AddDeadline.java
``` java
package procrastinate.command;

import java.util.Date;

import procrastinate.task.Deadline;
import procrastinate.task.TaskEngine;
import procrastinate.ui.UI;

public class AddDeadline extends Add {
    private Date date;

    public AddDeadline(String description, Date date) {
        super(CommandType.ADD_DEADLINE);

        assert date != null;

        addDescription(description);
        addDate(date);
    }

    @Override
    public String run(UI ui, TaskEngine taskEngine) {
        String feedback = null;

        // make task
        task = new Deadline(description, date);

        // make feedback for preview zone
        feedback = ui.fitToStatus(String.format(ADD, task.getTypeString()), description, task.getDateString());

        if (isPreview()) {
            assert feedback != null;
            return feedback;
        }

        // add to task engine
        if (taskEngine.add(task)) {
            return feedback;
        } else {
            // display error msg if add fails
            ui.createErrorDialog(ERROR_SAVE_HEADER, ERROR_SAVE_MESSAGE);
            feedback = FEEDBACK_TRY_AGAIN;
            return feedback;
        }
    }

    public Command addDate(Date date) {
        this.date = date;
        return this;
    }

    public Date getDate() {
        return date;
    }
}
```
###### procrastinate\command\AddDream.java
``` java
package procrastinate.command;

import procrastinate.task.Dream;
import procrastinate.task.TaskEngine;
import procrastinate.ui.UI;

public class AddDream extends Add {
    public AddDream(String description) {
        super(CommandType.ADD_DREAM);
        addDescription(description);
    }

    @Override
    public String run(UI ui, TaskEngine taskEngine) {
        String feedback = null;

        // make task
        task = new Dream(description);

        // make feedback for preview zone
        feedback = ui.fitToStatus(String.format(ADD, task.getTypeString()), description, task.getDateString());

        if (isPreview()) {
            assert feedback != null;
            return feedback;
        }

        if (taskEngine.add(task)) {
            return feedback;
        } else {
            // display error msg if add fails
            ui.createErrorDialog(ERROR_SAVE_HEADER, ERROR_SAVE_MESSAGE);
            feedback = FEEDBACK_TRY_AGAIN;
            return feedback;
        }


    }
}
```
###### procrastinate\command\AddEvent.java
``` java
package procrastinate.command;

import java.util.Date;

import procrastinate.task.Event;
import procrastinate.task.TaskEngine;
import procrastinate.ui.UI;

public class AddEvent extends Add {
    private Date startDate;
    private Date endDate;

    public AddEvent(String description, Date startDate, Date endDate) {
        super(CommandType.ADD_EVENT);
        assert startDate != null && endDate != null;

        addDescription(description);
        addStartDate(startDate);
        addEndDate(endDate);
    }

    @Override
    public String run(UI ui, TaskEngine taskEngine) {
        String feedback = null;

        if (endDate.before(startDate)) {
            feedback = String.format(INVALID_RANGE,
                                     Feedback.formatDateTime(startDate),
                                     Feedback.formatDateTime(endDate));
            return feedback;
        }

        // make task
        task = new Event(description, startDate, endDate);

        // make feedback for preview zone
        feedback = ui.fitToStatus(String.format(ADD, task.getTypeString()), description, task.getDateString());

        if (isPreview()) {
            assert feedback != null;
            return feedback;
        }

        // add to task engine
        if (taskEngine.add(task)) {
            return feedback;
        } else {
            // display error msg if add fails
            ui.createErrorDialog(ERROR_SAVE_HEADER, ERROR_SAVE_MESSAGE);
            feedback = FEEDBACK_TRY_AGAIN;
            return feedback;
        }

    }

    public Command addStartDate(Date startDate) {
        this.startDate = startDate;
        return this;
    }

    public Command addEndDate(Date endDate) {
        this.endDate = endDate;
        return this;
    }

    public Date getStartDate() {
        return startDate;
    }

    public Date getEndDate() {
        return endDate;
    }

}
```
###### procrastinate\command\Command.java
``` java
package procrastinate.command;

import java.util.Date;

import procrastinate.task.TaskEngine;
import procrastinate.ui.UI;

public abstract class Command implements Preview, Feedback {
    public static enum CommandType {
        ADD_DEADLINE, ADD_EVENT, ADD_DREAM, EDIT, EDIT_PARTIAL, EDIT_TO_DREAM, DELETE, UNDO, DONE,
        SEARCH, SEARCH_ON, SEARCH_DUE, SEARCH_RANGE, SHOW_OUTSTANDING, SHOW_DONE, SHOW_ALL, SHOW_SUMMARY,
        SET_PATH, EXIT, HELP, INVALID;
    }

    protected int lineNum;
    protected String searchTerm, searchString;
    protected Date searchStartDate, searchEndDate;
    protected boolean searchShowDone;

    private CommandType type;
    private boolean preview;

    public Command(CommandType type) {
        assert type != null;

        this.type = type;
    }

    public abstract String run(UI ui, TaskEngine taskEngine);

    public String getSearchStr() {
        return searchString;
    }

    public String getSearchTerm() {
        return searchTerm;
    }

    public Date getSearchStartDate() {
        return searchStartDate;
    }

    public Date getSearchEndDate() {
        return searchEndDate;
    }

    public boolean getSearchShowDone() {
        return searchShowDone;
    }

    public int getLineNumber() {
        return lineNum;
    }

    @Override
    public boolean isPreview() {
        return preview;
    }

    @Override
    public void setPreview(boolean preview) {
        this.preview = preview;
    }

    public CommandType getType() {
        return type;
    }
}
```
###### procrastinate\command\CrudCmd.java
``` java
package procrastinate.command;

import procrastinate.task.Task;
import procrastinate.task.TaskEngine;

public abstract class CrudCmd extends Command implements FeedbackCrud {

    public CrudCmd(CommandType type) {
        super(type);
    }

    /**
     * Retrieves a task from the list of task TaskEngine maintains
     * List is 0-based index.
     * @param lineNumber visible from UI i.e. 1-based index
     * @return task
     */
    public Task getTask(int lineNumber, TaskEngine taskEngine) {
        return taskEngine.getCurrentTaskList().get(lineNumber - 1);
    }

    /**
     * Checks for line number validity
     * @param lineNum
     * @param taskEngine
     * @return
     */
    public boolean isInvalid(int lineNum, TaskEngine taskEngine) {
        return !(lineNum >= 1 && lineNum <= taskEngine.getCurrentTaskList().size());
    }
}
```
###### procrastinate\command\Delete.java
``` java
package procrastinate.command;

import procrastinate.task.Task;
import procrastinate.task.TaskEngine;
import procrastinate.ui.UI;

public class Delete extends CrudCmd {
    public Delete(int lineNum) {
        super(CommandType.DELETE);
        this.lineNum = lineNum;
    }

    @Override
    public String run(UI ui, TaskEngine taskEngine) {
        String feedback = null;

        if (isInvalid(lineNum, taskEngine)) {
            feedback = String.format(INVALID_LINE_NUMBER, lineNum);
            return feedback;
        }
        Task task = getTask(lineNum, taskEngine);

        // make feedback for preview zone
        feedback = String.format(DELETED, task.getTypeString(), task.getDescription());

        if (isPreview()) {
            assert feedback != null;
            return feedback;
        }

        if (taskEngine.delete(task.getId())) {
            return feedback;
        } else {
            // display error msg if add fails
            ui.createErrorDialog(ERROR_SAVE_HEADER, ERROR_SAVE_MESSAGE);
            feedback = FEEDBACK_TRY_AGAIN;
            return feedback;
        }
    }

}
```
###### procrastinate\command\Done.java
``` java
package procrastinate.command;

import procrastinate.task.Task;
import procrastinate.task.TaskEngine;
import procrastinate.ui.UI;

public class Done extends CrudCmd {
    public Done(int lineNum) {
        super(CommandType.DONE);
        this.lineNum = lineNum;
    }

    @Override
    public String run(UI ui, TaskEngine taskEngine) {
        assert ui != null && taskEngine != null;
        String feedback = null;

        if (isInvalid(lineNum, taskEngine)) {
            feedback = String.format(INVALID_LINE_NUMBER, lineNum);
            return feedback;
        }
        Task task = getTask(lineNum, taskEngine);
        boolean done = task.isDone();

        // make feedback for preview zone
        if (done) {
            feedback = String.format(UNDONE, task.getTypeString(), task.getDescription());
        } else {
            feedback = String.format(DONE, task.getTypeString(), task.getDescription());
        }

        if (isPreview()) {
            assert feedback != null;
            return feedback;
        }

        boolean success = taskEngine.done(task.getId());

        if (!success) {
            // display error msg if add fails
            ui.createErrorDialog(ERROR_SAVE_HEADER, ERROR_SAVE_MESSAGE);
            feedback = FEEDBACK_TRY_AGAIN;
            return feedback;
        }
        return feedback;
    }
}
```
###### procrastinate\command\Edit.java
``` java
package procrastinate.command;

import procrastinate.task.Task;

public abstract class Edit extends CrudCmd implements FeedbackCrud {
    protected String description;
    protected Task oldTask;
    protected Task newTask;

    public Edit(CommandType type, int lineNum) {
        super(type);
        this.lineNum = lineNum;
    }

    public Command addDescription(String description) {
        assert description != null;

        this.description = description.trim();
        return this;
    }

    public String getDescription() {
        return description;
    }
}
```
###### procrastinate\command\EditDeadline.java
``` java
package procrastinate.command;

import java.util.Date;

import procrastinate.task.Deadline;
import procrastinate.task.TaskEngine;
import procrastinate.ui.UI;

public class EditDeadline extends Edit {
    private Date date;

    public EditDeadline(int lineNum, String description, Date date) {
        super(CommandType.EDIT, lineNum);

        addDescription(description);
        this.date = date;
    }

    @Override
    public String run(UI ui, TaskEngine taskEngine) {
        String feedback = null;

        if (isInvalid(lineNum, taskEngine)) {
            feedback = String.format(INVALID_LINE_NUMBER, lineNum);
            return feedback;
        }

        // make task
        oldTask = getTask(lineNum, taskEngine);
        if (description.isEmpty()) {
            newTask = new Deadline(oldTask.getDescription(), date);
        } else {
            newTask = new Deadline(description, date);
        }

        // make feedback for preview zone
        feedback = ui.fitToStatus(String.format(EDIT, getLineNumber()),
                                  newTask.getDescription(),
                                  newTask.getDateString());

        if (isPreview()) {
            assert feedback != null;
            return feedback;
        }

        // replace old with new
        if (taskEngine.edit(oldTask.getId(), newTask)) {
            return feedback;
        } else {
            // display error msg if add fails
            ui.createErrorDialog(ERROR_SAVE_HEADER, ERROR_SAVE_MESSAGE);
            feedback = FEEDBACK_TRY_AGAIN;
            return feedback;
        }
    }

}
```
###### procrastinate\command\EditDream.java
``` java
package procrastinate.command;

import procrastinate.task.Dream;
import procrastinate.task.TaskEngine;
import procrastinate.ui.UI;

public class EditDream extends Edit {
    public EditDream(int lineNum, String description) {
        super(CommandType.EDIT, lineNum);

        addDescription(description);
    }

    @Override
    public String run(UI ui, TaskEngine taskEngine) {
        String feedback = null;

        if (isInvalid(lineNum, taskEngine)) {
            feedback = String.format(INVALID_LINE_NUMBER, lineNum);
            return feedback;
        }

        // make task
        oldTask = getTask(lineNum, taskEngine);
        if (description.isEmpty()) {
            newTask = new Dream(oldTask.getDescription());
        } else {
            newTask = new Dream(description);
        }

        // make feedback for preview zone
        feedback = ui.fitToStatus(String.format(EDIT, getLineNumber()), newTask.getDescription(), newTask.getDateString());

        if (isPreview()) {
            assert feedback != null;
            return feedback;
        }

        // replace old with new
        if (taskEngine.edit(oldTask.getId(), newTask)) {
            return feedback;
        } else {
            // display error msg if add fails
            ui.createErrorDialog(ERROR_SAVE_HEADER, ERROR_SAVE_MESSAGE);
            feedback = FEEDBACK_TRY_AGAIN;
            return feedback;
        }
    }

}
```
###### procrastinate\command\EditEvent.java
``` java
package procrastinate.command;

import java.util.Date;

import procrastinate.task.Event;
import procrastinate.task.TaskEngine;
import procrastinate.ui.UI;

public class EditEvent extends Edit {
    private Date startDate;
    private Date endDate;

    public EditEvent(int lineNum, String description, Date startDate, Date endDate) {
        super(CommandType.EDIT, lineNum);

        addDescription(description);
        this.startDate = startDate;
        this.endDate = endDate;
    }

    @Override
    public String run(UI ui, TaskEngine taskEngine) {
        String feedback = null;

        if (isInvalid(lineNum, taskEngine)) {
            feedback = String.format(INVALID_LINE_NUMBER, lineNum);
            return feedback;
        }

        if (endDate.before(startDate)) {
            feedback = String.format(INVALID_RANGE,
                                     Feedback.formatDateTime(startDate),
                                     Feedback.formatDateTime(endDate));
            return feedback;
        }

        // make task
        oldTask = getTask(lineNum, taskEngine);
        if (description.isEmpty()) {
            newTask = new Event(oldTask.getDescription(), startDate, endDate);
        } else {
            newTask = new Event(description, startDate, endDate);
        }

        // make feedback for preview zone
        feedback = ui.fitToStatus(String.format(EDIT, getLineNumber()),
                                  newTask.getDescription(),
                                  newTask.getDateString());

        if (isPreview()) {
            assert feedback != null;
            return feedback;
        }


        // replace old with new
        if (taskEngine.edit(oldTask.getId(), newTask)) {
            return feedback;
        } else {
            // display error msg if add fails
            ui.createErrorDialog(ERROR_SAVE_HEADER, ERROR_SAVE_MESSAGE);
            feedback = FEEDBACK_TRY_AGAIN;
            return feedback;
        }
    }

}
```
###### procrastinate\command\EditPartial.java
``` java
package procrastinate.command;

import procrastinate.task.TaskEngine;
import procrastinate.ui.UI;

public class EditPartial extends CrudCmd implements FeedbackCrud {
    public EditPartial(int lineNum) {
        super(CommandType.EDIT_PARTIAL);
        this.lineNum = lineNum;
    }

    @Override
    public String run(UI ui, TaskEngine taskEngine) {
        assert taskEngine != null;

        String feedback = null;

        if (isInvalid(lineNum, taskEngine)) {
            feedback = String.format(INVALID_LINE_NUMBER, lineNum);
            return feedback;
        }

        feedback = EDIT_PARTIAL;
        return feedback;
    }
}
```
###### procrastinate\command\Feedback.java
``` java
package procrastinate.command;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * A feedback interface to consolidate all feedback messages
 * @author Gerald
 *
 */
public interface Feedback {
    public static final String FEEDBACK_TRY_AGAIN = "Please set a different save location and try again";;
    public static final String INVALID_RANGE = "Invalid dates: %2$s is before %1$s";
    public static final String ELLIPSIS = "...";

    public static final DateFormat dateTimeFormatter = new SimpleDateFormat("d/MM/yy h:mma");
    public static final DateFormat dateFormatter = new SimpleDateFormat("d/MM/yy");

    public static String formatDateTime(Date date) {
        return dateTimeFormatter.format(date);
    }

    public static String formatDate(Date date) {
        return dateFormatter.format(date);
    }

    public static String shorten(String description, int maxLength) {
        if (description.length() <= maxLength) {
            return description;
        }

        return description.substring(0, maxLength - 1) + ELLIPSIS;
    }
}
```
###### procrastinate\command\FeedbackCrud.java
``` java
package procrastinate.command;

public interface FeedbackCrud extends Feedback {
    public static final String ADD = "New %1$s: ";
    public static final String ADD_DREAM = "New dream: %1$s";
    public static final String ADD_DEADLINE = "New deadline: %1$s due %2$s";
    public static final String ADD_EVENT = "New event: %1$s %2$s to %3$s";

    public static final String EDIT = "Edited #%1$s: ";
    public static final String EDIT_DREAM = "Edited #%1$s: %2$s";
    public static final String EDIT_DEADLINE = "Edited #%1$s: %2$s due %3$s";
    public static final String EDIT_EVENT = "Edited #%1$s: %2$s %3$s to %4$s";
    public static final String EDIT_PARTIAL = "Please specify the new description/date(s) or press tab";

    public static final String DELETED = "Deleted %1$s: %2$s";

    public static final String DONE = "Done %1$s: %2$s";
    public static final String UNDONE = "Undone %1$s: %2$s";

    public static final String UNDO = "Undid last operation";
    public static final String NOTHING_TO_UNDO = "Nothing to undo";

    public static final String INVALID_LINE_NUMBER = "Invalid line number: %1$d";

    public static final String ERROR_SAVE_HEADER = "Could not save changes to file!";
    public static final String ERROR_SAVE_MESSAGE = FEEDBACK_TRY_AGAIN;

    public static final int MAX_LENGTH_DESCRIPTION = 20;
    public static final int MAX_LENGTH_DESCRIPTION_SHORT = 10;
    public static final int MAX_LENGTH_DESCRIPTION_TINY = 7;
}
```
###### procrastinate\command\FeedbackHelp.java
``` java
package procrastinate.command;

public interface FeedbackHelp extends Feedback {
    public static final String HELP = "Showing help screen (use left/right keys to navigate)";
}
```
###### procrastinate\command\FeedbackSearch.java
``` java
package procrastinate.command;

public interface FeedbackSearch extends Feedback {
    public static final String SEARCH = "Searching for tasks";
    public static final String SEARCH_CONTAINING = " containing '%1$s'";
    public static final String SEARCH_ON = " on %1$s";
    public static final String SEARCH_DUE = " due by %1$s";
    public static final String SEARCH_FROM_TO = " from %1$s to %2$s";

    public static final String SEARCH_STRING_DESCRIPTION = "'%1$s'";
    public static final String SEARCH_STRING_NO_DESCRIPTION = "all tasks";
    public static final String SEARCH_STRING_ON = " on ";
    public static final String SEARCH_STRING_DUE = " due ";
    public static final String SEARCH_STRING_FROM_TO = " from %1$s to %2$s";
}
```
###### procrastinate\command\Preview.java
``` java
package procrastinate.command;

/**
 * A simple interface to state whether an action should be run
 * @author Gerald
 *
 */
public interface Preview {
    /**
     *
     * @return true if action should not be run
     */
    public boolean isPreview();

    public void setPreview(boolean preview);
}
```
###### procrastinate\command\Search.java
``` java
package procrastinate.command;

public abstract class Search extends Command implements FeedbackSearch {
    protected String description;

    public Search(CommandType type) {
        super(type);
    }
}
```
###### procrastinate\command\SearchDesc.java
``` java
package procrastinate.command;

import java.util.Date;

import procrastinate.task.TaskEngine;
import procrastinate.ui.UI;

public class SearchDesc extends Search {

    public SearchDesc(String description) {
        super(CommandType.SEARCH);
        this.description = description;
    }
    @Override
    public String run(UI ui, TaskEngine taskEngine) {
        String str = "";
        String term = null;
        Date start = null;
        Date end = null;
        boolean showDone = true;

        String feedback = SEARCH;

        // description setting
        if (description.isEmpty()) {
            str += SEARCH_STRING_NO_DESCRIPTION;
        } else {
            feedback += String.format(SEARCH_CONTAINING, description);
            term = description;
            str += String.format(SEARCH_STRING_DESCRIPTION, description);
        }

        searchString = str;
        searchTerm = term;
        searchEndDate = end;
        searchStartDate = start;
        searchShowDone = showDone;
        return feedback;
    }
}
```
###### procrastinate\command\SearchDue.java
``` java
package procrastinate.command;

import java.util.Calendar;
import java.util.Date;

import org.apache.commons.lang.time.DateUtils;

import procrastinate.task.TaskEngine;
import procrastinate.ui.UI;

public class SearchDue extends Search {
    private Date date;

    public SearchDue(String description, Date date) {
        super(CommandType.SEARCH_DUE);
        this.description = description;
        this.date = date;
    }

    @Override
    public String run(UI ui, TaskEngine taskEngine) {
        String str = "";
        String term = null;
        Date start = null;
        Date end = null;
        boolean showDone = true;

        String feedback = SEARCH;

        // description setting
        if (description.isEmpty()) {
            str += SEARCH_STRING_NO_DESCRIPTION;
        } else {
            feedback += String.format(SEARCH_CONTAINING, description);
            term = description;
            str += String.format(SEARCH_STRING_DESCRIPTION, description);
        }

        // date setting
        if (date != null) {
            showDone = false;

            // set time to 0000 hrs of the specified day
            date = DateUtils.truncate(date, Calendar.DATE);

            feedback += String.format(SEARCH_DUE, Feedback.formatDate(date));
            start = new Date(0); // beginning of time
            end = DateUtils.addDays(date, 3);
            str += SEARCH_STRING_DUE + Feedback.formatDate(date);
        }

        searchString = str;
        searchTerm = term;
        searchEndDate = end;
        searchStartDate = start;
        searchShowDone = showDone;

        return feedback;
    }
}
```
###### procrastinate\command\SearchOn.java
``` java
package procrastinate.command;

import java.util.Calendar;
import java.util.Date;

import org.apache.commons.lang.time.DateUtils;

import procrastinate.task.TaskEngine;
import procrastinate.ui.UI;

public class SearchOn extends Search {
    private Date date;

    public SearchOn(String description, Date date) {
        super(CommandType.SEARCH_ON);
        this.description = description;
        this.date = date;
    }

    @Override
    public String run(UI ui, TaskEngine taskEngine) {
        String str = "";
        String term = null;
        Date start = null;
        Date end = null;
        boolean showDone = true;

        String feedback = SEARCH;

        // decription setting
        if (description.isEmpty()) {
            str += SEARCH_STRING_NO_DESCRIPTION;
        } else {
            feedback += String.format(SEARCH_CONTAINING, description);
            term = description;
            str += String.format(SEARCH_STRING_DESCRIPTION, description);
        }

        // date setting
        if (date != null) {
            showDone = false;

            // set time to 0000 hrs of the specified day
            date = DateUtils.truncate(date, Calendar.DATE);

            feedback += String.format(SEARCH_ON, Feedback.formatDate(date));
            start = date;
            end = DateUtils.addDays(date, 3);
            str += SEARCH_STRING_ON + Feedback.formatDate(date);
        }

        searchString = str;
        searchTerm = term;
        searchEndDate = end;
        searchStartDate = start;
        searchShowDone = showDone;

        return feedback;
    }
}
```
###### procrastinate\command\SearchRange.java
``` java
package procrastinate.command;

import java.util.Calendar;
import java.util.Date;

import org.apache.commons.lang.time.DateUtils;

import procrastinate.task.TaskEngine;
import procrastinate.ui.UI;

public class SearchRange extends Search {
    private Date startDate, endDate;

    public SearchRange(String description, Date startDate, Date endDate) {
        super(CommandType.SEARCH_RANGE);
        this.description = description;
        this.startDate = startDate;
        this.endDate = endDate;
    }

    @Override
    public String run(UI ui, TaskEngine taskEngine) {
        String str = "";
        String term = null;
        Date start = null;
        Date end = null;
        boolean showDone = true;

        String feedback = SEARCH;

        // description setting
        if (description.isEmpty()) {
            str += SEARCH_STRING_NO_DESCRIPTION;
        } else {
            feedback += String.format(SEARCH_CONTAINING, description);
            term = description;
            str += String.format(SEARCH_STRING_DESCRIPTION, description);
        }

        // date setting
        if (startDate != null && endDate != null) {
            // set time to 0000 hrs of the specified day
            startDate = DateUtils.truncate(startDate, Calendar.DATE);
            endDate = DateUtils.truncate(endDate, Calendar.DATE);

            if (endDate.before(startDate)) {
                return String.format(INVALID_RANGE,
                                     Feedback.formatDate(startDate),
                                     Feedback.formatDate(endDate));
            }

            feedback += String.format(SEARCH_FROM_TO,
                                      Feedback.formatDate(startDate),
                                      Feedback.formatDate(endDate));
            start = startDate;
            end = DateUtils.addDays(endDate, 1);;
            str += String.format(SEARCH_STRING_FROM_TO,
                                 Feedback.formatDate(startDate),
                                 Feedback.formatDate(endDate));
        }

        searchString = str;
        searchTerm = term;
        searchEndDate = end;
        searchStartDate = start;
        searchShowDone = showDone;

        return feedback;
    }
}
```
###### procrastinate\command\SetPath.java
``` java
package procrastinate.command;

import java.io.File;
import java.io.IOException;

import procrastinate.FileHandler;
import procrastinate.task.TaskEngine;
import procrastinate.ui.UI;

public class SetPath extends Command implements FeedbackSetPath {
    private String pathDir, pathFilename;

    public SetPath(String pathDir, String pathFilename) {
        super(CommandType.SET_PATH);
        this.pathDir = pathDir;
        this.pathFilename = pathFilename == null ? FileHandler.DEFAULT_FULL_FILENAME : pathFilename;
    }

    public String getPathDirectory() {
        return pathDir;
    }

    public String getPathFilename() {
        return pathFilename;
    }

    @Override
    public String run(UI ui, TaskEngine taskEngine) {
        String feedback = null;
        String parsedPathDirectory = null;
        File targetDirectory = new File(pathDir);

        // normalise path
        try {
            parsedPathDirectory = targetDirectory.getCanonicalPath();
        } catch (IOException e) {
            parsedPathDirectory = targetDirectory.getAbsolutePath();
        }

        if (!parsedPathDirectory.endsWith(File.separator)) {
            parsedPathDirectory += File.separator;
        }

        // feedback for preview zone
        feedback = String.format(SET_LOCATION, parsedPathDirectory, pathFilename);

        if (isPreview()) {
            return feedback;
        }

        // sets the path
        if (taskEngine.set(parsedPathDirectory, pathFilename)) {
            return feedback;
        } else {
            ui.createErrorDialog(ERROR_SET_LOCATION_HEADER,
                                 String.format(ERROR_SET_LOCATION_MESSAGE,
                                               parsedPathDirectory, pathFilename));
            feedback = FEEDBACK_TRY_AGAIN;
            return feedback;
        }
    }
}
```
###### procrastinate\command\ShowAll.java
``` java
package procrastinate.command;

import procrastinate.task.TaskEngine;
import procrastinate.ui.UI;

public class ShowAll extends Show {

    public ShowAll() {
        super(CommandType.SHOW_ALL);
    }

    @Override
    public String run(UI ui, TaskEngine taskEngine) {
        return SHOW_ALL;
    }
}
```
###### procrastinate\command\ShowDone.java
``` java
package procrastinate.command;

import procrastinate.task.TaskEngine;
import procrastinate.ui.UI;

public class ShowDone extends Show {

    public ShowDone() {
        super(CommandType.SHOW_DONE);
    }

    @Override
    public String run(UI ui, TaskEngine taskEngine) {
        return SHOW_DONE;
    }
}
```
###### procrastinate\command\ShowOutstanding.java
``` java
package procrastinate.command;

import procrastinate.task.TaskEngine;
import procrastinate.ui.UI;

public class ShowOutstanding extends Show {

    public ShowOutstanding() {
        super(CommandType.SHOW_OUTSTANDING);
    }

    @Override
    public String run(UI ui, TaskEngine taskEngine) {
        return SHOW_OUTSTANDING;
    }
}
```
###### procrastinate\command\ShowSummary.java
``` java
package procrastinate.command;

import procrastinate.task.TaskEngine;
import procrastinate.ui.UI;

public class ShowSummary extends Show {

    public ShowSummary() {
        super(CommandType.SHOW_SUMMARY);
    }

    @Override
    public String run(UI ui, TaskEngine taskEngine) {
        return SHOW_SUMMARY;
    }
}
```
###### procrastinate\command\Undo.java
``` java
package procrastinate.command;

import procrastinate.task.TaskEngine;
import procrastinate.ui.UI;

public class Undo extends CrudCmd {
    public Undo() {
        super(CommandType.UNDO);
    }

    @Override
    public String run(UI ui, TaskEngine taskEngine) {
        String feedback = null;

        if (!taskEngine.hasPreviousOperation()) {
            feedback = NOTHING_TO_UNDO;
            return feedback;
        }

        feedback = UNDO;

        if (isPreview()) {
            return feedback;
        }

        if (taskEngine.undo()) {
            return feedback;
        } else {
            ui.createErrorDialog(ERROR_SAVE_HEADER, ERROR_SAVE_MESSAGE);
            return FEEDBACK_TRY_AGAIN;
        }
    }

}
```
###### procrastinate\FileHandler.java
``` java
    /**
     * FileHandler constructor. loads configuration and storage information.
     * Absence of config file is considered as first launch. Config and save files will
     * be initialised accordingly. For subsequent launches, loads config and save files.
     */
    public FileHandler() throws IOException {
        File saveFile = null;
        configFile = Paths.get(CONFIG_PATH).toFile();

        Path savePath = loadConfig();
        if (Files.exists(savePath)) {
            saveFile = savePath.toFile();
        } else {
            saveFile = makeFile(savePath);
            makeEmptyState();
        }
        this.saveFile = saveFile;
        this.fullFilename = savePath.getFileName().toString();

        logger.log(Level.INFO, String.format(DEBUG_FILE_INIT, saveFile.getCanonicalPath()));
    }
```
###### procrastinate\FileHandler.java
``` java
    /**
     * Converts TaskState into json format and writes to disk
     * @param taskState
     */
    public boolean saveTaskState(TaskState taskState) {
        String json = jsonify(taskState);
        try {
            jsonToFile(json);
        } catch (IOException e) {
            logger.log(Level.SEVERE, DEBUG_FILE_WRITE_FAILURE);
            return false;
        }
        return true;
    }

```
###### procrastinate\FileHandler.java
``` java
    /**
     * Loads TaskState from a json file
     * @return TaskState
     */
    public TaskState loadTaskState() {
        return loadTaskState(saveFile);
    }

```
###### procrastinate\FileHandler.java
``` java
    /**
     * Sets new path for save file.
     * Will not overwrite a file, fails if the path already exists.
     * On contrary, all non-existent directory and file will be created.
     *
     * @param dir must end with '/'. filename should not have file extension
     * @return true on success, false otherwise
     */
    public boolean setPath(String dir, String filename) {
        assert dir.endsWith(File.separator);

        if (filename == null || filename.isEmpty()) {
            filename = DEFAULT_FULL_FILENAME;
        }

        Path newPath = Paths.get(dir + filename);

        try {
            saveFile = updateSaveFile(newPath).toFile();
            updateConfig(newPath);
            fullFilename = filename;

            logger.log(Level.INFO, String.format(DEBUG_SET_PATH_SUCCESS, newPath));
            return true;
        } catch (IOException e) {
            logger.log(Level.SEVERE, String.format(DEBUG_SET_PATH_FAILURE, newPath));
            return false;
        }
    }

```
###### procrastinate\FileHandler.java
``` java
    public String getFilename() {
        return fullFilename;
    }

```
###### procrastinate\FileHandler.java
``` java
    public File getSaveFile() {
        return saveFile;
    }

```
###### procrastinate\FileHandler.java
``` java
    public File getConfigFile() {
        return configFile;
    }

```
###### procrastinate\FileHandler.java
``` java
    /**
     * Loads from existing configuration if it exists, otherwise initialise configuration
     * file with default settings. If config file does not exists, storage file is assumed
     * to not exists
     *
     * @return savePath, the path of the storage file.
     */
    private Path loadConfig() throws IOException {
        BufferedReader reader = null;
        BufferedWriter writer = null;
        Path p = null;

        if (Files.exists(configFile.toPath())) {
            reader = new BufferedReader(new FileReader(configFile));

            String line = reader.readLine();
            reader.close();
            if (line != null) {
                fullFilename = line;

                p = Paths.get(line);
                saveFile = p.toFile();
            } else {
                writer = new BufferedWriter(new FileWriter(configFile));
                writer.write(DEFAULT_FULL_FILENAME);
                writer.flush();

                p = Paths.get(DEFAULT_FULL_FILENAME);
                saveFile = p.toFile();
            }
            reader.close();
            logger.log(Level.INFO, String.format(DEBUG_CONFIG_EXISTS,  configFile.getCanonicalPath()));
        } else if (Files.notExists(configFile.toPath())) {
            Files.createFile(configFile.toPath());
            writer = new BufferedWriter(new FileWriter(configFile));

            writer.write(Paths.get(DEFAULT_FULL_FILENAME).toAbsolutePath().toString());
            writer.flush();

            p = Paths.get(DEFAULT_FULL_FILENAME);
            saveFile = p.toFile();
            logger.log(Level.INFO, String.format(DEBUG_CONFIG_ABSENT,  configFile.getCanonicalPath()));
        } else {
            logger.log(Level.SEVERE, String.format(DEBUG_FILE_INDETERMINANT, configFile.getCanonicalPath()));
        }

        if (writer !=null) {
            writer.close();
        }
        return p;
    }

```
###### procrastinate\FileHandler.java
``` java
    /**
     * Writes new configuration to file. Save path will be converted to absolute path
     * to make it easier for advance users to edit
     *
     * @param savePath Must be an existing path
     * @return
     */
    private boolean updateConfig(Path savePath) throws IOException {
        assert Files.exists(savePath);
        assert Files.isRegularFile(savePath);

        String abPath = savePath.toAbsolutePath().normalize().toString();
        BufferedWriter writer = null;
        boolean success = false;

        // overwrite the contents of the file.
        try {
            writer = new BufferedWriter(new FileWriter(configFile));
            writer.write(abPath);
            writer.flush();

            success = true;
        } catch (IOException e) {
            logger.log(Level.SEVERE, DEBUG_CONFIG_WRITE_FAILURE);
            throw e;
        } finally {
            try {
                if (writer != null) {
                    writer.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return success;
    }

```
###### procrastinate\FileHandler.java
``` java
    /**
     * Move save file to a new location. Does not overwrite if file exists
     *
     * @param savePath
     * @return
     * @throws IOException
     */
    private Path updateSaveFile(Path savePath) throws IOException {
        File oldSave = saveFile;
        Path parentDir = savePath.getParent();

        if (parentDir != null) {
            Files.createDirectories(parentDir);
        }

        Files.move(oldSave.toPath(), savePath);

        return savePath;
    }

```
###### procrastinate\FileHandler.java
``` java
    /**
     * Loads TaskState from json formatted file
     *
     * @return TaskState parsed from file, or an empty TaskState if the file is not found or invalid
     */
    private TaskState loadTaskState(File file) {
        BufferedReader br = null;
        Gson gson = new GsonBuilder().registerTypeAdapter(Task.class, new TaskDeserializer())
                .registerTypeAdapter(Date.class, new DateAdapter()).create();
        Type type = new TypeToken<TaskState>() {}.getType();

        try {
            br = new BufferedReader(new FileReader(file));
            TaskState taskState = gson.fromJson(br, type);

            if (taskState == null) {
                taskState = new TaskState();
            }

            logger.log(Level.INFO, String.format(DEBUG_FILE_LOAD_SUCCESS, taskState.getTasks().size()));
            return taskState;
        } catch (FileNotFoundException e) {
            logger.log(Level.WARNING, DEBUG_FILE_LOAD_NOT_FOUND);
            return new TaskState();
        } catch (JsonParseException e) {
            logger.log(Level.WARNING, DEBUG_FILE_PARSE_FAILURE);
            return new TaskState();
        } finally {
            if (br != null) {
                try {
                    br.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    };
```
###### procrastinate\FileHandler.java
``` java
    private void jsonToFile(String json) throws IOException {
        File parentDir = saveFile.getAbsoluteFile().getParentFile();
        if (parentDir != null) {
            parentDir.mkdirs();
        }
        saveFile.createNewFile();
        bw = new BufferedWriter(new FileWriter(saveFile));
        bw.write(json);
        bw.close();
        logger.log(Level.INFO, DEBUG_FILE_WRITE_SUCCESS + json);
    }

```
###### procrastinate\FileHandler.java
``` java
    private String jsonify(TaskState taskState) {
        Gson gson = new GsonBuilder().setPrettyPrinting().serializeNulls()
                .registerTypeAdapter(Date.class, new DateAdapter()).create();
        String json = gson.toJson(taskState);

        return json;
    }

```
###### procrastinate\FileHandler.java
``` java
    /**
     * Make a new save file based on given path.
     *
     * @param path of new file
     * @throws FileAlreadyExistsException
     * @author Gerald
     */
    private File makeFile(Path target) throws IOException {
        if (Files.notExists(target)) {
            return makeNewFile(target);
        } else {
            throw new FileAlreadyExistsException(target.toString() + " already exists");
        }
    }

```
###### procrastinate\FileHandler.java
``` java
    private File makeNewFile(Path target) throws IOException {
        assert Files.notExists(target);

        Path parentDir = target.toAbsolutePath().getParent();
        if (parentDir != null) {
            Files.createDirectories(parentDir.normalize());
        }
        return Files.createFile(target).toFile();
    }

```
###### procrastinate\FileHandler.java
``` java
    /**
     * Makes a empty state when a file is first initialised so that the json
     * file has the right structure
     */
    private void makeEmptyState() throws IOException {
        saveTaskState(new TaskState());
    }
```
###### procrastinate\Logic.java
``` java
    private String runCommand(Command command) {
        String feedback = null;

        switch (command.getType()) {

            case ADD_DREAM :
            case ADD_DEADLINE :
            case ADD_EVENT :
                feedback = execute(command);
                if (!command.isPreview()) {
                    updateView(ViewType.SHOW_OUTSTANDING);
                }
                break;

            case EDIT :
            case EDIT_TO_DREAM :
                feedback = execute(command);
                if (!command.isPreview()) {
                    updateView();
                }
                break;

            case EDIT_PARTIAL :
                feedback = execute(command);
                break;

            case DELETE :
                feedback = execute(command);
                if (!command.isPreview()) {
                    updateView();
                }
                break;

            case DONE :
                feedback = execute(command);
                if (!command.isPreview()) {
                    updateView();
                }
                break;

            case UNDO :
                feedback = execute(command);
                if (!command.isPreview()) {
                    updateView();
                }
                break;

            case SEARCH :
            case SEARCH_ON :
            case SEARCH_DUE :
            case SEARCH_RANGE :
                feedback = execute(command);
                if (!command.isPreview()) {
                    searchString = command.getSearchStr();
                    searchTerm = command.getSearchTerm();
                    searchStartDate = command.getSearchStartDate();
                    searchEndDate = command.getSearchEndDate();
                    searchShowDone = command.getSearchShowDone();

                    updateView(ViewType.SHOW_SEARCH_RESULTS);
                }
                break;

            case SET_PATH :
                feedback = execute(command);
                break;

            case SHOW_OUTSTANDING :
                feedback = execute(command);
                if (!command.isPreview()) {
                    updateView(ViewType.SHOW_OUTSTANDING);
                }
                break;

            case SHOW_DONE :
                feedback = execute(command);
                if (!command.isPreview()) {
                    updateView(ViewType.SHOW_DONE);
                }
                break;

            case SHOW_ALL :
                feedback = execute(command);
                if (!command.isPreview()) {
                    updateView(ViewType.SHOW_ALL);
                }
                break;

            case SHOW_SUMMARY :
                feedback = execute(command);
                if (!command.isPreview()) {
                    updateView(ViewType.SHOW_SUMMARY);
                }
                break;

            case HELP :
                feedback = execute(command);
                break;

            case INVALID :
                feedback = execute(command);
                break;

            case EXIT :
                if (!command.isPreview() && !exit()) {
                    feedback = Feedback.FEEDBACK_TRY_AGAIN;
                } else {
                    feedback = FeedbackExit.EXIT;
                }
                break;

            default :
                break;
        }
        return feedback;

    }

```
###### procrastinate\task\Task.java
``` java
	public Task(TaskType type, String description) {
	    this(type, description, false, UUID.randomUUID());
	}
```
###### procrastinate\task\Task.java
``` java
	/**
	 * For two tasks to be identical, they must be the same type
	 * and have the same description and done status
	 */
	@Override
	public boolean equals(Object o) {
		if (o == null) {
			return false;
		}
		if (o == this) {
			return true;
		}
		if (!(o instanceof Task)) {
			return false;
		}
		Task t = (Task) o;
		if (t.type_ == type_
				&& t.description_.equals(description_)
				&& t.isDone_ == isDone_) {
			return true;
		} else {
			return false;
		}
	}
```
###### procrastinate\task\TaskState.java
``` java
    /**
     * Checks if every task in the list is equal.
     * Equality is defined in Task class
     */
    @Override
    public boolean equals(Object o) {
    	if (o == null) {
    		return false;
    	}
    	if (o == this) {
    		return true;
    	}
    	if (!(o instanceof TaskState)) {
    		return false;
    	}

    	TaskState ts = (TaskState)o;
    	List<Task> t = ts.tasks_;

    	if (this.tasks_.size() != ts.tasks_.size()) {
    		return false;
    	}

    	return tasks_.equals(t);
    }
}
```
###### procrastinate\test\FileHandlerTest.java
``` java
package procrastinate.test;

import static org.junit.Assert.*;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.lang.reflect.Type;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Date;

import org.junit.Test;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.BeforeClass;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;

import procrastinate.FileHandler;
import procrastinate.task.DateAdapter;
import procrastinate.task.Task;
import procrastinate.task.TaskDeserializer;
import procrastinate.task.TaskState;

public class FileHandlerTest {
    private FileHandler handler = null;
    private static final String defaultName = "storage.json";
    private static final String testDir = "testfolder";
    private static Path originalSavePath;
    private static Path originalSaveName;
    private static Path tmpDir;
    private static boolean hasCfg;
    private static boolean hasSave;

    // move config and save file to a tmp folder
    @BeforeClass
    public static void prep() {
        Path cfg = Paths.get("settings.config");
        hasCfg = Files.exists(cfg);

        if (hasCfg) {
            BufferedReader reader = null;
            try {
                tmpDir = Files.createTempDirectory(Paths.get(""), "testtmp");

                reader = new BufferedReader(new FileReader(cfg.toFile()));
                originalSavePath = Paths.get(reader.readLine());
                reader.close();
                hasSave = Files.exists(originalSavePath);

                if (hasSave) {
                    originalSaveName = originalSavePath.getFileName();

                    Files.move(originalSavePath, tmpDir.resolve(originalSaveName));
                }

                Files.move(cfg, tmpDir.resolve(cfg));
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    // move config and save file back to original location
    @AfterClass
    public static void revert() {
        try {
            if (hasSave) {
                Files.move(tmpDir.resolve(originalSaveName), originalSavePath);
            }

            if (hasCfg) {
                Files.move(tmpDir.resolve("settings.config"), Paths.get("settings.config"));
                Files.deleteIfExists(tmpDir);
            }
            Files.deleteIfExists(Paths.get(testDir));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @After
    public void tearDown() {
        File config = handler.getConfigFile();
        File save = handler.getSaveFile();
        try {
            Files.deleteIfExists(config.toPath());
            Files.deleteIfExists(save.toPath());
        } catch (IOException e) {
            e.printStackTrace();
        }
        handler = null;
    }

    @Test
    public void fileHandler_DirNotGiven_ShouldMakeFileAtCurrLoc() throws IOException {
        System.out.println("fileHandler_DirNotGiven_ShouldMakeFileAtCurrLoc");
        handler = new FileHandler();
        Path p = Paths.get(defaultName);

        assertTrue(Files.exists(p));
        assertTrue(Files.isRegularFile(p));
        assertTrue(Files.isWritable(p));
    }

    @Test
    public void setPath_RelativePathWithFilename_ShouldUpdateCfgAndSaveFileLoc() throws IOException {
        System.out.println("setPath_RelativePathWithFilename_ShouldUpdateCfgAndSaveFileLoc");
        handler = new FileHandler();
        String dir = "." + File.separator + testDir + File.separator;
        String filename = "setpathtest";
        handler.setPath(dir, filename);

        BufferedReader br = new BufferedReader(new FileReader(handler.getConfigFile()));
        String content = br.readLine();
        br.close();

        Path newPath = Paths.get(dir+filename);
        assertEquals(newPath, handler.getSaveFile().toPath());
        assertEquals(newPath.toFile(), handler.getSaveFile());
        assertEquals(newPath.toAbsolutePath().normalize().toString().trim(), content.trim());
    }

    @Test
    public void setPath_SameDirDiffName_ShouldRemoveOldFile() throws IOException {
        System.out.println("setPath_SameDirDiffName_ShouldRemoveOldFile");
        handler = new FileHandler();

        String dir = "." + File.separator;
        String filename = "setpathtest";

        File oldSave = handler.getSaveFile();
        handler.setPath(dir, filename);

        assertTrue(Files.notExists(oldSave.toPath()));;
    }

    @Test
    public void loadConfig_NoConfigFile_ShouldMakeFile() throws IOException {
        System.out.println("loadConfig_NoConfigFile_ShouldMakeFile");
        handler = new FileHandler();
        BufferedReader reader = new BufferedReader(new FileReader(Paths.get("settings.config").toFile()));
        String line = reader.readLine();
        reader.close();

        assertEquals(Paths.get(defaultName).toAbsolutePath().toString(), line);
    }

    @Test
    public void loadTaskState_NoStorageFile_ShouldInitAndLoad() throws IOException {
        System.out.println("loadTaskState_NoStorageFile_ShouldInitAndLoad");
        TaskState loadedState;
        handler = new FileHandler();

        // load state from file
        loadedState = handler.loadTaskState();

        assertEquals(0, loadedState.getTasks().size());
    }

    @Test
    public void loadTaskState_HasStorageFile_ShouldLoadState() throws IOException {
        System.out.println("loadTaskState_HasStorageFile_ShouldLoadState");
        BufferedReader br;
        TaskState loadedState;

        handler = new FileHandler();
        // save stubstate to file
        handler.saveTaskState(new TaskStateStub());

        // load state from file
        loadedState = handler.loadTaskState();

        // mock a json file and load from it
        Gson gson = new GsonBuilder()
                .registerTypeAdapter(Task.class, new TaskDeserializer())
                .registerTypeAdapter(Date.class, new DateAdapter())
                .create();

        Type type = new TypeToken<TaskState>() {}.getType();
        br = new BufferedReader(new FileReader(new File(defaultName)));
        TaskState stub = gson.fromJson(br, type);
        br.close();

        assertEquals(stub, loadedState);
    }
}
```
###### procrastinate\test\LogicTest.java
``` java
    @Test
    public void search_DescriptionByWordDifferentTaskTypes_ShouldReturnHits() throws ParseException {
        List<Task> expected = new ArrayList<Task>();
        execute("foo 1");
        execute("foo 2 due 1/2/14 12:00am");
        execute("foo 3 from 1/2/14 to 2/2/2014 12:00am");

        execute("search foo");

        expected.add(new Deadline("foo 2", sdf.parse("1/2/14")));
        expected.add(new Event("foo 3", sdf.parse("1/2/14"), sdf.parse("2/2/14")));
        expected.add(new Dream("foo 1"));

        assertEquals(expected, getResults());
    }

```
###### procrastinate\test\LogicTest.java
``` java
    @Test
    public void search_DescriptionByWord_ShouldShowHits() {
        List<Task> expected = new ArrayList<Task>();
        execute("foo has bar");
        execute("foo has baz");
        execute("foo is not bar");

        execute("search foo");

        expected.add(new Dream("foo has bar"));
        expected.add(new Dream("foo has baz"));
        expected.add(new Dream("foo is not bar"));
        assertEquals(expected, getResults());
    }

```
###### procrastinate\test\LogicTest.java
``` java
    @Test
    public void searchDue_ByDate_ShouldShowTasksTillDate() throws ParseException {
        List<Task> expected = new ArrayList<Task>();
        execute("a due 1/2/14 12:00am");
        execute("b due 1/3/14 12:00am");
        execute("c due 10/1/14 12:00am");
        execute("d due 10/1/15 12:00am");

        execute("search due 10/1/2014");

        expected.add(new Deadline("a", sdf.parse("1/2/14")));
        expected.add(new Deadline("b", sdf.parse("1/3/14")));
        expected.add(new Deadline("c", sdf.parse("10/1/14")));

        assertEquals(expected, getResults());
    }

```
###### procrastinate\test\LogicTest.java
``` java
    // start or end dates are not distinct
    @Test
    public void searchDue_ByDateDiffTaskTypes_ShouldShowTasksWithGivenDates() throws ParseException {
        List<Task> expected = new ArrayList<Task>();
        execute("a due 1/2/14 12:00am");
        execute("a from 1/2/14 to 1/3/14 12:00am");
        execute("a from 1/5/14 to 1/6/14 12:00am");
        execute("a due 10/1/14 12:00am");

        execute("search due 1/2/14 12:00am");
        expected.add(new Deadline("a", sdf.parse("1/2/14")));
        expected.add(new Event("a", sdf.parse("1/2/14"), sdf.parse("1/3/14")));
        assertEquals(expected, getResults());

        execute("search due 1/3/14 12:00am");
        expected.add(new Event("a", sdf.parse("1/5/14"), sdf.parse("1/6/14")));
        assertEquals(expected, getResults());
    }

```
###### procrastinate\test\LogicTest.java
``` java
    @Test
    public void searchOn_ByDate_ShouldShowTasksOnDate() throws ParseException {
        List<Task> expected = new ArrayList<Task>();
        execute("a due 1/1/14 12:00am");
        execute("b due 1/2/14 12:00am");
        execute("c due 2/1/14 12:00am");
        execute("d due 1/1/15 12:00am");

        execute("search on 2/1/2014");

        expected.add(new Deadline("c", sdf.parse("2/1/14")));

        assertEquals(expected, getResults());
    }
```
###### procrastinate\test\TaskStateStub.java
``` java
	public TaskStateStub() {
		super(makeTasks());
	}

```
###### procrastinate\test\TaskStateStub.java
``` java
	private static List<Task> makeTasks() {
		List<Task> stub = new ArrayList<Task>();

		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
		stub.add(new Dream("foo dream"));
		try {
			stub.add(new Deadline("foo deadline", sdf.parse("30/09/2015")));
			stub.add(new Event("foo event", sdf.parse("30/09/2015"), sdf.parse("02/10/2015")));
		} catch (ParseException e) {
			e.printStackTrace();
		}

		Dream doneDream = new Dream("bar bee");
		doneDream.setDone(true);
		stub.add(doneDream);

		return stub;
	}
}
```
