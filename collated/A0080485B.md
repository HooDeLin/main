# A0080485B
###### Procrastinate/src/procrastinate/FileHandler.java
``` java
    public FileHandler(boolean isUnderTest) {
    }

```
###### Procrastinate/src/procrastinate/Logic.java
``` java
package procrastinate;

import javafx.beans.value.ChangeListener;
import javafx.event.EventHandler;
import javafx.scene.input.KeyEvent;
import javafx.stage.Stage;
import procrastinate.command.Command;
import procrastinate.command.Command.CommandType;
import procrastinate.command.Feedback;
import procrastinate.command.FeedbackExit;
import procrastinate.command.FeedbackHelp;
import procrastinate.ui.UI;
import procrastinate.ui.UI.ScreenView;

import java.io.IOException;
import java.util.Date;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import procrastinate.task.Task;
import procrastinate.task.TaskEngine;

public class Logic {

    // ================================================================================
    // Class variables
    // ================================================================================

    private static final Logger logger = Logger.getLogger(Logic.class.getName());

    private static enum ViewType {
        SHOW_OUTSTANDING, SHOW_DONE, SHOW_ALL, SHOW_SUMMARY, SHOW_SEARCH_RESULTS
    }

    // ================================================================================
    // Message strings
    // ================================================================================

    private static final String DEBUG_LOGIC_INIT = "Logic initialised.";

    private static final String NATTY_WARMUP_STRING = "Natty starts up slowly due tomorrow";

    private static final String FEEDBACK_READY = "Ready!";

    private static final String ERROR_STARTUP_HEADER = "There was a problem accessing the directory";
    private static final String ERROR_STARTUP_MESSAGE = "Please startup Procrastinate from a different working directory";
    private static final String ERROR_EXIT_HEADER = "Could not save changes! Your data will be LOST!";
    private static final String ERROR_EXIT_MESSAGE = "Discard unsaved changes and exit?";
    private static final String ERROR_EXIT_BUTTON_LABEL = "Discard and exit";

    // ================================================================================
    // Instance variables
    // ================================================================================

    protected TaskEngine taskEngine;
    protected UI ui;

    private boolean hasStartupError = false;

    private Command lastPreviewedCommand = null;

    private ViewType currentView;

    private String searchString = null;
    private String searchTerm = null;
    private Date searchStartDate = null;
    private Date searchEndDate = null;
    private boolean searchShowDone = true;

    // ================================================================================
    // Singleton pattern
    // ================================================================================

    private static Logic logic;

    protected Logic() {
        initTaskEngine();
        initParser();
        logger.log(Level.INFO, DEBUG_LOGIC_INIT);
    }

    public static Logic getInstance() {
        if (logic == null) {
            logic = new Logic();
        }
        return logic;
    }

    // ================================================================================
    // Logic methods
    // ================================================================================

    public String previewCommand(String userCommand) {
    	lastPreviewedCommand = Parser.parse(userCommand);
    	lastPreviewedCommand.setPreview(true);
        return runCommand(lastPreviewedCommand);
    }

    public String executeLastPreviewedCommand() {
    	assert(lastPreviewedCommand != null);
    	lastPreviewedCommand.setPreview(false);
        return runCommand(lastPreviewedCommand);
    }

    public boolean hasLastPreviewedCommand() {
    	return lastPreviewedCommand != null;
    }

```
###### Procrastinate/src/procrastinate/Logic.java
``` java
    // ================================================================================
    // Init methods
    // ================================================================================

    // Main handle
    public void initUi(Stage stage) {
        ui = new UI(stage);
        ui.attachHandlersAndListeners(createKeyPressHandler(), createUserInputListener(), createIsExitListener());
        if (hasStartupError) {
            ui.createErrorDialog(ERROR_STARTUP_HEADER, ERROR_STARTUP_MESSAGE);
            exit();
        }
        initUiTaskList();
        ui.setPreviewStatus(FEEDBACK_READY);
    }

    protected void initTaskEngine() {
		try {
            taskEngine = new TaskEngine();
        } catch (IOException e) {
            hasStartupError = true;
        }
    }

    private void initParser() {
        Parser.parse(NATTY_WARMUP_STRING);
    }

    // ================================================================================
    // UI Interaction methods
    // ================================================================================

    private void updateView() {
        if (currentView == ViewType.SHOW_SUMMARY) {
            currentView = ViewType.SHOW_OUTSTANDING;
        }
        updateUiTaskList();
    }

    private void updateView(ViewType newView) {
        currentView = newView;
        updateUiTaskList();
    }

    private void updateUiTaskList() {
        switch (currentView) {
            case SHOW_OUTSTANDING :
                ui.updateTaskList(taskEngine.getOutstandingTasks(), ScreenView.SCREEN_MAIN);
                break;

            case SHOW_DONE :
                ui.updateTaskList(taskEngine.getCompletedTasks(), ScreenView.SCREEN_DONE);
                break;

            case SHOW_ALL :
                ui.updateTaskList(taskEngine.getAllTasks(), ScreenView.SCREEN_MAIN_ALL);
                break;

            case SHOW_SUMMARY :
                ui.updateTaskList(taskEngine.getOutstandingTasks(), ScreenView.SCREEN_SUMMARY);
                break;

            case SHOW_SEARCH_RESULTS :
                ui.passSearchStringToSearchScreen(searchString);
                ui.updateTaskList(taskEngine.search(searchTerm, searchStartDate, searchEndDate, searchShowDone),
                                  ScreenView.SCREEN_SEARCH);
                break;
        }
    }

    private void initUiTaskList() {
        ui.initialUpdateTaskList(taskEngine.getOutstandingTasks());
        updateView(ViewType.SHOW_SUMMARY);
    }

    // Process key press events
    private EventHandler<KeyEvent> createKeyPressHandler() {
        return (keyEvent) -> {

            // Remove initial splash overlay
            ui.hideSplashOverlay();

            switch (keyEvent.getCode()) {

                // Main command execution flow
                case ENTER : {

                    // Whitespace command
                    if (ui.getInput().trim().isEmpty()) {
                        ui.clearInput();
                        ui.hideHelpOverlay();
                        return;
                    }

                    // Hide help unless it's a help or exit command
                    if (!lastPreviewedCommand.getType().equals(CommandType.HELP)
                            && !lastPreviewedCommand.getType().equals(CommandType.EXIT)) {
                        ui.hideHelpOverlay();
                    }

                    // All the work happens here!
                    String feedback = executeLastPreviewedCommand();

                    // Clear input box and display feedback
                    // ClearInput must come before setStatus as user input listener
                    // resets status when input is cleared
                    ui.clearInput();
                    ui.setExecuteStatus(feedback);

                    return;
                }

                // Edit description autocompletion
                case TAB : {
                    if (!hasLastPreviewedCommand()) {
                        return;
                    }

                    Command command = lastPreviewedCommand;
                    if (command.getType() != CommandType.EDIT_PARTIAL) {
                        return;
                    }

                    int lineNumber = lastPreviewedCommand.getLineNumber();

                    if (!isValidLineNumber(lineNumber)) {
                        return;
                    }

                    ui.setInput(ui.getInput().trim() + " " + getTaskFromLineNumber(lineNumber).getDescription());
                    return;
                }

                // Scrolling
                case UP : {
                    ui.scrollUpScreen();
                    return;
                }
                case DOWN : {
                    ui.scrollDownScreen();
                    return;
                }

                // Show help
                case F1 : {
                    ui.showHelpOverlay();
                    if (ui.getInput().isEmpty()) {
                        ui.setPreviewStatus(FeedbackHelp.HELP);
                    }
                    return;
                }

                // Activate next help page using left/right keys
                // (but only when the input box is empty)
                case LEFT :
                case RIGHT : {
                    if (ui.getInput().isEmpty()) {
                        ui.nextHelpPage();
                    }
                    return;
                }

                // Hide help
                case ESCAPE : {
                    ui.hideHelpOverlay();
                    if (ui.getInput().trim().isEmpty()) {
                        ui.setPreviewStatus(FEEDBACK_READY);
                    }
                    return;
                }

                default :
                    break;
            }
        };
    }

    // Main command preview flow
    private ChangeListener<String> createUserInputListener() {
        return (observable, oldValue, newValue) -> {
            if (newValue.trim().isEmpty()) {
                ui.setPreviewStatus(FEEDBACK_READY);
            } else {
                ui.setPreviewStatus(previewCommand(newValue));
            }
        };
    }

    // Listen for exit invoked by close button or system tray
    private ChangeListener<Boolean> createIsExitListener() {
        return (observable, oldValue, newValue) -> {
            if (newValue.booleanValue()) {
                if (!exit()) {
                    ui.resetIsExit();
                    ui.setPreviewStatus(Feedback.FEEDBACK_TRY_AGAIN);
                }
            }
        };
    }

    // ================================================================================
    // Utility methods
    // ================================================================================

    private String execute(Command command) {
        return command.run(ui, taskEngine);
    }

    // Exit routine used by exit command, close button and system tray
    private boolean exit() {
        if (hasStartupError) {
            hideAndTerminate();
        }

        if (!taskEngine.hasPreviousOperation()) {
            hideAndTerminate(); // No write operations; safe to exit
        }

        boolean success = taskEngine.save(); // Try to write state to file
        if (success) {
            hideAndTerminate(); // Write success; safe to exit
        }

        // Write failure; create confirmation dialog to warn user
        boolean exitAnyway = ui.createErrorDialogWithConfirmation(ERROR_EXIT_HEADER,
                ERROR_EXIT_MESSAGE, ERROR_EXIT_BUTTON_LABEL);
        if (exitAnyway) {
            hideAndTerminate(); // User chose to exit anyway despite save failure
        }

        return false; // User pressed cancel
    }

    // Simulate faster exit by hiding window first
    private void hideAndTerminate() {
        ui.hide();
        System.exit(0);
    }

    private boolean isValidLineNumber(int lineNumber) {
        return (lineNumber >= 1 && lineNumber <= getCurrentTaskList().size());
    }

    private Task getTaskFromLineNumber(int lineNumber) {
        return getCurrentTaskList().get(lineNumber - 1);
    }

    private List<Task> getCurrentTaskList() {
        return taskEngine.getCurrentTaskList();
    }

}
```
###### Procrastinate/src/procrastinate/task/DateAdapter.java
``` java
package procrastinate.task;

import java.lang.reflect.Type;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.TimeZone;

import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonParseException;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;

public class DateAdapter implements JsonSerializer<Date>, JsonDeserializer<Date> {

    private static final DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", Locale.US);

    public DateAdapter() {
        dateFormat.setTimeZone(TimeZone.getTimeZone("UTC"));
    }

    @Override
    public JsonElement serialize(Date date, Type typeOfT, JsonSerializationContext context) {
        return new JsonPrimitive(dateFormat.format(date));
    }

    @Override
    public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {
        try {
            return dateFormat.parse(json.getAsString());
        } catch (ParseException e) {
            throw new JsonParseException(e);
        }
    }

}
```
###### Procrastinate/src/procrastinate/task/Deadline.java
``` java
package procrastinate.task;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.UUID;

import com.google.gson.annotations.SerializedName;

public class Deadline extends Task {

    protected static final String FIELD_DATE = "date";

    private static final String dateStringFormat = " due %1$s";

    private static final DateFormat dateFormatter = new SimpleDateFormat("d/MM/yy h:mma");

    @SerializedName(FIELD_DATE)
	private Date date_;

	public Deadline(String description, Date date) {
		super(TaskType.DEADLINE, description);
		this.date_ = date;
	}

	protected Deadline(String description, Date date, boolean isDone, UUID id) {
		super(TaskType.DEADLINE, description, isDone, id);
		this.date_ = date;
	}

	public void setDate(Date date) {
		date_ = date;
	}

	public Date getDate() {
		return date_;
	}

	@Override
    public String getDateString() {
	    return String.format(dateStringFormat, dateFormatter.format(date_));
	}

    @Override
    public boolean isWithin(Date startDate, Date endDate) {
        assert (endDate.compareTo(startDate) >= 0);
        return date_.compareTo(startDate) >= 0 && date_.compareTo(endDate) < 0;
    }

    @Override
    public int compareTo(Task other) {
        int superResult = super.compareTo(other);
        if (superResult != 0) {
            return superResult;
        }
        if (other.getType() == TaskType.DREAM) {
            return -1;
        } else {
            Date otherDate = null;
            if (other.getType() == TaskType.DEADLINE) {
                otherDate = ((Deadline) other).date_;
            } else {
                otherDate = ((Event) other).getStartDate();
            }
            if (!date_.equals(otherDate)) {
                if (isDone()) {
                    return -1 * date_.compareTo(otherDate); // flip order for done tasks
                } else {
                    return date_.compareTo(otherDate);
                }
            } else {
                return getDescription().compareTo(other.getDescription());
            }
        }
    }

    @Override
    public boolean equals(Object other) {
        if (other == null) {
            return false;
        }
        if (other == this) {
            return true;
        }
        if (!(other instanceof Deadline)) {
            return false;
        }
        if (!super.equals(other)) {
            return false;
        }
        Deadline otherDeadline = (Deadline) other;
        return otherDeadline.date_.equals(date_);
    }
}
```
###### Procrastinate/src/procrastinate/task/Dream.java
``` java
package procrastinate.task;

import java.util.Date;
import java.util.UUID;

public class Dream extends Task {

	public Dream(String description) {
		super(TaskType.DREAM, description);
	}

	protected Dream(String description, boolean isDone, UUID id) {
		super(TaskType.DREAM, description, isDone, id);
	}

    @Override
    public String getDateString() {
        return "";
    }

    @Override
    public boolean isWithin(Date startDate, Date endDate) {
        return false;
    }

    @Override
    public int compareTo(Task other) {
        int superResult = super.compareTo(other);
        if (superResult != 0) {
            return superResult;
        }
        if (other.getType() != TaskType.DREAM) {
            return 1;
        } else {
            return this.getDescription().compareTo(other.getDescription());
        }
    }

    @Override
    public boolean equals(Object other) {
        if (other == null) {
            return false;
        }
        if (other == this) {
            return true;
        }
        if (!(other instanceof Dream)) {
            return false;
        }
        if (!super.equals(other)) {
            return false;
        }
        return true;
    }
}
```
###### Procrastinate/src/procrastinate/task/Event.java
``` java
package procrastinate.task;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.UUID;

import com.google.gson.annotations.SerializedName;

public class Event extends Task {

    protected static final String FIELD_START_DATE = "startDate";
    protected static final String FIELD_END_DATE = "endDate";

    private static final String dateStringFormat = " from %1$s to %2$s";

    private static final DateFormat dateFormatter = new SimpleDateFormat("d/MM/yy h:mma");

    @SerializedName(FIELD_START_DATE)
	private Date startDate_;
    @SerializedName(FIELD_END_DATE)
	private Date endDate_;

	public Event(String description, Date startDate, Date endDate) {
		super(TaskType.EVENT, description);
        assert(endDate.compareTo(startDate) >= 0);
		this.startDate_ = startDate;
		this.endDate_ = endDate;
	}

	protected Event(String description, Date startDate, Date endDate, boolean isDone, UUID id) {
		super(TaskType.EVENT, description, isDone, id);
        assert(endDate.compareTo(startDate) >= 0);
		this.startDate_ = startDate;
		this.endDate_ = endDate;
	}

	public Date getStartDate() {
		return startDate_;
	}

	public Date getEndDate() {
		return endDate_;
	}

    @Override
    public String getDateString() {
        return String.format(dateStringFormat, dateFormatter.format(startDate_), dateFormatter.format(endDate_));
    }

    @Override
    public boolean isWithin(Date startDate, Date endDate) {
        assert (endDate.compareTo(startDate) >= 0);
        return startDate_.compareTo(startDate) >= 0 && startDate_.compareTo(endDate) < 0
                || endDate_.compareTo(startDate) >= 0 && endDate_.compareTo(endDate) < 0;
    }

	@Override
    public int compareTo(Task other) {
        int superResult = super.compareTo(other);
        if (superResult != 0) {
            return superResult;
        }
	    if (other.getType() == TaskType.DREAM) {
	        return -1;
	    } else {
	        Date otherDate = null;
	        Date otherEndDate = null;
	        if (other.getType() == TaskType.DEADLINE) {
	            otherDate = ((Deadline) other).getDate();
	        } else {
	            otherDate = ((Event) other).startDate_;
	            otherEndDate = ((Event) other).endDate_;
	        }
	        if (!startDate_.equals(otherDate)) {
                if (isDone()) {
                    return -1 * startDate_.compareTo(otherDate); // flip order for done tasks
                } else {
                    return startDate_.compareTo(otherDate);
                }
	        } else if (otherEndDate != null && !endDate_.equals(otherEndDate)) {
	            return endDate_.compareTo(otherEndDate);
	        } else {
	            return getDescription().compareTo(other.getDescription());
	        }
	    }
	}

    @Override
    public boolean equals(Object other) {
        if (other == null) {
            return false;
        }
        if (other == this) {
            return true;
        }
        if (!(other instanceof Event)) {
            return false;
        }
        if (!super.equals(other)) {
            return false;
        }
        Event otherEvent = (Event) other;
        return otherEvent.startDate_.equals(startDate_) && otherEvent.endDate_.equals(endDate_);
    }
}
```
###### Procrastinate/src/procrastinate/task/Task.java
``` java
package procrastinate.task;

import java.util.Date;
import java.util.UUID;

import com.google.gson.annotations.SerializedName;

public abstract class Task implements Comparable<Task> {

    public static enum TaskType {
        DEADLINE, EVENT, DREAM;
    }

    protected static final String FIELD_TYPE = "type";
    protected static final String FIELD_ID = "id";
    protected static final String FIELD_DESCRIPTION = "description";
    protected static final String FIELD_DONE = "done";

    private static final String ERROR_UNKNOWN_TYPE = "Error: unknown task type";

	@SerializedName(FIELD_TYPE)
	private final TaskType type_; // Cannot change type; subclass object already created
    @SerializedName(FIELD_ID)
    private UUID id_;
    @SerializedName(FIELD_DESCRIPTION)
	private String description_;
    @SerializedName(FIELD_DONE)
	private boolean isDone_;

```
###### Procrastinate/src/procrastinate/task/TaskDeserializer.java
``` java
package procrastinate.task;

import java.lang.reflect.Type;
import java.util.Date;
import java.util.UUID;

import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import procrastinate.task.Task.TaskType;

public class TaskDeserializer implements JsonDeserializer<Task> {

	/**
	 * Task is abstract class so gson is unable to construct a list of Task
	 * Therefore this method is overridden to allow custom deserialization
	 * A new task is constructed depending on the type that is read
	 */
	@Override
	public Task deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
			throws JsonParseException {

	    JsonObject jsonObject = json.getAsJsonObject();

	    String type = null;
	    String description = null;
	    boolean isDone = false;
	    UUID id = null;

        try {
            id = UUID.fromString(jsonObject.get(Task.FIELD_ID).getAsString());
        } catch (Exception e) {
            id = UUID.randomUUID(); // generate new UUID instead of crashing
        }

        try {
            isDone = jsonObject.get(Task.FIELD_DONE).getAsBoolean();
        } catch (Exception e) {
            isDone = false; // assume not done instead of crashing
        }

        try {
            description = jsonObject.get(Task.FIELD_DESCRIPTION).getAsString();
        } catch (Exception e) {
            description = ""; // empty description instead of crashing
        }

	    try {
	        // type as in the variable, type in Task class
	        type = jsonObject.get(Task.FIELD_TYPE).getAsString();
	    } catch (Exception e) {
	        type = TaskType.DREAM.toString(); // assume Dream instead of crashing
	    }

		if (type.equals(TaskType.DREAM.toString())) {
			return new Dream(description, isDone, id);

		} else if (type.equals(TaskType.DEADLINE.toString())) {
	        Date date = null;

            try {
                date = context.deserialize(jsonObject.get(Deadline.FIELD_DATE), Date.class);
            } catch (Exception e) {
                e.printStackTrace();
                return new Dream(description, isDone, id);
            }

			return new Deadline(description, date, isDone, id);

		} else if (type.equals(TaskType.EVENT.toString())) {
		    Date startDate = null;
		    Date endDate = null;

            try {
                startDate = context.deserialize(jsonObject.get(Event.FIELD_START_DATE), Date.class);
                endDate = context.deserialize(jsonObject.get(Event.FIELD_END_DATE), Date.class);

                if (endDate.before(startDate)) { // encountered invalid range
                    endDate = startDate; // use start date as both start and end date
                }
            } catch (Exception e) {
                e.printStackTrace();
                return new Dream(description, isDone, id);
            }

            return new Event(description, startDate, endDate, isDone, id);

		} else {
		    return new Dream(description, isDone, id); // if unrecognised, default to dream
		}

	}
}
```
###### Procrastinate/src/procrastinate/task/TaskEngine.java
``` java
package procrastinate.task;

import java.io.File;
import java.io.IOException;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.UUID;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import procrastinate.FileHandler;

public class TaskEngine {

    // ================================================================================
    // Class variables
    // ================================================================================

    private static final Logger logger = Logger.getLogger(TaskEngine.class.getName());

    // ================================================================================
    // Message strings
    // ================================================================================

    private static final String DEBUG_TASK_ENGINE_INIT = "TaskEngine initialised.";
    private static final String DEBUG_ADDED_TASK = "Added %1$s: %2$s";
    private static final String DEBUG_EDITED_TASK = "Edited #%1$s: %2$s";
    private static final String DEBUG_DELETED_TASK = "Deleted %1$s: %2$s";
    private static final String DEBUG_DONE_TASK = "Done %1$s: %2$s";
    private static final String DEBUG_UNDONE_TASK = "Undone %1$s: %2$s";
    private static final String DEBUG_UNDONE = "Last task operation undone";

    private static final String ERROR_TASK_NOT_FOUND = "Task not found!";

    // ================================================================================
    // Instance variables
    // ================================================================================

    protected FileHandler fileHandler;

    private TaskState previousState_ = null;
    private TaskState currentState_ = null;
    private TaskState currentView_ = null;

    private boolean isPreviousOperationSet_ = false;
    private String previousSaveDirectory_ = null;
    private String previousSaveFilename_ = null;

    // ================================================================================
    // Constructor
    // ================================================================================

    public TaskEngine() throws IOException {
        initFileHandler();
        initTasks();
        logger.log(Level.INFO, DEBUG_TASK_ENGINE_INIT);
    }

    // ================================================================================
    // TaskEngine methods
    // ================================================================================

    public boolean add(Task task) {
        backupOlderState();

        String description = task.getDescription();
        String type = task.getTypeString();

        getTasks().add(task);

        logger.log(Level.INFO, String.format(DEBUG_ADDED_TASK, type, description));

        return writeStateToFile();
    }

    public boolean edit(UUID taskId, Task newTask) {
        backupOlderState();

        int index = getIndexFromId(taskId);
        getTasks().remove(index);
        getTasks().add(index, newTask);

        logger.log(Level.INFO, String.format(DEBUG_EDITED_TASK, index + 1, newTask.getDescription()));

        return writeStateToFile();
    }

    public boolean delete(UUID taskId) {
        backupOlderState();

        int index = getIndexFromId(taskId);
        Task task = getTasks().get(index);
        getTasks().remove(index);

        String description = task.getDescription();
        String type = task.getTypeString();

        logger.log(Level.INFO, String.format(DEBUG_DELETED_TASK, type, description));

        return writeStateToFile();
    }

    public boolean done(UUID taskId) {
        backupOlderState();

        int index = getIndexFromId(taskId);
        Task task = Task.copy(getTasks().get(index));
        task.setDone(!task.isDone());
        getTasks().remove(index);
        getTasks().add(index, task);

        String description = task.getDescription();
        String type = task.getTypeString();
        String feedback;

        if (task.isDone()) {
            feedback = DEBUG_DONE_TASK;
        } else {
            feedback = DEBUG_UNDONE_TASK;
        }

        logger.log(Level.INFO, String.format(feedback, type, description));

        return writeStateToFile();
    }

    public boolean undo() {
        if (isPreviousOperationSet_) {
            return set(previousSaveDirectory_, previousSaveFilename_);
        }

        if (!hasPreviousOperation()) {
            return true;
        }

        TaskState backupNewerState = getBackupOfCurrentState();
        restoreOlderState();
        previousState_ = backupNewerState;

        logger.log(Level.INFO, String.format(DEBUG_UNDONE));

        return writeStateToFile();
    }

    public boolean save() {
        return writeStateToFile();
    }

    public boolean set(String directory, String filename) {
        isPreviousOperationSet_ = true;
        File previousSaveFile = fileHandler.getSaveFile();
        previousSaveDirectory_ = previousSaveFile.getAbsoluteFile().getParent() + File.separator;
        previousSaveFilename_ = previousSaveFile.getName();
        return fileHandler.setPath(directory, filename);
    }

    public boolean hasPreviousOperation() {
        return previousState_ != null || isPreviousOperationSet_;
    }

    public List<Task> search(String description, Date startDate, Date endDate, boolean showDone) {
        assert(description != null || startDate != null && endDate != null);
        List<Task> results = getTasks();
        if (description != null) {
            results = results.stream()
                    .filter(task -> task.contains(description))
                    .collect(Collectors.toList());
        }
        if (startDate != null) {
            results = results.stream()
                    .filter(task -> task.isWithin(startDate, endDate))
                    .collect(Collectors.toList());
        }
        if (!showDone) {
            results = results.stream()
                    .filter(task -> !task.isDone())
                    .collect(Collectors.toList());
        }
        currentView_ = new TaskState(results);
        return currentView_.getTasks();
    }

    public List<Task> getOutstandingTasks() {
        List<Task> outstandingTasks = getTasks().stream()
                .filter(task -> !task.isDone())
                .collect(Collectors.toList());
        currentView_ = new TaskState(outstandingTasks);
        return currentView_.getTasks();
    }

    public List<Task> getCompletedTasks() {
        List<Task> completedTasks = getTasks().stream()
                .filter(task -> task.isDone())
                .collect(Collectors.toList());
        currentView_ = new TaskState(completedTasks);
        return currentView_.getTasks();
    }

    public List<Task> getAllTasks() {
        currentView_ = currentState_;
        return currentView_.getTasks();
    }

    public List<Task> getCurrentTaskList() {
        return currentView_.getTasks();
    }

    // ================================================================================
    // Init methods
    // ================================================================================

    protected void initFileHandler() throws IOException {
        fileHandler = new FileHandler();
    }

    private void initTasks() {
        loadState(fileHandler.loadTaskState());
        currentView_ = currentState_;
        Collections.sort(getTasks());
    }

    // ================================================================================
    // State handling methods
    // ================================================================================

    private void backupOlderState() {
        previousState_ = getBackupOfCurrentState();
        isPreviousOperationSet_ = false;
    }

    private void restoreOlderState() {
        loadState(previousState_);
    }

    private void loadState(TaskState state) {
        currentState_ = state;
    }

    private boolean writeStateToFile() {
        return fileHandler.saveTaskState(getCurrentState());
    }

    private TaskState getBackupOfCurrentState() {
        return TaskState.copy(getCurrentState());
    }

    private TaskState getCurrentState() {
        Collections.sort(getTasks());
        return currentState_;
    }

    // ================================================================================
    // Utility methods
    // ================================================================================

    private int getIndexFromId(UUID id) {
        for (int i = 0; i < getTasks().size(); i++) {
            if (getTasks().get(i).getId().equals(id)) {
                return i;
            }
        }
        throw new Error(ERROR_TASK_NOT_FOUND);
    }

    private List<Task> getTasks() {
        return currentState_.getTasks();
    }

}
```
###### Procrastinate/src/procrastinate/task/TaskState.java
``` java
package procrastinate.task;

import java.util.ArrayList;
import java.util.List;

import com.google.gson.annotations.SerializedName;

public class TaskState {

    protected static final String FIELD_TASKS = "tasks";

    @SerializedName(FIELD_TASKS)
    private List<Task> tasks_;

    public TaskState() {
        this.tasks_ = new ArrayList<Task>();
    }

    public TaskState(List<Task> tasks) {
        this.tasks_ = tasks;
    }

    public static TaskState copy(TaskState other) {
        return new TaskState(new ArrayList<Task>(other.tasks_));
    }

    public List<Task> getTasks() {
        return tasks_;
    }

```
###### Procrastinate/src/procrastinate/test/LogicTest.java
``` java
package procrastinate.test;

import static org.junit.Assert.assertEquals;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.List;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import procrastinate.Logic;
import procrastinate.task.Deadline;
import procrastinate.task.Dream;
import procrastinate.task.Event;
import procrastinate.task.Task;

public class LogicTest {

    private static SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yy");

    private Logic logic;
    private UIStub uiStub;

    @Before
    public void setUp() throws Exception {
        System.out.println("Setting up test...");
        uiStub = new UIStub();
        logic = new LogicUnit(uiStub);
    }

    @After
    public void tearDown() throws Exception {
        System.out.println("Tearing down. Final state:");
        System.out.println(getResults());
        System.out.println("Test completed!\n");
    }

    @Test
    public void previewTest() {
        assertEquals(preview("exit"), "Goodbye!");
        assertEquals(preview("help"), "Showing help screen (use left/right keys to navigate)");
        assertEquals(preview("show"), "Showing outstanding tasks");
        assertEquals(preview("show done"), "Showing completed tasks");
        assertEquals(preview("show all"), "Showing all tasks");
        assertEquals(preview("show summary"), "Showing summary of outstanding tasks");
        assertEquals(preview("search abc"), "Searching for tasks containing 'abc'");
    }

    @Test
    public void addTest() throws ParseException {
        execute("dream");
        execute("deadline due 10/13/17 0");
        execute("event from 10/14/17 to 10/15/17 0");
        execute("another dream");
        execute("urgent deadline due 10/13/16 0");
        List<Task> expected = new ArrayList<Task>();
        expected.add(new Deadline("urgent deadline", sdf.parse("10/13/16")));
        expected.add(new Deadline("deadline", sdf.parse("10/13/17")));
        expected.add(new Event("event", sdf.parse("10/14/17"), sdf.parse("10/15/17")));
        expected.add(new Dream("another dream"));
        expected.add(new Dream("dream"));
        assertEquals(expected, getResults());
    }

    @Test
    public void editTest() throws ParseException {
        assertEquals(preview("edit 1"), "Invalid line number: 1");

        execute("dream");
        assertEquals(preview("edit 1"), "Please specify the new description/date(s) or press tab");

        // edit description
        execute("edit 1 dream edited");
        List<Task> expected = new ArrayList<Task>();
        expected.add(new Dream("dream edited"));
        assertEquals(expected, getResults());

        // edit to event
        execute("edit 1 from 10/14/17 to 10/15/17 0");
        expected.clear();
        expected.add(new Event("dream edited", sdf.parse("10/14/17"), sdf.parse("10/15/17")));
        assertEquals(expected, getResults());

        // edit to event with new description
        execute("edit 1 event from 10/14/17 to 10/15/17 0");
        expected.clear();
        expected.add(new Event("event", sdf.parse("10/14/17"), sdf.parse("10/15/17")));
        assertEquals(expected, getResults());

        // edit to deadline
        execute("edit 1 due 10/13/17 0");
        expected.clear();
        expected.add(new Deadline("event", sdf.parse("10/13/17")));
        assertEquals(expected, getResults());

        // edit to deadline with new description
        execute("edit 1 deadline due 10/13/17 0");
        expected.clear();
        expected.add(new Deadline("deadline", sdf.parse("10/13/17")));
        assertEquals(expected, getResults());

        // edit back to dream
        execute("edit 1 eventually");
        expected.clear();
        expected.add(new Dream("deadline"));
        assertEquals(expected, getResults());
    }

    @Test
    public void deleteUndoTest() {
        assertEquals(preview("undo"), "Nothing to undo");

        execute("a");
        execute("b");
        execute("c");

        assertEquals(preview("delete 3"), "Deleted dream: c");
        assertEquals(preview("delete 4"), "Invalid line number: 4");

        execute("delete 2");
        List<Task> expected = new ArrayList<Task>();
        expected.add(new Dream("a"));
        expected.add(new Dream("c"));
        assertEquals(expected, getResults());
        assertEquals(preview("delete 3"), "Invalid line number: 3");

        execute("undo");
        expected.add(1, new Dream("b"));
        assertEquals(expected, getResults());
        assertEquals(preview("delete 3"), "Deleted dream: c");
    }

    @Test
    public void doneTest() {
        execute("a");
        execute("show all");

        execute("done 1");
        List<Task> expected = new ArrayList<Task>();
        expected.add(new Dream("a"));
        expected.get(0).setDone(true);
        assertEquals(expected, getResults());

        execute("done 1");
        expected.get(0).setDone(false);
        assertEquals(expected, getResults());
    }

    @Test
    public void showTest() {
        execute("a");
        execute("b");
        execute("c");
        execute("d");
        execute("e");
        execute("done 3"); // done c
        execute("done 3"); // done d

        execute("show done");
        List<Task> expected = new ArrayList<Task>();
        expected.add(new Dream("c"));
        expected.add(new Dream("d"));
        expected.get(0).setDone(true);
        expected.get(1).setDone(true);
        assertEquals(expected, getResults());

        execute("show");
        expected.clear();
        expected.add(new Dream("a"));
        expected.add(new Dream("b"));
        expected.add(new Dream("e"));
        assertEquals(expected, getResults());

        execute("show all");
        expected.clear();
        expected.add(new Dream("a"));
        expected.add(new Dream("b"));
        expected.add(new Dream("e"));
        expected.add(new Dream("c"));
        expected.add(new Dream("d"));
        expected.get(3).setDone(true); // done c
        expected.get(4).setDone(true); // done d
        assertEquals(expected, getResults());
    }

```
###### Procrastinate/src/procrastinate/test/LogicUnit.java
``` java
package procrastinate.test;

import java.io.IOException;

import procrastinate.Logic;

public class LogicUnit extends Logic {
    public LogicUnit(UIStub uiStub) {
        ui = uiStub;
    }
    @Override
    protected void initTaskEngine() {
        try {
            taskEngine = new TaskEngineUnit();
        } catch (IOException e) {
        }
    }
}
```
###### Procrastinate/src/procrastinate/test/TaskEngineUnit.java
``` java
package procrastinate.test;

import java.io.IOException;

import procrastinate.task.TaskEngine;

public class TaskEngineUnit extends TaskEngine {
    public TaskEngineUnit() throws IOException {
    }
    @Override
    protected void initFileHandler() {
        fileHandler = new FileHandlerStub();
    }
}
```
###### Procrastinate/src/procrastinate/test/UIStub.java
``` java
package procrastinate.test;

import java.util.ArrayList;
import java.util.List;

import javafx.beans.value.ChangeListener;
import javafx.event.EventHandler;
import javafx.scene.input.KeyEvent;
import javafx.stage.Stage;
import procrastinate.task.Task;
import procrastinate.ui.UI;

public class UIStub extends UI {
    private List<Task> taskList_;
    public UIStub() {
        taskList_ = new ArrayList<Task>();
    }
    public UIStub(Stage stage) {
    }
    public List<Task> getTaskList() {
        return taskList_;
    }
    @Override
    public String getInput() {
        return null;
    }
    @Override
    public void setInput(String input) {
    }
    @Override
    public void clearInput() {
    }
    @Override
    public void setPreviewStatus(String status) {
    }
    @Override
    public void setExecuteStatus(String status) {
    }
    @Override
    public String fitToStatus(String before, String text, String after) {
        return before + text + after;
    }
    @Override
    public void initialUpdateTaskList(List<Task> taskList) {
    }
    @Override
    public void updateTaskList(List<Task> taskList, ScreenView screenView) {
        taskList_ = taskList;
    }
    @Override
    public void resetIsExit() {
    }
    @Override
    public void attachHandlersAndListeners(EventHandler<KeyEvent> keyPressHandler,
            ChangeListener<String> userInputListener, ChangeListener<Boolean> isExitListener) {
    }
    @Override
    public void hide() {
    }
    @Override
    public void passSearchStringToSearchScreen(String searchTerm) {
    }
    @Override
    public void showHelpOverlay() {
    }
    @Override
    public void nextHelpPage() {
    }
    @Override
    public void hideHelpOverlay() {
    }
    @Override
    public void hideSplashOverlay() {
    }
    @Override
    public void scrollUpScreen() {
    }
    @Override
    public void scrollDownScreen() {
    }
    @Override
    public void createErrorDialog(String header, String message) {
    }
    @Override
    public void createErrorDialogWithTrace(Exception e) {
    }
    @Override
    public boolean createErrorDialogWithConfirmation(String header, String message, String okLabel) {
        return true;
    }
}
```
###### Procrastinate/src/procrastinate/ui/HelpOverlay.java
``` java
    protected void nextPage() {
        if (isFirstPage_) {
            imageView.setImage(new Image(HelpOverlay.class.getResource(LOCATION_REFERENCE_SHEET_2).toExternalForm()));
        } else {
            imageView.setImage(new Image(HelpOverlay.class.getResource(LOCATION_REFERENCE_SHEET).toExternalForm()));
        }

        isFirstPage_ = !isFirstPage_;
    }

    // ================================================================================
    // Init Methods
    // ================================================================================

```
###### Procrastinate/src/procrastinate/ui/SummaryScreen.java
``` java
    protected boolean isSummarising() {
        return isSummarising_;
    }

```
###### Procrastinate/src/procrastinate/ui/SummaryScreen.java
``` java
    private void setupSummaryView(List<Task> taskList) {
        double currMainVBoxHeight = getCurrentMainVBoxHeight();
        double maxMainVBoxHeight = ((ScrollPane) getNode().lookup(SELECTOR_SCROLLPANE)).getHeight();

        if (taskList.isEmpty()) {
            isSummarising_ = true;
            return;
        }

        if (currMainVBoxHeight < maxMainVBoxHeight) {
            isSummarising_ = false;
            return;
        }

        isSummarising_ = true;

        // shortenTaskDescription is the first step
        clearTaskList();
        for (Task task : taskList) {
            taskCount.set(taskCount.get() + 1);
            addTaskByType(shortenTaskDescription(task));
        }
        updateDisplay();

        if (getCurrentMainVBoxHeight() < maxMainVBoxHeight) {
            return;
        }

        resizeScreenToFit(maxMainVBoxHeight);
    }

    /**
     * Calculates the number of partitions to split the screen in order to fit
     * the maxMainVBoxHeight and resizes each category to a given size depending
     * on their PartitionCount declared above.
     *
     * @param maxMainVBoxHeight    the height to resize the screen to fit into
     */
```
###### Procrastinate/src/procrastinate/ui/SummaryScreen.java
``` java
    private Task shortenTaskDescription(Task task) {
        String description = task.getDescription();
        if (description.length() > DESCRIPTION_MAX_LENGTH) {
            task = Task.copy(task);
            task.setDescription(description.substring(0, DESCRIPTION_MAX_LENGTH
                                                         - DESCRIPTION_ELLIPSIS_LENGTH) + DESCRIPTION_ELLIPSIS_STRING);
        }
        return task;
    }
}
```
###### Procrastinate/src/procrastinate/ui/UI.java
``` java
    public void setPreviewStatus(String status) {
        Platform.runLater(() -> {
            getStatusLabel().setStyle("-fx-text-fill: #365fac");
            statusLabelText_.set(status);
        });
    }

    public void setExecuteStatus(String status) {
        Platform.runLater(() -> {
            getStatusLabel().setStyle("-fx-text-fill: black");
            statusLabelText_.set(status);
        });
    }

    public String fitToStatus(String before, String text, String after) {
        if (canFitStatus(before + text + after)) {
            return before + text + after;
        }
        String grow = "";
        for (int i = 0; i < text.length(); i++) {
            char nextChar = text.charAt(i);
            if (!canFitStatus(before + grow + nextChar + ELLIPSIS + after)) {
                break;
            }
            grow += nextChar;
        }
        return before + grow + ELLIPSIS + after;
    }

    public void initialUpdateTaskList(List<Task> taskList) {
        centerPaneController_.initialUpdateMainScreen(taskList);
    }

```
###### Procrastinate/src/procrastinate/ui/UI.java
``` java
    public boolean createErrorDialogWithConfirmation(String header, String message, String okLabel) {
        boolean result = false;
        if (!Platform.isFxApplicationThread()) {
            FutureTask<Boolean> query = new FutureTask<Boolean>(new Callable<Boolean>() {
                @Override
                public Boolean call() throws Exception {
                    return dialogPopupHandler_.createErrorDialogPopupWithConfirmation(header, message, okLabel);
                }
            });
            Platform.runLater(query);

            try {
                result = query.get();
            } catch (Exception e) {
                e.printStackTrace();
            }

        } else {
            result = dialogPopupHandler_.createErrorDialogPopupWithConfirmation(header, message, okLabel);
        }
        return result;
    }

    // ================================================================================
    // Init Methods
    // ================================================================================

```
###### Procrastinate/src/procrastinate/ui/UI.java
``` java
    private Label getStatusLabel() {
        return windowHandler_.getStatusLabel();
    }

    private boolean canFitStatus(String status) {
        double width = Toolkit.getToolkit().getFontLoader().computeStringWidth(status, getStatusLabel().getFont());
        double maxWidth = getUserInputField().getWidth();
        return width < maxWidth;
    }

}
```
