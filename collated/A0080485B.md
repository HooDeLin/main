# A0080485B
###### Procrastinate/src/procrastinate/Command.java
``` java
package procrastinate;

import java.util.Date;

public class Command {

    public static enum CommandType {
        ADD_DEADLINE, ADD_EVENT, ADD_DREAM, EDIT, EDIT_PARTIAL, EDIT_TO_DREAM, DELETE, UNDO, DONE,
        SEARCH, SEARCH_ON, SHOW_OUTSTANDING, SHOW_DONE, SHOW_ALL, SHOW_SUMMARY,
        SET_PATH, EXIT, HELP, INVALID;
    }

    // Required field for all command types
    private CommandType type_;

    // Optional fields; availability depends on command type
    private String description_;
    private Date date_;
    private Date startDate_;
    private Date endDate_;
    private int lineNumber_;
    private String pathDirectory_;
    private String pathFilename_;

    public Command(CommandType type) {
        this.type_ = type;
    }

    // ================================================================================
    // Setter methods (using chaining)
    // ================================================================================

    public Command addDescription(String description) {
        description_ = description.trim();
        return this;
    }

    public Command addDate(Date date) {
        date_ = date;
        return this;
    }

    public Command addStartDate(Date startDate) {
        startDate_ = startDate;
        return this;
    }

    public Command addEndDate(Date endDate) {
        endDate_ = endDate;
        return this;
    }

    public Command addLineNumber(int lineNumber) {
        lineNumber_ = lineNumber;
        return this;
    }

    public Command addPathDirectory(String pathDirectory) {
        pathDirectory_ = pathDirectory;
        return this;
    }

    public Command addPathFilename(String fileName) {
        pathFilename_ = fileName;
        return this;
    }

    // ================================================================================
    // Getter methods
    // ================================================================================

    public CommandType getType() {
        return type_;
    }

    public String getDescription() {
        return description_;
    }

    public Date getDate() {
        return date_;
    }

    public Date getStartDate() {
        return startDate_;
    }

    public Date getEndDate() {
        return endDate_;
    }

    public int getLineNumber() {
        return lineNumber_;
    }

    public String getPathDirectory() {
        return pathDirectory_;
    }

    public String getPathFilename() {
        return pathFilename_;
    }

}
```
###### Procrastinate/src/procrastinate/FileHandler.java
``` java
    public FileHandler(boolean isUnderTest) {
    }

```
###### Procrastinate/src/procrastinate/Logic.java
``` java
package procrastinate;

import java.io.File;
import java.io.IOException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.apache.commons.lang.time.DateUtils;

import javafx.beans.value.ChangeListener;
import javafx.event.EventHandler;
import javafx.scene.input.KeyEvent;
import javafx.stage.Stage;
import procrastinate.Command.CommandType;
import procrastinate.task.Deadline;
import procrastinate.task.Dream;
import procrastinate.task.Event;
import procrastinate.task.Task;
import procrastinate.task.TaskEngine;
import procrastinate.ui.UI;
import procrastinate.ui.UI.ScreenView;

public class Logic {

    private static final Logger logger = Logger.getLogger(Logic.class.getName());

    private static enum ViewType {
        SHOW_OUTSTANDING, SHOW_DONE, SHOW_ALL, SHOW_SUMMARY, SHOW_SEARCH_RESULTS
    }

    // ================================================================================
    // Message strings
    // ================================================================================

    private static final String DEBUG_LOGIC_INIT = "Logic initialised.";

    private static final String NATTY_WARMUP_STRING = "Natty starts up slowly due tomorrow";

    private static final String STATUS_READY = "Ready!";
    private static final String STATUS_PREVIEW_COMMAND = ">>";

    private static final String FEEDBACK_ADD_DREAM = "New dream: ";
    private static final String FEEDBACK_ADD_DEADLINE = "New deadline: %1$s due %2$s";
    private static final String FEEDBACK_ADD_EVENT = "New event: %1$s %2$s to %3$s";
    private static final String FEEDBACK_EDIT_DREAM = "Edited #%1$s: %2$s";
    private static final String FEEDBACK_EDIT_DEADLINE = "Edited #%1$s: %2$s due %3$s";
    private static final String FEEDBACK_EDIT_EVENT = "Edited #%1$s: %2$s %3$s to %4$s";
    private static final String FEEDBACK_EDIT_PARTIAL = "Please specify the new description/date(s) or press tab";
    private static final String FEEDBACK_DELETED = "Deleted %1$s: %2$s";
    private static final String FEEDBACK_DONE = "Done %1$s: %2$s";
    private static final String FEEDBACK_UNDONE = "Undone %1$s: %2$s";
    private static final String FEEDBACK_SEARCH = "Searching for tasks";
    private static final String FEEDBACK_SEARCH_CONTAINING = " containing '%1$s'";
    private static final String FEEDBACK_SEARCH_ON = " on %1$s";
    private static final String FEEDBACK_SEARCH_DUE = " due by %1$s";
    private static final String FEEDBACK_SEARCH_FROM_TO = " from %1$s to %2$s";
    private static final String FEEDBACK_INVALID_LINE_NUMBER = "Invalid line number: ";
    private static final String FEEDBACK_INVALID_RANGE = "Invalid dates: %2$s is before %1$s";
    private static final String FEEDBACK_UNDO = "Undid last operation";
    private static final String FEEDBACK_NOTHING_TO_UNDO = "Nothing to undo";
    private static final String FEEDBACK_SET_LOCATION = "Set save location to ";
    private static final String FEEDBACK_HELP = "Showing help screen (use left/right keys to navigate)";
    private static final String FEEDBACK_SHOW_ALL = "Showing all tasks";
    private static final String FEEDBACK_SHOW_DONE = "Showing completed tasks";
    private static final String FEEDBACK_SHOW_OUTSTANDING = "Showing outstanding tasks";
    private static final String FEEDBACK_SHOW_SUMMARY = "Showing summary of outstanding tasks";
    private static final String FEEDBACK_TRY_AGAIN = "Please set a different save location and try again";
    private static final String FEEDBACK_ELLIPSIS = "...";
    private static final String FEEDBACK_EXIT = "Goodbye!";

    private static final String ERROR_STARTUP_HEADER = "There was a problem accessing the directory";
    private static final String ERROR_STARTUP_MESSAGE = "Please startup Procrastinate from a different working directory";
    private static final String ERROR_SAVE_HEADER = "Could not save changes to file!";
    private static final String ERROR_SAVE_MESSAGE = FEEDBACK_TRY_AGAIN;
    private static final String ERROR_EXIT_HEADER = "Could not save changes! Your data will be LOST!";
    private static final String ERROR_EXIT_MESSAGE = "Discard unsaved changes and exit?";
    private static final String ERROR_EXIT_BUTTON_LABEL = "Discard and exit";
    private static final String ERROR_SET_LOCATION_HEADER = "Could not set save location:";
    private static final String ERROR_SET_LOCATION_MESSAGE = "%1$s%2$s\n\n" + FEEDBACK_TRY_AGAIN;

    private static final String SEARCH_STRING_DESCRIPTION = "'%1$s'";
    private static final String SEARCH_STRING_NO_DESCRIPTION = "all tasks";
    private static final String SEARCH_STRING_ON = " on ";
    private static final String SEARCH_STRING_DUE = " due ";
    private static final String SEARCH_STRING_FROM_TO = " from %1$s to %2$s";

    private static final int MAX_LENGTH_DESCRIPTION = 20;
    private static final int MAX_LENGTH_DESCRIPTION_SHORT = 10;
    private static final int MAX_LENGTH_DESCRIPTION_TINY = 7;

    private static final DateFormat dateTimeFormatter = new SimpleDateFormat("d/MM/yy h:mma");
    private static final DateFormat dateFormatter = new SimpleDateFormat("d/MM/yy");

    // ================================================================================
    // Class variables
    // ================================================================================

    protected TaskEngine taskEngine;
    protected UI ui;

    private boolean startupError = false;

    private Command lastPreviewedCommand = null;

    private ViewType currentView;

    private String searchString = null;
    private String searchTerm = null;
    private Date searchStartDate = null;
    private Date searchEndDate = null;
    private boolean searchShowDone = true;

    // ================================================================================
    // Singleton pattern
    // ================================================================================

    private static Logic logic;

    protected Logic() {
        initTaskEngine();
        initParser();
        logger.log(Level.INFO, DEBUG_LOGIC_INIT);
    }

    public static Logic getInstance() {
        if (logic == null) {
            logic = new Logic();
        }
        return logic;
    }

    // ================================================================================
    // Logic methods
    // ================================================================================

    public String previewCommand(String userCommand) {
    	lastPreviewedCommand = Parser.parse(userCommand);
        return runCommand(lastPreviewedCommand, false);
    }

    public String executeLastPreviewedCommand() {
    	assert(lastPreviewedCommand != null);
        return runCommand(lastPreviewedCommand, true);
    }

    public boolean hasLastPreviewedCommand() {
    	return lastPreviewedCommand != null;
    }

    private String runCommand(Command command, boolean execute) {

        switch (command.getType()) {

            case ADD_DREAM :
            case ADD_DEADLINE :
            case ADD_EVENT :
                return runAdd(command, execute);

            case EDIT :
            case EDIT_TO_DREAM :
                return runEdit(command, execute);

            case EDIT_PARTIAL :
                return runEditPartial(command);

            case DELETE :
                return runDelete(command, execute);

            case DONE :
                return runDone(command, execute);

            case UNDO :
                return runUndo(execute);

            case SEARCH :
            case SEARCH_ON :
                return runSearch(command, execute);

            case SET_PATH :
                return runSetPath(command, execute);

            case SHOW_OUTSTANDING :
                return runShowOutstanding(execute);

            case SHOW_DONE :
                return runShowDone(execute);

            case SHOW_ALL :
                return runShowAll(execute);

            case SHOW_SUMMARY :
                return runShowSummary(execute);

            case HELP :
                return runHelp(execute);

            case INVALID :
                return runInvalid(command);

            case EXIT :
                return runExit(execute);

            default:
                return null;

        }

    }

    // ================================================================================
    // Command handling methods
    // ================================================================================

    private String runAdd(Command command, boolean execute) {
        String description = command.getDescription();
        assert(description != null);

        Task newTask = null;
        Date date = null;
        Date startDate = null;
        Date endDate = null;

        switch(command.getType()) {
            case ADD_DREAM :
                newTask = new Dream(description);
                break;

            case ADD_DEADLINE :
                date = command.getDate();
                assert(date != null);

                newTask = new Deadline(description, date);
                break;

            case ADD_EVENT :
                startDate = command.getStartDate();
                endDate = command.getEndDate();
                assert(startDate != null && endDate != null);

                if (endDate.before(startDate)) {
                    return String.format(FEEDBACK_INVALID_RANGE, formatDateTime(startDate), formatDateTime(endDate));
                }

                newTask = new Event(description, startDate, endDate);
                break;

            default:
                break;
        }

        if (execute) {
            boolean success = taskEngine.add(newTask);
            updateView(ViewType.SHOW_OUTSTANDING);
            if (!success) {
                ui.createErrorDialog(ERROR_SAVE_HEADER, ERROR_SAVE_MESSAGE);
                return FEEDBACK_TRY_AGAIN;
            }
        }

        switch(command.getType()) {
            case ADD_DREAM :
                return FEEDBACK_ADD_DREAM + description;

            case ADD_DEADLINE :
                return String.format(FEEDBACK_ADD_DEADLINE, shorten(description, MAX_LENGTH_DESCRIPTION),
                        formatDateTime(date));

            case ADD_EVENT :
                return String.format(FEEDBACK_ADD_EVENT, shorten(description, MAX_LENGTH_DESCRIPTION_SHORT),
                        formatDateTime(startDate), formatDateTime(endDate));

            default:
                return null;
        }

    }

    private String runEdit(Command command, boolean execute) {
        int lineNumber = command.getLineNumber();

        if (!isValidLineNumber(lineNumber)) {
            return FEEDBACK_INVALID_LINE_NUMBER + lineNumber;
        }

        Task oldTask = getTaskFromLineNumber(lineNumber);
        String oldDescription = oldTask.getDescription();

        String newDescription = command.getDescription();
        Date newDate = command.getDate();
        Date newStartDate = command.getStartDate();
        Date newEndDate = command.getEndDate();

        Task newTask;

        if (newDate != null) {
            newTask = new Deadline(oldDescription, newDate);

        } else if (newStartDate != null) {
            assert(newEndDate != null);
            if (newEndDate.before(newStartDate)) {
                return String.format(FEEDBACK_INVALID_RANGE,
                        formatDateTime(newStartDate), formatDateTime(newEndDate));
            }

            newTask = new Event(oldDescription, newStartDate, newEndDate);

        } else if (command.getType() == CommandType.EDIT_TO_DREAM) {
            newTask = new Dream(oldDescription);

        } else {
            newTask = Task.copyWithNewId(oldTask);

        }

        if (newDescription != null) {
            newTask.setDescription(newDescription);
        }

        if (execute) {
            boolean success = taskEngine.edit(oldTask.getId(), newTask);
            updateView();
            if (!success) {
                ui.createErrorDialog(ERROR_SAVE_HEADER, ERROR_SAVE_MESSAGE);
                return FEEDBACK_TRY_AGAIN;
            }
        }

        String description = newTask.getDescription();

        switch (newTask.getType()) {
            case DREAM :
                return String.format(FEEDBACK_EDIT_DREAM, lineNumber, description);

            case DEADLINE :
                return String.format(FEEDBACK_EDIT_DEADLINE, lineNumber,
                        shorten(description, MAX_LENGTH_DESCRIPTION),
                        formatDateTime(((Deadline) newTask).getDate()));

            case EVENT :
                return String.format(FEEDBACK_EDIT_EVENT, lineNumber,
                        shorten(description, MAX_LENGTH_DESCRIPTION_TINY),
                        formatDateTime(((Event) newTask).getStartDate()),
                        formatDateTime(((Event) newTask).getEndDate()));

            default:
                return null;
        }
    }

    private String runEditPartial(Command command) {
        int lineNumber = command.getLineNumber();

        if (!isValidLineNumber(lineNumber)) {
            return FEEDBACK_INVALID_LINE_NUMBER + lineNumber;
        }

        return FEEDBACK_EDIT_PARTIAL;
    }

    private String runDelete(Command command, boolean execute) {
        int lineNumber = command.getLineNumber();

        if (!isValidLineNumber(lineNumber)) {
            return FEEDBACK_INVALID_LINE_NUMBER + lineNumber;
        }

        Task task = getTaskFromLineNumber(lineNumber);
        String type = task.getTypeString();
        String description = task.getDescription();

        if (execute) {
            boolean success = taskEngine.delete(task.getId());
            updateView();
            if (!success) {
                ui.createErrorDialog(ERROR_SAVE_HEADER, ERROR_SAVE_MESSAGE);
                return FEEDBACK_TRY_AGAIN;
            }
        }

        return String.format(FEEDBACK_DELETED, type, description);
    }

    private String runDone(Command command, boolean execute) {
        int lineNumber = command.getLineNumber();

        if (!isValidLineNumber(lineNumber)) {
            return FEEDBACK_INVALID_LINE_NUMBER + lineNumber;
        }

        Task task = getTaskFromLineNumber(lineNumber);
        String type = task.getTypeString();
        String description = task.getDescription();
        String feedback;

        if (!task.isDone()) {
            feedback = FEEDBACK_DONE;
        } else {
            feedback = FEEDBACK_UNDONE;
        }

        if (execute) {
            boolean success = taskEngine.done(task.getId());
            updateView();
            if (!success) {
                ui.createErrorDialog(ERROR_SAVE_HEADER, ERROR_SAVE_MESSAGE);
                return FEEDBACK_TRY_AGAIN;
            }
        }

        return String.format(feedback, type, description);
    }

    private String runUndo(boolean execute) {
        if (!taskEngine.hasPreviousOperation()) {
            return FEEDBACK_NOTHING_TO_UNDO;
        }

        if (execute) {
            boolean success = taskEngine.undo();
            updateView();
            if (!success) {
                ui.createErrorDialog(ERROR_SAVE_HEADER, ERROR_SAVE_MESSAGE);
                return FEEDBACK_TRY_AGAIN;
            }
        }

        return FEEDBACK_UNDO;
    }

    private String runSearch(Command command, boolean execute) {
        String description = command.getDescription();
        Date date = command.getDate();
        Date startDate = command.getStartDate();
        Date endDate = command.getEndDate();

        if (execute) {
            searchString = "";
            searchTerm = null;
            searchStartDate = null;
            searchEndDate = null;
            searchShowDone = true;
        }

        String feedback = FEEDBACK_SEARCH;

        if (description != null) {
            feedback += String.format(FEEDBACK_SEARCH_CONTAINING, description);
            if (execute) {
                searchTerm = description;
                searchString += String.format(SEARCH_STRING_DESCRIPTION, description);
            }
        } else {
            if (execute) {
                searchString += SEARCH_STRING_NO_DESCRIPTION;
            }
        }

        if (date != null) {
            searchShowDone = false;

            // set time to 0000 hrs of the specified day
            date = DateUtils.truncate(date, Calendar.DATE);

            if (command.getType() == CommandType.SEARCH_ON) {
                feedback += String.format(FEEDBACK_SEARCH_ON, formatDate(date));
                if (execute) {
                    searchStartDate = date;
                    searchEndDate = DateUtils.addDays(date, 3);
                    searchString += SEARCH_STRING_ON + formatDate(date);
                }

            } else {
                feedback += String.format(FEEDBACK_SEARCH_DUE, formatDate(date));
                if (execute) {
                    searchStartDate = new Date(0); // beginning of time
                    searchEndDate = DateUtils.addDays(date, 3);
                    searchString += SEARCH_STRING_DUE + formatDate(date);
                }

            }

        } else if (startDate != null) {
            assert(endDate != null);

            // set time to 0000 hrs of the specified day
            startDate = DateUtils.truncate(startDate, Calendar.DATE);
            endDate = DateUtils.truncate(endDate, Calendar.DATE);

            if (endDate.before(startDate)) {
                return String.format(FEEDBACK_INVALID_RANGE, formatDate(startDate), formatDate(endDate));
            }

            feedback += String.format(FEEDBACK_SEARCH_FROM_TO, formatDate(startDate), formatDate(endDate));
            if (execute) {
                searchStartDate = startDate;
                searchEndDate = DateUtils.addDays(endDate, 1);;
                searchString += String.format(SEARCH_STRING_FROM_TO, formatDate(startDate), formatDate(endDate));
            }
        }

        if (execute) {
            updateView(ViewType.SHOW_SEARCH_RESULTS);
        }

        return feedback;
    }

    private String runSetPath(Command command, boolean execute) {
        String pathDirectory = command.getPathDirectory();
        String pathFilename = command.getPathFilename();

        String parsedPathDirectory = null;
        File targetDirectory = new File(pathDirectory);

        try {
            parsedPathDirectory = targetDirectory.getCanonicalPath();
        } catch (IOException e) {
            parsedPathDirectory = targetDirectory.getAbsolutePath();
        }

        if (!parsedPathDirectory.endsWith(File.separator)) {
            parsedPathDirectory += File.separator;
        }

        if (pathFilename == null) {
            pathFilename = FileHandler.DEFAULT_FULL_FILENAME;
        }

        if (execute) {
            boolean success = taskEngine.set(parsedPathDirectory, pathFilename);
            if (!success) {
                ui.createErrorDialog(ERROR_SET_LOCATION_HEADER,
                                     String.format(ERROR_SET_LOCATION_MESSAGE,
                                                   parsedPathDirectory, pathFilename));
                return FEEDBACK_TRY_AGAIN;
            }
        }

        return FEEDBACK_SET_LOCATION + parsedPathDirectory + pathFilename;
    }

    private String runShowOutstanding(boolean execute) {
        if (execute) {
            updateView(ViewType.SHOW_OUTSTANDING);
        }
        return FEEDBACK_SHOW_OUTSTANDING;
    }

    private String runShowDone(boolean execute) {
        if (execute) {
            updateView(ViewType.SHOW_DONE);
        }
        return FEEDBACK_SHOW_DONE;
    }

    private String runShowAll(boolean execute) {
        if (execute) {
            updateView(ViewType.SHOW_ALL);
        }
        return FEEDBACK_SHOW_ALL;
    }

    private String runShowSummary(boolean execute) {
        if (execute) {
            updateView(ViewType.SHOW_SUMMARY);
        }
        return FEEDBACK_SHOW_SUMMARY;
    }

    private String runHelp(boolean execute) {
        if (execute) {
            ui.showHelpOverlay();
        }
        return FEEDBACK_HELP;
    }

    private String runInvalid(Command command) {
        return command.getDescription();
    }

    private String runExit(boolean execute) {
        if (execute) {
            if (!exit()) {
                return FEEDBACK_TRY_AGAIN;
            }
        }
        return FEEDBACK_EXIT;
    }

    // ================================================================================
    // Init methods
    // ================================================================================

    // Main handle
    public void initUi(Stage stage) {
        ui = new UI(stage);
        ui.attachHandlersAndListeners(createKeyPressHandler(), createUserInputListener(), createIsExitListener());
        if (startupError) {
            ui.createErrorDialog(ERROR_STARTUP_HEADER, ERROR_STARTUP_MESSAGE);
            exit();
        }
        initUiTaskList();
        ui.setStatus(STATUS_READY);
    }

    protected void initTaskEngine() {
		try {
            taskEngine = new TaskEngine();
        } catch (IOException e) {
            startupError = true;
        }
    }

    private void initParser() {
        Parser.parse(NATTY_WARMUP_STRING);
    }

    // ================================================================================
    // UI Interaction methods
    // ================================================================================

    private void updateView() {
        if (currentView == ViewType.SHOW_SUMMARY) {
            currentView = ViewType.SHOW_OUTSTANDING;
        }
        updateUiTaskList();
    }

    private void updateView(ViewType newView) {
        currentView = newView;
        updateUiTaskList();
    }

    private void updateUiTaskList() {
        switch (currentView) {
            case SHOW_OUTSTANDING :
                ui.updateTaskList(taskEngine.getOutstandingTasks(), ScreenView.SCREEN_MAIN);
                break;

            case SHOW_DONE :
                ui.updateTaskList(taskEngine.getCompletedTasks(), ScreenView.SCREEN_DONE);
                break;

            case SHOW_ALL :
                ui.updateTaskList(taskEngine.getAllTasks(), ScreenView.SCREEN_MAIN);
                break;

            case SHOW_SUMMARY :
                ui.updateTaskList(taskEngine.getOutstandingTasks(), ScreenView.SCREEN_SUMMARY);
                break;

            case SHOW_SEARCH_RESULTS :
                ui.passSearchStringToSearchScreen(searchString);
                ui.updateTaskList(taskEngine.search(searchTerm, searchStartDate, searchEndDate, searchShowDone),
                                  ScreenView.SCREEN_SEARCH);
                break;
        }
    }

    private void initUiTaskList() {
        ui.initialUpdateTaskList(taskEngine.getOutstandingTasks());
        updateView(ViewType.SHOW_SUMMARY);
    }

    // Process key press events
    private EventHandler<KeyEvent> createKeyPressHandler() {
        return (keyEvent) -> {

            // Remove initial splash overlay
            ui.hideSplashOverlay();

            switch (keyEvent.getCode()) {

                // Main command execution flow
                case ENTER : {

                    // Whitespace command
                    if (ui.getInput().trim().isEmpty()) {
                        ui.clearInput();
                        ui.hideHelpOverlay();
                        return;
                    }

                    // Hide help unless it's a help or exit command
                    if (!lastPreviewedCommand.getType().equals(CommandType.HELP)
                            && !lastPreviewedCommand.getType().equals(CommandType.EXIT)) {
                        ui.hideHelpOverlay();
                    }

                    // All the work happens here!
                    String feedback = executeLastPreviewedCommand();

                    // Clear input box and display feedback
                    // ClearInput must come before setStatus as user input listener
                    // resets status when input is cleared
                    ui.clearInput();
                    ui.setStatus(feedback);

                    return;
                }

                // Edit description autocompletion
                case TAB : {
                    if (!hasLastPreviewedCommand()) {
                        return;
                    }

                    Command command = lastPreviewedCommand;
                    if (command.getType() != CommandType.EDIT_PARTIAL) {
                        return;
                    }

                    int lineNumber = lastPreviewedCommand.getLineNumber();

                    if (!isValidLineNumber(lineNumber)) {
                        return;
                    }

                    ui.setInput(ui.getInput().trim() + " " + getTaskFromLineNumber(lineNumber).getDescription());
                    return;
                }

                // Scrolling
                case UP : {
                    ui.scrollUpScreen();
                    return;
                }
                case DOWN : {
                    ui.scrollDownScreen();
                    return;
                }

                // Show help
                case F1 : {
                    ui.showHelpOverlay();
                    if (ui.getInput().isEmpty()) {
                        ui.setStatus(FEEDBACK_HELP);
                    }
                    return;
                }

                // Activate next help page using left/right keys
                // (but only when the input box is empty)
                case LEFT :
                case RIGHT : {
                    if (ui.getInput().isEmpty()) {
                        ui.nextHelpPage();
                    }
                    return;
                }

                // Hide help
                case ESCAPE : {
                    ui.hideHelpOverlay();
                    if (ui.getInput().trim().isEmpty()) {
                        ui.setStatus(STATUS_READY);
                    }
                    return;
                }

                default:
                    break;
            }
        };
    }

    // Main command preview flow
    private ChangeListener<String> createUserInputListener() {
        return (observable, oldValue, newValue) -> {
            if (newValue.trim().isEmpty()) {
                ui.setStatus(STATUS_READY);
            } else {
                ui.setStatus(STATUS_PREVIEW_COMMAND + previewCommand(newValue));
            }
        };
    }

    // Listen for exit invoked by close button or system tray
    private ChangeListener<Boolean> createIsExitListener() {
        return (observable, oldValue, newValue) -> {
            if (newValue.booleanValue()) {
                if (!exit()) {
                    ui.resetIsExit();
                    ui.setStatus(FEEDBACK_TRY_AGAIN);
                }
            }
        };
    }

    // ================================================================================
    // Utility methods
    // ================================================================================

    // Exit routine used by exit command, close button and system tray
    private boolean exit() {
        if (startupError) {
            hideAndTerminate();
        }

        if (!taskEngine.hasPreviousOperation()) {
            hideAndTerminate(); // No write operations; safe to exit
        }

        boolean success = taskEngine.save(); // Try to write state to file
        if (success) {
            hideAndTerminate(); // Write success; safe to exit
        }

        // Write failure; create confirmation dialog to warn user
        boolean exitAnyway = ui.createErrorDialogWithConfirmation(ERROR_EXIT_HEADER,
                ERROR_EXIT_MESSAGE, ERROR_EXIT_BUTTON_LABEL);
        if (exitAnyway) {
            hideAndTerminate(); // User chose to exit anyway despite save failure
        }

        return false; // User pressed cancel
    }

    // Simulate faster exit by hiding window first
    private void hideAndTerminate() {
        ui.hide();
        System.exit(0);
    }

    private boolean isValidLineNumber(int lineNumber) {
        return (lineNumber >= 1 && lineNumber <= getCurrentTaskList().size());
    }

    private Task getTaskFromLineNumber(int lineNumber) {
        return getCurrentTaskList().get(lineNumber - 1);
    }

    private List<Task> getCurrentTaskList() {
        return taskEngine.getCurrentTaskList();
    }

    private static String formatDateTime(Date date) {
        return dateTimeFormatter.format(date);
    }

    private static String formatDate(Date date) {
        return dateFormatter.format(date);
    }

    private static String shorten(String description, int maxLength) {
        if (description.length() <= maxLength) {
            return description;
        }

        return description.substring(0, maxLength - 1) + FEEDBACK_ELLIPSIS;
    }

}
```
###### Procrastinate/src/procrastinate/task/DateAdapter.java
``` java
package procrastinate.task;

import java.lang.reflect.Type;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.TimeZone;

import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonParseException;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;

public class DateAdapter implements JsonSerializer<Date>, JsonDeserializer<Date> {

private static final DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", Locale.US);

public DateAdapter() {
    dateFormat.setTimeZone(TimeZone.getTimeZone("UTC"));
}

@Override
public JsonElement serialize(Date date, Type typeOfT, JsonSerializationContext context) {
    return new JsonPrimitive(dateFormat.format(date));
}

@Override
public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {
        try {
            return dateFormat.parse(json.getAsString());
        } catch (ParseException e) {
            throw new JsonParseException(e);
        }
    }
}
```
###### Procrastinate/src/procrastinate/task/Deadline.java
``` java
package procrastinate.task;

import java.util.Date;
import java.util.UUID;

import com.google.gson.annotations.SerializedName;

public class Deadline extends Task {

    protected static final String FIELD_DATE = "date";

    @SerializedName(FIELD_DATE)
	private Date date_;

	public Deadline(String description, Date date) {
		super(TaskType.DEADLINE, description);
		this.date_ = date;
	}

	protected Deadline(String description, Date date, boolean isDone, UUID id) {
		super(TaskType.DEADLINE, description, isDone, id);
		this.date_ = date;
	}

	public void setDate(Date date) {
		date_ = date;
	}

	public Date getDate() {
		return date_;
	}

    @Override
    public boolean isWithin(Date startDate, Date endDate) {
        assert (endDate.compareTo(startDate) >= 0);
        return date_.compareTo(startDate) >= 0 && date_.compareTo(endDate) < 0;
    }

    @Override
    public int compareTo(Task other) {
        int superResult = super.compareTo(other);
        if (superResult != 0) {
            return superResult;
        }
        if (other.getType() == TaskType.DREAM) {
            return -1;
        } else {
            Date otherDate = null;
            if (other.getType() == TaskType.DEADLINE) {
                otherDate = ((Deadline) other).date_;
            } else {
                otherDate = ((Event) other).getStartDate();
            }
            if (!date_.equals(otherDate)) {
                if (isDone()) {
                    return -1 * date_.compareTo(otherDate); // flip order for done tasks
                } else {
                    return date_.compareTo(otherDate);
                }
            } else {
                return getDescription().compareTo(other.getDescription());
            }
        }
    }

    @Override
    public boolean equals(Object other) {
        if (other == null) {
            return false;
        }
        if (other == this) {
            return true;
        }
        if (!(other instanceof Deadline)) {
            return false;
        }
        if (!super.equals(other)) {
            return false;
        }
        Deadline otherDeadline = (Deadline) other;
        return otherDeadline.date_.equals(date_);
    }
}
```
###### Procrastinate/src/procrastinate/task/Dream.java
``` java
package procrastinate.task;

import java.util.Date;
import java.util.UUID;

public class Dream extends Task {

	public Dream(String description) {
		super(TaskType.DREAM, description);
	}

	protected Dream(String description, boolean isDone, UUID id) {
		super(TaskType.DREAM, description, isDone, id);
	}

    @Override
    public boolean isWithin(Date startDate, Date endDate) {
        return false;
    }

    @Override
    public int compareTo(Task other) {
        int superResult = super.compareTo(other);
        if (superResult != 0) {
            return superResult;
        }
        if (other.getType() != TaskType.DREAM) {
            return 1;
        } else {
            return this.getDescription().compareTo(other.getDescription());
        }
    }

    @Override
    public boolean equals(Object other) {
        if (other == null) {
            return false;
        }
        if (other == this) {
            return true;
        }
        if (!(other instanceof Dream)) {
            return false;
        }
        if (!super.equals(other)) {
            return false;
        }
        return true;
    }
}
```
###### Procrastinate/src/procrastinate/task/Event.java
``` java
package procrastinate.task;

import java.util.Date;
import java.util.UUID;

import com.google.gson.annotations.SerializedName;

public class Event extends Task {

    protected static final String FIELD_START_DATE = "startDate";
    protected static final String FIELD_END_DATE = "endDate";

    @SerializedName(FIELD_START_DATE)
	private Date startDate_;
    @SerializedName(FIELD_END_DATE)
	private Date endDate_;

	public Event(String description, Date startDate, Date endDate) {
		super(TaskType.EVENT, description);
        assert(endDate.compareTo(startDate) >= 0);
		this.startDate_ = startDate;
		this.endDate_ = endDate;
	}

	protected Event(String description, Date startDate, Date endDate, boolean isDone, UUID id) {
		super(TaskType.EVENT, description, isDone, id);
        assert(endDate.compareTo(startDate) >= 0);
		this.startDate_ = startDate;
		this.endDate_ = endDate;
	}

	public Date getStartDate() {
		return startDate_;
	}

	public Date getEndDate() {
		return endDate_;
	}

    @Override
    public boolean isWithin(Date startDate, Date endDate) {
        assert (endDate.compareTo(startDate) >= 0);
        return startDate_.compareTo(startDate) >= 0 && startDate_.compareTo(endDate) < 0
                || endDate_.compareTo(startDate) >= 0 && endDate_.compareTo(endDate) < 0;
    }

	@Override
    public int compareTo(Task other) {
        int superResult = super.compareTo(other);
        if (superResult != 0) {
            return superResult;
        }
	    if (other.getType() == TaskType.DREAM) {
	        return -1;
	    } else {
	        Date otherDate = null;
	        Date otherEndDate = null;
	        if (other.getType() == TaskType.DEADLINE) {
	            otherDate = ((Deadline) other).getDate();
	        } else {
	            otherDate = ((Event) other).startDate_;
	            otherEndDate = ((Event) other).endDate_;
	        }
	        if (!startDate_.equals(otherDate)) {
                if (isDone()) {
                    return -1 * startDate_.compareTo(otherDate); // flip order for done tasks
                } else {
                    return startDate_.compareTo(otherDate);
                }
	        } else if (otherEndDate != null && !endDate_.equals(otherEndDate)) {
	            return endDate_.compareTo(otherEndDate);
	        } else {
	            return getDescription().compareTo(other.getDescription());
	        }
	    }
	}

    @Override
    public boolean equals(Object other) {
        if (other == null) {
            return false;
        }
        if (other == this) {
            return true;
        }
        if (!(other instanceof Event)) {
            return false;
        }
        if (!super.equals(other)) {
            return false;
        }
        Event otherEvent = (Event) other;
        return otherEvent.startDate_.equals(startDate_) && otherEvent.endDate_.equals(endDate_);
    }
}
```
###### Procrastinate/src/procrastinate/task/Task.java
``` java
package procrastinate.task;

import java.util.Date;
import java.util.UUID;

import com.google.gson.annotations.SerializedName;

public abstract class Task implements Comparable<Task> {

    protected static final String FIELD_TYPE = "type";
    protected static final String FIELD_ID = "id";
    protected static final String FIELD_DESCRIPTION = "description";
    protected static final String FIELD_DONE = "done";

    private static final String ERROR_UNKNOWN_TYPE = "Error: unknown task type";

	public static enum TaskType {
		DEADLINE, EVENT, DREAM;
	}

	@SerializedName(FIELD_TYPE)
	private final TaskType type_; // Cannot change type; subclass object already created
    @SerializedName(FIELD_ID)
    private UUID id_;
    @SerializedName(FIELD_DESCRIPTION)
	private String description_;
    @SerializedName(FIELD_DONE)
	private boolean isDone_;

```
###### Procrastinate/src/procrastinate/task/TaskDeserializer.java
``` java
package procrastinate.task;

import java.lang.reflect.Type;
import java.util.Date;
import java.util.UUID;

import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import procrastinate.task.Task.TaskType;

public class TaskDeserializer implements JsonDeserializer<Task> {

	/**
	 * Task is abstract class so gson is unable to construct a list of Task
	 * Therefore this method is overridden to allow custom deserialization
	 * A new task is constructed depending on the type that is read
	 */
	@Override
	public Task deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
			throws JsonParseException {

	    JsonObject jsonObject = json.getAsJsonObject();

	    String type = null;
	    String description = null;
	    boolean isDone = false;
	    UUID id = null;

        try {
            id = UUID.fromString(jsonObject.get(Task.FIELD_ID).getAsString());
        } catch (Exception e) {
            id = UUID.randomUUID(); // generate new UUID instead of crashing
        }

        try {
            isDone = jsonObject.get(Task.FIELD_DONE).getAsBoolean();
        } catch (Exception e) {
            isDone = false; // assume not done instead of crashing
        }

        try {
            description = jsonObject.get(Task.FIELD_DESCRIPTION).getAsString();
        } catch (Exception e) {
            description = ""; // empty description instead of crashing
        }

	    try {
	        // type as in the variable, type in Task class
	        type = jsonObject.get(Task.FIELD_TYPE).getAsString();
	    } catch (Exception e) {
	        type = TaskType.DREAM.toString(); // assume Dream instead of crashing
	    }

		if (type.equals(TaskType.DREAM.toString())) {
			return new Dream(description, isDone, id);

		} else if (type.equals(TaskType.DEADLINE.toString())) {
	        Date date = null;

            try {
                date = context.deserialize(jsonObject.get(Deadline.FIELD_DATE), Date.class);
            } catch (Exception e) {
                e.printStackTrace();
                return new Dream(description, isDone, id);
            }

			return new Deadline(description, date, isDone, id);

		} else if (type.equals(TaskType.EVENT.toString())) {
		    Date startDate = null;
		    Date endDate = null;

            try {
                startDate = context.deserialize(jsonObject.get(Event.FIELD_START_DATE), Date.class);
                endDate = context.deserialize(jsonObject.get(Event.FIELD_END_DATE), Date.class);

                if (endDate.before(startDate)) { // encountered invalid range
                    endDate = startDate; // use start date as both start and end date
                }
            } catch (Exception e) {
                e.printStackTrace();
                return new Dream(description, isDone, id);
            }

            return new Event(description, startDate, endDate, isDone, id);

		} else {
		    return new Dream(description, isDone, id); // if unrecognised, default to dream
		}

	}
}
```
###### Procrastinate/src/procrastinate/task/TaskEngine.java
``` java
package procrastinate.task;

import java.io.File;
import java.io.IOException;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.UUID;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import procrastinate.FileHandler;

public class TaskEngine {

    private static final Logger logger = Logger.getLogger(TaskEngine.class.getName());

    // ================================================================================
    // Message strings
    // ================================================================================

    private static final String DEBUG_TASK_ENGINE_INIT = "TaskEngine initialised.";
    private static final String DEBUG_ADDED_TASK = "Added %1$s: %2$s";
    private static final String DEBUG_EDITED_TASK = "Edited #%1$s: %2$s";
    private static final String DEBUG_DELETED_TASK = "Deleted %1$s: %2$s";
    private static final String DEBUG_DONE_TASK = "Done %1$s: %2$s";
    private static final String DEBUG_UNDONE_TASK = "Undone %1$s: %2$s";
    private static final String DEBUG_UNDONE = "Last task operation undone";

    private static final String ERROR_TASK_NOT_FOUND = "Task not found!";

    // ================================================================================
    // Class variables
    // ================================================================================

    private TaskState previousState_ = null;
    private TaskState currentState_ = null;
    private TaskState currentView_ = null;

    private boolean isPreviousOperationSet_ = false;
    private String previousSaveDirectory_ = null;
    private String previousSaveFilename_ = null;

    protected FileHandler fileHandler;

    public TaskEngine() throws IOException {
        initFileHandler();
        initTasks();
        logger.log(Level.INFO, DEBUG_TASK_ENGINE_INIT);
    }

    // ================================================================================
    // TaskEngine methods
    // ================================================================================

    public boolean add(Task task) {
        backupOlderState();

        String description = task.getDescription();
        String type = task.getTypeString();

        getTasks().add(task);

        logger.log(Level.INFO, String.format(DEBUG_ADDED_TASK, type, description));

        return writeStateToFile();
    }

    public boolean edit(UUID taskId, Task newTask) {
        backupOlderState();

        int index = getIndexFromId(taskId);
        getTasks().remove(index);
        getTasks().add(index, newTask);

        logger.log(Level.INFO, String.format(DEBUG_EDITED_TASK, index + 1, newTask.getDescription()));

        return writeStateToFile();
    }

    public boolean delete(UUID taskId) {
        backupOlderState();

        int index = getIndexFromId(taskId);
        Task task = getTasks().get(index);
        getTasks().remove(index);

        String description = task.getDescription();
        String type = task.getTypeString();

        logger.log(Level.INFO, String.format(DEBUG_DELETED_TASK, type, description));

        return writeStateToFile();
    }

    public boolean done(UUID taskId) {
        backupOlderState();

        int index = getIndexFromId(taskId);
        Task task = Task.copy(getTasks().get(index));
        task.setDone(!task.isDone());
        getTasks().remove(index);
        getTasks().add(index, task);

        String description = task.getDescription();
        String type = task.getTypeString();
        String feedback;

        if (task.isDone()) {
            feedback = DEBUG_DONE_TASK;
        } else {
            feedback = DEBUG_UNDONE_TASK;
        }

        logger.log(Level.INFO, String.format(feedback, type, description));

        return writeStateToFile();
    }

    public boolean undo() {
        if (isPreviousOperationSet_) {
            return set(previousSaveDirectory_, previousSaveFilename_);
        }

        if (!hasPreviousOperation()) {
            return true;
        }

        TaskState backupNewerState = getBackupOfCurrentState();
        restoreOlderState();
        previousState_ = backupNewerState;

        logger.log(Level.INFO, String.format(DEBUG_UNDONE));

        return writeStateToFile();
    }

    public boolean save() {
        return writeStateToFile();
    }

    public boolean set(String directory, String filename) {
        isPreviousOperationSet_ = true;
        File previousSaveFile = fileHandler.getSaveFile();
        previousSaveDirectory_ = previousSaveFile.getAbsoluteFile().getParent() + File.separator;
        previousSaveFilename_ = previousSaveFile.getName();
        return fileHandler.setPath(directory, filename);
    }

    public boolean hasPreviousOperation() {
        return previousState_ != null || isPreviousOperationSet_;
    }

    public List<Task> search(String description, Date startDate, Date endDate, boolean showDone) {
        assert(description != null || startDate != null && endDate != null);
        List<Task> results = getTasks();
        if (description != null) {
            results = results.stream()
                    .filter(task -> task.contains(description))
                    .collect(Collectors.toList());
        }
        if (startDate != null) {
            results = results.stream()
                    .filter(task -> task.isWithin(startDate, endDate))
                    .collect(Collectors.toList());
        }
        if (!showDone) {
            results = results.stream()
                    .filter(task -> !task.isDone())
                    .collect(Collectors.toList());
        }
        currentView_ = new TaskState(results);
        return currentView_.getTasks();
    }

    public List<Task> getOutstandingTasks() {
        List<Task> outstandingTasks = getTasks().stream()
                .filter(task -> !task.isDone())
                .collect(Collectors.toList());
        currentView_ = new TaskState(outstandingTasks);
        return currentView_.getTasks();
    }

    public List<Task> getCompletedTasks() {
        List<Task> completedTasks = getTasks().stream()
                .filter(task -> task.isDone())
                .collect(Collectors.toList());
        currentView_ = new TaskState(completedTasks);
        return currentView_.getTasks();
    }

    public List<Task> getAllTasks() {
        currentView_ = currentState_;
        return currentView_.getTasks();
    }

    public List<Task> getCurrentTaskList() {
        return currentView_.getTasks();
    }

    // ================================================================================
    // Init methods
    // ================================================================================

    protected void initFileHandler() throws IOException {
        fileHandler = new FileHandler();
    }

    private void initTasks() {
        loadState(fileHandler.loadTaskState());
        currentView_ = currentState_;
        Collections.sort(getTasks());
    }

    // ================================================================================
    // State handling methods
    // ================================================================================

    private void backupOlderState() {
        previousState_ = getBackupOfCurrentState();
        isPreviousOperationSet_ = false;
    }

    private void restoreOlderState() {
        loadState(previousState_);
    }

    private void loadState(TaskState state) {
        currentState_ = state;
    }

    private boolean writeStateToFile() {
        return fileHandler.saveTaskState(getCurrentState());
    }

    private TaskState getBackupOfCurrentState() {
        return TaskState.copy(getCurrentState());
    }

    private TaskState getCurrentState() {
        Collections.sort(getTasks());
        return currentState_;
    }

    // ================================================================================
    // Utility methods
    // ================================================================================

    private int getIndexFromId(UUID id) {
        for (int i = 0; i < getTasks().size(); i++) {
            if (getTasks().get(i).getId().equals(id)) {
                return i;
            }
        }
        throw new Error(ERROR_TASK_NOT_FOUND);
    }

    private List<Task> getTasks() {
        return currentState_.getTasks();
    }

}
```
###### Procrastinate/src/procrastinate/task/TaskState.java
``` java
package procrastinate.task;

import java.util.ArrayList;
import java.util.List;

import com.google.gson.annotations.SerializedName;

public class TaskState {

    protected static final String FIELD_TASKS = "tasks";

    @SerializedName(FIELD_TASKS)
    private List<Task> tasks_;

    public TaskState() {
        this.tasks_ = new ArrayList<Task>();
    }

    public TaskState(List<Task> tasks) {
        this.tasks_ = tasks;
    }

    public static TaskState copy(TaskState other) {
        return new TaskState(new ArrayList<Task>(other.tasks_));
    }

    public List<Task> getTasks() {
        return tasks_;
    }

```
###### Procrastinate/src/procrastinate/test/LogicTest.java
``` java
package procrastinate.test;

import static org.junit.Assert.assertEquals;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.List;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import procrastinate.Logic;
import procrastinate.task.Deadline;
import procrastinate.task.Dream;
import procrastinate.task.Event;
import procrastinate.task.Task;

public class LogicTest {

    private static SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yy");

    private Logic logic;
    private UIStub uiStub;

    @Before
    public void setUp() throws Exception {
        System.out.println("Setting up test...");
        uiStub = new UIStub();
        logic = new LogicUnit(uiStub);
    }

    @After
    public void tearDown() throws Exception {
        System.out.println("Tearing down. Final state:");
        System.out.println(getResults());
        System.out.println("Test completed!\n");
    }

    @Test
    public void trivialTest() {
        assertEquals(logic.previewCommand("exit"), "Goodbye!");
        assertEquals(logic.previewCommand("help"), "Showing help screen (use left/right keys to navigate)");
        assertEquals(logic.previewCommand("show"), "Showing outstanding tasks");
        assertEquals(logic.previewCommand("show done"), "Showing completed tasks");
        assertEquals(logic.previewCommand("show all"), "Showing all tasks");
        assertEquals(logic.previewCommand("search abc"), "Searching for tasks containing 'abc'");
    }

    @Test
    public void addTest() throws ParseException {
        execute("dream");
        execute("deadline due 10/13/17 0");
        execute("event from 10/14/17 to 10/15/17 0");
        execute("another dream");
        execute("urgent deadline due 10/13/16 0");
        List<Task> expected = new ArrayList<Task>();
        expected.add(new Deadline("urgent deadline", sdf.parse("10/13/16")));
        expected.add(new Deadline("deadline", sdf.parse("10/13/17")));
        expected.add(new Event("event", sdf.parse("10/14/17"), sdf.parse("10/15/17")));
        expected.add(new Dream("another dream"));
        expected.add(new Dream("dream"));
        assertEquals(expected, getResults());
    }

    @Test
    public void showTest() {
        execute("a");
        execute("b");
        execute("c");
        execute("d");
        execute("e");
        execute("done 3"); // done c
        execute("done 3"); // done d

        execute("show done");
        List<Task> expected = new ArrayList<Task>();
        expected.add(new Dream("c"));
        expected.add(new Dream("d"));
        expected.get(0).setDone(true);
        expected.get(1).setDone(true);
        assertEquals(expected, getResults());

        execute("show");
        expected.clear();
        expected.add(new Dream("a"));
        expected.add(new Dream("b"));
        expected.add(new Dream("e"));
        assertEquals(expected, getResults());

        execute("show all");
        expected.clear();
        expected.add(new Dream("a"));
        expected.add(new Dream("b"));
        expected.add(new Dream("e"));
        expected.add(new Dream("c"));
        expected.add(new Dream("d"));
        expected.get(3).setDone(true); // done c
        expected.get(4).setDone(true); // done d
        assertEquals(expected, getResults());
    }

```
###### Procrastinate/src/procrastinate/test/LogicUnit.java
``` java
package procrastinate.test;

import java.io.IOException;

import procrastinate.Logic;

public class LogicUnit extends Logic {
    public LogicUnit(UIStub uiStub) {
        ui = uiStub;
    }
    @Override
    protected void initTaskEngine() {
        try {
            taskEngine = new TaskEngineUnit();
        } catch (IOException e) {
        }
    }
}
```
###### Procrastinate/src/procrastinate/test/TaskEngineUnit.java
``` java
package procrastinate.test;

import java.io.IOException;

import procrastinate.task.TaskEngine;

public class TaskEngineUnit extends TaskEngine {
    public TaskEngineUnit() throws IOException {
    }
    @Override
    protected void initFileHandler() {
        fileHandler = new FileHandlerStub();
    }
}
```
###### Procrastinate/src/procrastinate/test/UIStub.java
``` java
package procrastinate.test;

import java.util.ArrayList;
import java.util.List;

import javafx.beans.value.ChangeListener;
import javafx.event.EventHandler;
import javafx.scene.input.KeyEvent;
import javafx.stage.Stage;
import procrastinate.task.Task;
import procrastinate.ui.UI;

public class UIStub extends UI {
    private List<Task> taskList_;
    public UIStub() {
        taskList_ = new ArrayList<Task>();
    }
    public UIStub(Stage stage) {
    }
    public List<Task> getTaskList() {
        return taskList_;
    }
    @Override
    public String getInput() {
        return null;
    }
    @Override
    public void setInput(String input) {
    }
    @Override
    public void clearInput() {
    }
    @Override
    public void setStatus(String status) {
    }
    @Override
    public void updateTaskList(List<Task> taskList, ScreenView screenView) {
        taskList_ = taskList;
    }
    @Override
    public void initialUpdateTaskList(List<Task> taskList) {
    }
    @Override
    public void resetIsExit() {
    }
    @Override
    public void attachHandlersAndListeners(EventHandler<KeyEvent> keyPressHandler,
            ChangeListener<String> userInputListener, ChangeListener<Boolean> isExitListener) {
    }
    @Override
    public void passSearchStringToSearchScreen(String searchTerm) {
    }
    @Override
    public void showHelpOverlay() {
    }
    @Override
    public void hideHelpOverlay() {
    }
    @Override
    public void hideSplashOverlay() {
    }
    @Override
    public void scrollUpScreen() {
    }
    @Override
    public void scrollDownScreen() {
    }
    @Override
    public void createErrorDialog(String header, String message) {
    }
    @Override
    public void createErrorDialogWithTrace(Exception e) {
    }
    @Override
    public boolean createErrorDialogWithConfirmation(String header, String message, String okLabel) {
        return true;
    }
}
```
###### Procrastinate/src/procrastinate/ui/HelpOverlay.java
``` java
    protected void nextPage() {
        if (isFirstPage_) {
            imageView.setImage(new Image(HelpOverlay.class.getResource(LOCATION_REFERENCE_SHEET_2).toExternalForm()));
        } else {
            imageView.setImage(new Image(HelpOverlay.class.getResource(LOCATION_REFERENCE_SHEET).toExternalForm()));
        }

        isFirstPage_ = !isFirstPage_;
    }

    // ================================================================================
    // Init Methods
    // ================================================================================

```
###### Procrastinate/src/procrastinate/ui/SummaryScreen.java
``` java
    protected boolean isSummarising() {
        return isSummarising_;
    }

```
###### Procrastinate/src/procrastinate/ui/SummaryScreen.java
``` java
    private Task shortenTaskDescription(Task task) {
        String description = task.getDescription();
        if (description.length() > DESCRIPTION_MAX_LENGTH) {
            task = Task.copy(task);
            task.setDescription(description.substring(0, DESCRIPTION_MAX_LENGTH
                                                         - DESCRIPTION_ELLIPSIS_LENGTH) + DESCRIPTION_ELLIPSIS_STRING);
        }
        return task;
    }
}
```
###### Procrastinate/src/procrastinate/ui/UI.java
``` java
    public void initialUpdateTaskList(List<Task> taskList) {
        centerPaneController_.initialUpdateMainScreen(taskList);
    }

```
###### Procrastinate/src/procrastinate/ui/UI.java
``` java
    public boolean createErrorDialogWithConfirmation(String header, String message, String okLabel) {
        boolean result = false;
        if (!Platform.isFxApplicationThread()) {
            FutureTask<Boolean> query = new FutureTask<Boolean>(new Callable<Boolean>() {
                @Override
                public Boolean call() throws Exception {
                    return dialogPopupHandler_.createErrorDialogPopupWithConfirmation(header, message, okLabel);
                }
            });
            Platform.runLater(query);

            try {
                result = query.get();
            } catch (Exception e) {
                e.printStackTrace();
            }

        } else {
            result = dialogPopupHandler_.createErrorDialogPopupWithConfirmation(header, message, okLabel);
        }
        return result;
    }

    // ================================================================================
    // Init Methods
    // ================================================================================

```
