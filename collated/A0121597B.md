# A0121597B
###### procrastinate\test\UITest.java
``` java
    // ================================================================================
    // CenterPaneController Testing
    // ================================================================================

    @Test
    public void centerPaneController_InitCurrentOverlayShouldBeNull() {
        assertNull(uiTestHelper.getCPCCurrentOverlay());
    }

    @Test
    public void centerPaneController_InitCurrentScreenShouldNotBeNullAndIsSummaryScreen() {
        // The inital start screen should be a summary screen
        assertTrue(uiTestHelper.getCPCCurrentScreen() != null);
        assertTrue(uiTestHelper.getCPCCurrentScreen() instanceof SummaryScreen);
    }

    @Test
    public void centerPaneController_ShouldHaveCreatedAllScreens() {
        assertNotNull(uiTestHelper.getDoneScreenNode());
        assertNotNull(uiTestHelper.getMainScreenNode());
        assertNotNull(uiTestHelper.getSearchScreenNode());
        assertNotNull(uiTestHelper.getSummaryScreenNode());
        assertNotNull(uiTestHelper.getHelpOverlayNode());
        assertNotNull(uiTestHelper.getSplashOverlayNode());
    }

    @Test
    public void centerPaneController_ShouldBeAbleToSwitchAllScreens() throws InterruptedException {
        List<Task> emptyList = new ArrayList<Task>();
        // Due to random nature of tests running, this test needs to be isolated so that the initial
        // start point is always the same and would not have unwanted assertionErrors
        UITestHelper isolatedTestHelper = new UITestHelper();
        isolatedTestHelper.getNewCenterPaneController(new StackPane());

        assertTrue(isolatedTestHelper.getCPCCurrentScreen() instanceof SummaryScreen);
        assertEquals(isolatedTestHelper.getCPCCurrentScreenNode(), isolatedTestHelper.getSummaryScreenNode());

        // Each screen switch requires waiting of the screen switch animation to end before asserts can be carried out
        isolatedTestHelper.changeCPCScreen(emptyList, ScreenView.SCREEN_MAIN);
        Thread.sleep(1000);
        assertTrue(isolatedTestHelper.getCPCCurrentScreen() instanceof MainScreen);
        assertEquals(isolatedTestHelper.getCPCCurrentScreenNode(), isolatedTestHelper.getMainScreenNode());

        isolatedTestHelper.changeCPCScreen(emptyList, ScreenView.SCREEN_SEARCH);
        Thread.sleep(1000);
        assertTrue(isolatedTestHelper.getCPCCurrentScreen() instanceof SearchScreen);
        assertEquals(isolatedTestHelper.getCPCCurrentScreenNode(), isolatedTestHelper.getSearchScreenNode());

        isolatedTestHelper.changeCPCScreen(emptyList, ScreenView.SCREEN_DONE);
        Thread.sleep(1000);
        assertTrue(isolatedTestHelper.getCPCCurrentScreen() instanceof DoneScreen);
        assertEquals(isolatedTestHelper.getCPCCurrentScreenNode(), isolatedTestHelper.getDoneScreenNode());
    }

    @Test
    public void centerPaneController_ShouldBeAbleToShowAllOverlays() throws InterruptedException {
        // Splash overlay testing
        uiTestHelper.showSplash();
        assertEquals(uiTestHelper.getCPCCurrentOverlayNode(), uiTestHelper.getSplashOverlayNode());

        uiTestHelper.hideSplash();
        Thread.sleep(3000); // to wait for splash animation to end
        assertNull(uiTestHelper.getCPCCurrentOverlay());

        // Help overlay testing
        uiTestHelper.showHelp();
        assertEquals(uiTestHelper.getCPCCurrentOverlayNode(), uiTestHelper.getHelpOverlayNode());

        uiTestHelper.hideHelp();
        Thread.sleep(300);
        assertNull(uiTestHelper.getCPCCurrentOverlay());
    }

    // ================================================================================
    // CenterScreen Testing
    // ================================================================================
    // DoneScreen related
    @Test
    public void doneScreen_InitChildrenShouldBeEmpty() {
        DoneScreen doneScreen = (DoneScreen) uiTestHelper.getNewDoneScreen();
        assertNotNull(doneScreen);
        assertEquals(0, uiTestHelper.getSingleCategoryTaskList(doneScreen).getChildren().size());
        assertEquals(0, uiTestHelper.getCenterScreenVBox(doneScreen).getChildren().size());
    }

    @Test
    public void doneScreen_UpdateShouldIgnoreUndoneTasks() throws ParseException {
        DoneScreen doneScreen = (DoneScreen) uiTestHelper.getNewDoneScreen();
        List<Task> taskList = new ArrayList<Task>();
        SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yy");

        Deadline undoneDeadline = new Deadline("An Undone Deadline", sdf.parse("11/11/16"));
        taskList.add(undoneDeadline);
        uiTestHelper.updateScreenTaskList(doneScreen, taskList);
        assertEquals(0, uiTestHelper.getSingleCategoryTaskList(doneScreen).getChildren().size());

        Deadline doneDeadline = new Deadline("A Done Deadline", sdf.parse("12/12/16"));
        doneDeadline.setDone(true);
        taskList.add(doneDeadline);
        uiTestHelper.updateScreenTaskList(doneScreen, taskList);
        assertEquals(1, uiTestHelper.getSingleCategoryTaskList(doneScreen).getChildren().size());


        Event undoneEvent = new Event("An Undone Event", sdf.parse("11/14/17"), sdf.parse("11/15/17"));
        Event doneEvent = new Event("A Done Event", sdf.parse("11/14/17"), sdf.parse("11/15/17"));
        doneEvent.setDone(true);
        taskList.add(undoneEvent);
        taskList.add(doneEvent);
        uiTestHelper.updateScreenTaskList(doneScreen, taskList);
        assertEquals(2, uiTestHelper.getSingleCategoryTaskList(doneScreen).getChildren().size());

        Dream undoneDream = new Dream("A Undone Dream");
        Dream doneDream = new Dream("A Done Dream");
        doneDream.setDone(true);
        taskList.add(undoneDream);
        taskList.add(doneDream);
        uiTestHelper.updateScreenTaskList(doneScreen, taskList);
        assertEquals(3, uiTestHelper.getSingleCategoryTaskList(doneScreen).getChildren().size());
    }

    // MainScreen related
    @Test
    public void mainScreen_InitChildrenShouldBeEmpty() {
        MainScreen mainScreen = (MainScreen) uiTestHelper.getNewMainScreen();
        assertNotNull(mainScreen);
        assertEquals(0, uiTestHelper.getCenterScreenVBox(mainScreen).getChildren().size());

        assertEquals(0, uiTestHelper.getOverdueTaskList(mainScreen).getChildren().size());
        assertEquals(0, uiTestHelper.getUpcomingTaskList(mainScreen).getChildren().size());
        assertEquals(0, uiTestHelper.getFutureTaskList(mainScreen).getChildren().size());
        assertEquals(0, uiTestHelper.getDreamsTaskList(mainScreen).getChildren().size());
        assertEquals(0, uiTestHelper.getDoneTaskList(mainScreen).getChildren().size());
    }

    @Test
    public void mainScreen_ShouldAddAllTasksCorrectly() throws ParseException {
        MainScreen mainScreen = (MainScreen) uiTestHelper.getNewMainScreen();
        List<Task> taskList = new ArrayList<Task>();
        SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yy");

        taskList.add(new Deadline("overdue", sdf.parse("11/11/11")));
        taskList.add(new Deadline("today", Date.from(Instant.now().plusSeconds(60))));  // else it will go into overdue
        taskList.add(new Event("tomorrow", Date.from(Instant.now().plusSeconds(86400)), sdf.parse("11/11/16")));
        taskList.add(new Event("future", sdf.parse("12/12/16"), sdf.parse("11/11/17")));
        taskList.add(new Dream("dream"));
        Dream doneDream = new Dream("another done dream");
        doneDream.setDone(true);
        taskList.add(doneDream);

        uiTestHelper.updateScreenTaskList(mainScreen, taskList);
        assertEquals(5, uiTestHelper.getCenterScreenVBox(mainScreen).getChildren().size());

        assertEquals(1, uiTestHelper.getOverdueTaskList(mainScreen).getChildren().size());
        assertEquals(2, uiTestHelper.getUpcomingTaskList(mainScreen).getChildren().size());
        assertEquals(1, uiTestHelper.getFutureTaskList(mainScreen).getChildren().size());
        assertEquals(1, uiTestHelper.getDreamsTaskList(mainScreen).getChildren().size());
        assertEquals(1, uiTestHelper.getDoneTaskList(mainScreen).getChildren().size());
    }

    // SearchScreen related
    @Test
    public void searchScreen_InitChildrenShouldBeEmpty() {
        SearchScreen searchScreen = (SearchScreen) uiTestHelper.getNewSearchScreen();
        assertNotNull(searchScreen);
        assertEquals(0, uiTestHelper.getCenterScreenVBox(searchScreen).getChildren().size());

        assertEquals(0, uiTestHelper.getOverdueTaskList(searchScreen).getChildren().size());
        assertEquals(0, uiTestHelper.getUpcomingTaskList(searchScreen).getChildren().size());
        assertEquals(0, uiTestHelper.getFutureTaskList(searchScreen).getChildren().size());
        assertEquals(0, uiTestHelper.getDreamsTaskList(searchScreen).getChildren().size());
        assertEquals(0, uiTestHelper.getDoneTaskList(searchScreen).getChildren().size());
    }

    @Test
    public void searchScreen_ShouldShowSearchedTasksCorrectly() throws ParseException, InterruptedException {
        SearchScreen searchScreen = (SearchScreen) uiTestHelper.getNewSearchScreen();
        List<Task> taskList = new ArrayList<Task>();
        SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yy");

        // Basically should show the tasks under the correct header
        taskList.add(new Deadline("overdue", sdf.parse("11/11/11")));
        uiTestHelper.updateScreenTaskList(searchScreen, taskList);
        assertEquals(1, uiTestHelper.getCenterScreenVBox(searchScreen).getChildren().size());
        assertEquals(1, uiTestHelper.getOverdueTaskList(searchScreen).getChildren().size());
        assertEquals(0, uiTestHelper.getUpcomingTaskList(searchScreen).getChildren().size());
        assertEquals(0, uiTestHelper.getFutureTaskList(searchScreen).getChildren().size());
        assertEquals(0, uiTestHelper.getDreamsTaskList(searchScreen).getChildren().size());
        assertEquals(0, uiTestHelper.getDoneTaskList(searchScreen).getChildren().size());

        taskList.clear();
        taskList.add(new Event("future", sdf.parse("12/12/16"), sdf.parse("11/11/17")));
        taskList.add(new Event("another future", sdf.parse("12/12/16"), sdf.parse("11/11/17")));
        uiTestHelper.updateScreenTaskList(searchScreen, taskList);
        Thread.sleep(300);  // to wait for prev category to fade out
        assertEquals(1, uiTestHelper.getCenterScreenVBox(searchScreen).getChildren().size());
        assertEquals(0, uiTestHelper.getOverdueTaskList(searchScreen).getChildren().size());
        assertEquals(0, uiTestHelper.getUpcomingTaskList(searchScreen).getChildren().size());
        assertEquals(2, uiTestHelper.getFutureTaskList(searchScreen).getChildren().size());
        assertEquals(0, uiTestHelper.getDreamsTaskList(searchScreen).getChildren().size());
        assertEquals(0, uiTestHelper.getDoneTaskList(searchScreen).getChildren().size());

        taskList.add(new Deadline("overdue", sdf.parse("11/11/11")));
        uiTestHelper.updateScreenTaskList(searchScreen, taskList);
        assertEquals(2, uiTestHelper.getCenterScreenVBox(searchScreen).getChildren().size());
        assertEquals(1, uiTestHelper.getOverdueTaskList(searchScreen).getChildren().size());
        assertEquals(0, uiTestHelper.getUpcomingTaskList(searchScreen).getChildren().size());
        assertEquals(2, uiTestHelper.getFutureTaskList(searchScreen).getChildren().size());
        assertEquals(0, uiTestHelper.getDreamsTaskList(searchScreen).getChildren().size());
        assertEquals(0, uiTestHelper.getDoneTaskList(searchScreen).getChildren().size());
    }

    // Unable to test SummaryScreen due to actual actual sizing of the window shown

    // ================================================================================
    // ImageOverlay Testing
    // ================================================================================
    @Test
    public void helpOverlay_InitShouldNotBeNullAndContainRequiredPages() {
        HelpOverlay helpOverlay = (HelpOverlay) uiTestHelper.getNewHelpOverlay();
        assertNotNull(helpOverlay);
        // Should only contain the image view
        assertEquals(1, uiTestHelper.getOverlayContainer(helpOverlay).getChildren().size());

        Image firstPage = uiTestHelper.getOverlayImageView(helpOverlay).getImage();
        uiTestHelper.switchHelpOverlayPage(helpOverlay);
        Image secondPage = uiTestHelper.getOverlayImageView(helpOverlay).getImage();
        assertNotEquals(firstPage, secondPage);
    }

    @Test
    public void splashOverlay_InitShouldNotBeNullAndLabelsSetUp() {
        SplashOverlay splashOverlay = (SplashOverlay) uiTestHelper.getNewSplashOverlay();
        assertNotNull(splashOverlay);
        // Should contain 2 extra labels
        assertEquals(3, uiTestHelper.getOverlayContainer(splashOverlay).getChildren().size());
    }

    // ================================================================================
    // CategoryBox Testing
    // ================================================================================
    @Test
    public void categoryBox_InitShouldNotBeNullAndCorrectLabelIsSet() {
        CategoryBox categoryBox = uiTestHelper.getNewCategoryBox("Test header");
        assertNotNull(categoryBox);

        // Check if the correct header is set
        assertEquals("Test header", uiTestHelper.getCategoryBoxLabel(categoryBox).textProperty().get());

        // Check that the task list is empty
        assertEquals(0, uiTestHelper.getCategoryBoxVBox(categoryBox).getChildren().size());
    }

    // ================================================================================
    // CategoryBox Testing
    // ================================================================================
    @Test
    public void subcategoryBox_InitShouldNotBeNullAndCorrectLabelIsSet() {
        SubcategoryBox subcategoryBox = uiTestHelper.getNewSubcategoryBox("Test header");
        assertNotNull(subcategoryBox);

        // Check if the correct header is set
        assertEquals("Test header", uiTestHelper.getSubcategoryBoxLabel(subcategoryBox).textProperty().get());

        // Check that the task list is empty
        assertEquals(0, uiTestHelper.getSubcategoryBoxVBox(subcategoryBox).getChildren().size());
    }

    // ================================================================================
    // TaskEntry Testing
    // ================================================================================
    @Test
    public void taskEntryDream_LabelsShouldBeSetCorrectly() {
        TaskEntry dreamTask = uiTestHelper.getNewDreamTaskEntry("1", "test");
        assertEquals("1", uiTestHelper.getTaskEntryLineNum(dreamTask).getText());
        assertEquals("test", uiTestHelper.getTaskEntryDescription(dreamTask).getText());
        assertEquals("", uiTestHelper.getTaskEntryTime(dreamTask).getText());
    }

    @Test
    public void taskEntryOthers_LabelsShouldBeSetCorrectly() {
        TaskEntry otherTask =  uiTestHelper.getNewOthersTaskEntry("2", "test2", "time");
        assertEquals("2", uiTestHelper.getTaskEntryLineNum(otherTask).getText());
        assertEquals("test2", uiTestHelper.getTaskEntryDescription(otherTask).getText());
        assertEquals("time", uiTestHelper.getTaskEntryTime(otherTask).getText());
    }

    @Test
    public void taskEntry_DoneTasksShouldHaveTickSet() {
        TaskEntry doneTask =  uiTestHelper.getNewDoneTaskEntry("3", "a done task", "time here");
        assertEquals("3", uiTestHelper.getTaskEntryLineNum(doneTask).getText());
        assertEquals("a done task", uiTestHelper.getTaskEntryDescription(doneTask).getText());
        assertEquals("time here", uiTestHelper.getTaskEntryTime(doneTask).getText());

        GridPane gridPane = (GridPane) uiTestHelper.getTaskEntryNode(doneTask);
        // Since the tick is wrapped with line number and added back, it will be at the end of the children list
        assertTrue(gridPane.getChildren().get(gridPane.getChildren().size()-1) instanceof HBox);

        // The combined wrapper should contain an individual HBox for the tick and line number label
        assertEquals(2, ((HBox)gridPane.getChildren().get(gridPane.getChildren().size()-1)).getChildren().size());
        assertTrue(((HBox)gridPane.getChildren().get(gridPane.getChildren().size()-1)).getChildren().get(0) instanceof HBox);
        assertTrue(((HBox)gridPane.getChildren().get(gridPane.getChildren().size()-1)).getChildren().get(1) instanceof HBox);

        // This should be the wrapper for the tick image
        HBox tickImageWrapper = (HBox)((HBox)gridPane.getChildren().get(gridPane.getChildren().size()-1)).getChildren().get(0);
        assertEquals(1, tickImageWrapper.getChildren().size());
        assertTrue(tickImageWrapper.getChildren().get(0) instanceof ImageView);
        ImageView tickImage = (ImageView) tickImageWrapper.getChildren().get(0);
        assertNotNull(tickImage.getImage());

        // This should be the wrapper for the line number
        HBox lineNumberWrapper = (HBox)((HBox)gridPane.getChildren().get(gridPane.getChildren().size()-1)).getChildren().get(1);
        assertEquals(1, lineNumberWrapper.getChildren().size());
        assertTrue(lineNumberWrapper.getChildren().get(0) instanceof Label);
        Label lineNumberLabel = (Label) lineNumberWrapper.getChildren().get(0);
        assertEquals("3", lineNumberLabel.getText());
    }
}
```
###### procrastinate\ui\CategoryBox.java
``` java
package procrastinate.ui;

import java.io.IOException;

import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.effect.BlurType;
import javafx.scene.effect.DropShadow;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;

/**
 * <h1>A VBox wrapper structure that models a category list.</h1>
 * It contains a Label that acts as the header and another VBox, to contain all the TaskEntry added.
 *
 * <p><b>Note:</b>
 * <br>It should be the main element to be added into the mainVBox of any screen before
 * any SubcategoryBox or TaskEntry.
 *
 * <br>The CSS style class for CategoryBox is 'categoryBox' and the styling applied
 * differentiates CategoryBox from SubcategoryBox.
 */
public class CategoryBox extends VBox {

    // ================================================================================
    // Message Strings
    // ================================================================================

    private static final String LOCATION_CATEGORYBOX_FXML = "views/CategoryBox.fxml";

    // ================================================================================
    // Class Variables
    // ================================================================================

    private Node categoryBox_;

    // ================================================================================
    // FXML Field Variables
    // ================================================================================

    @FXML
    private Label categoryLabel;
    @FXML
    private VBox categoryVBox;

    // ================================================================================
    // CategoryBox Constructor
    // ================================================================================

    /**
     * Creates a CategoryBox that encloses a Label as the header text and a VBox
     * to be used to contain the list of tasks.
     *
     * @param categoryHeader    string to be used as the header text of the category
     */
    protected CategoryBox(String categoryHeader) {
        loadLayout();
        setLabelTextWithDropShadowEffect(categoryHeader);
    }

    // ================================================================================
    // Init Methods
    // ================================================================================

    private void loadLayout() {
        FXMLLoader loader = new FXMLLoader(getClass().getResource(LOCATION_CATEGORYBOX_FXML));
        loader.setController(this); // Required due to different package
                                    // declaration from Main
        try {
            this.categoryBox_ = loader.load();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Sets the categoryLabel which acts as the header for a CategoryBox. This
     * method also adds a DropShadow effect to the label after the text is set.
     *
     * @param categoryHeader    to be set as the category header text
     */
    private void setLabelTextWithDropShadowEffect(String categoryHeader) {
        this.categoryLabel.setText(categoryHeader);
        DropShadow dropShadow = new DropShadow(BlurType.GAUSSIAN, Color.GRAY, 6, 0, 0, 2.0f);
        categoryLabel.setEffect(dropShadow);
    }

    // ================================================================================
    // Getter Methods
    // ================================================================================

```
###### procrastinate\ui\CenterPaneController.java
``` java
package procrastinate.ui;

import java.util.List;

import javafx.animation.FadeTransition;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.ParallelTransition;
import javafx.animation.SequentialTransition;
import javafx.animation.Timeline;
import javafx.scene.Node;
import javafx.scene.control.ScrollBar;
import javafx.scene.control.ScrollPane;
import javafx.scene.layout.StackPane;
import javafx.util.Duration;
import procrastinate.task.Task;
import procrastinate.ui.UI.ScreenView;

/**
 * <h1>This class controls the StackPane in the main window's BorderPane center region.</h1>
 *
 * It is also in-charge of all the different screens and overlays, including the:
 * <li>     Creation of all the different screens/overlays
 * <li>     Showing/Hiding of overlays
 * <li>     Switching of screens
 * <li>     Updating of screens
 * <li>     Transitions that occur in the center region of the window
 *
 */
public class CenterPaneController {

    // ================================================================================
    // Message Strings
    // ================================================================================

    private static final String MESSAGE_UNABLE_RECOGNISE_SCREEN_TYPE = "Unable to recognise ScreenType";

    private static final String SELECTOR_SCROLL_BAR = ".scroll-bar";
    private static final String SELECTOR_SCROLL_PANE = "#scrollPane";

    private static final String TRANSITION_CUE_POINT_END = "end";

    // ================================================================================
    // Animation Values
    // ================================================================================

    private static final double OPACITY_FULL = 1;
    private static final double OPACITY_ZERO = 0;

    // Time values are in milliseconds
    private static final double TIME_HELP_SCREEN_FADEIN = 150;
    private static final double TIME_HELP_SCREEN_FADEOUT = 200;

    private static final double TIME_SPLASH_SCREEN_FADE = 4000;
    private static final double TIME_SPLASH_SCREEN_FULL_OPACITY = 3000;
    private static final double TIME_SPLASH_SCREEN_INTERRUPT = 2700;

    // ================================================================================
    // Class Variables
    // ================================================================================

    private static double xOffset_, yOffset_;

    private CenterScreen currentScreen_;

    private ImageOverlay currentOverlay_;

    private Timeline splashScreenTimeline_;

    private Node mainScreenNode_;
    private Node mainAllScreenNode_;
    private Node doneScreenNode_;
    private Node searchScreenNode_;
    private Node summaryScreenNode_;

    private Node helpOverlayNode_;
    private Node splashOverlayNode_;

    private DoneScreen doneScreen_;
    private MainScreen mainScreen_;
    private MainScreen mainAllScreen_;
    private SearchScreen searchScreen_;
    private SummaryScreen summaryScreen_;

    private HelpOverlay helpOverlay_;
    private SplashOverlay splashOverlay_;

    private StackPane centerStackPane_;

    // ================================================================================
    // CenterPaneController Constructor
    // ================================================================================

    protected CenterPaneController(StackPane centerStackPane) {
        assert(centerStackPane != null);
        this.centerStackPane_ = centerStackPane;
        createScreens();
        createOverlays();
        setToSummaryScreen();
    }

    // ================================================================================
    // CenterScreen Methods
    // ================================================================================

    /**
     * Switches the current screen in the StackPane that is set within the
     * center region of the BorderPane of the main window.
     *
     * @param taskList    that contains the tasks related to each screen
     * @param screenView  corresponding to the screen to switch to upon update
     */
    protected void updateScreen(List<Task> taskList, ScreenView screenView) {
        assert(taskList != null);
        updateSummaryAndMainScreens(taskList, screenView);

        switch (screenView) {
            case SCREEN_DONE : {
                if (currentScreen_ != doneScreen_) {
                    startScreenSwitchSequence(doneScreenNode_, doneScreen_);
                }

                doneScreen_.updateTaskList(taskList);
                break;
            }

            case SCREEN_MAIN : {
                if (currentScreen_ != mainScreen_) {
                    startScreenSwitchSequence(mainScreenNode_, mainScreen_);
                }

                mainScreen_.updateTaskList(taskList);
                break;
            }

            case SCREEN_MAIN_ALL : {
                if (currentScreen_ != mainAllScreen_) {
                    startScreenSwitchSequence(mainAllScreenNode_, mainAllScreen_);
                }

                mainAllScreen_.updateTaskList(taskList);
                break;
            }

            case SCREEN_SEARCH : {
                if (currentScreen_ != searchScreen_) {
                    startScreenSwitchSequence(searchScreenNode_, searchScreen_);
                }

                searchScreen_.updateTaskList(taskList);
                break;
            }

            case SCREEN_SUMMARY : {
                if (currentScreen_ != summaryScreen_) {
                    // Special exception for summary screen, which requires the
                    // entire screen to be loaded before summarising can start.
                    switchToSummaryScreen();
                }

                summaryScreen_.updateTaskList(taskList);

                if (!summaryScreen_.isSummarising()) {
                    if (!centerStackPane_.getChildren().contains(splashOverlayNode_)) {
                        startScreenSwitchSequenceNoAnimation(mainScreenNode_, mainScreen_);
                    }
                }
                break;
            }

            default:
                System.out.println(MESSAGE_UNABLE_RECOGNISE_SCREEN_TYPE);
                break;
        }
    }

    /**
     * Used to keep both the Summary and Main screens up to date with one another.
     *
     * @param taskList     to update the screen with
     * @param screenView   must correspond to currentScreen and be either SCREEN_MAIN
     *                     or SCREEN_SUMMARY for any updates to take place.
     */
    private void updateSummaryAndMainScreens(List<Task> taskList, ScreenView screenView) {
        if (currentScreen_ == mainScreen_ && screenView == ScreenView.SCREEN_MAIN) {
            summaryScreen_.updateTaskList(taskList);
        } else if (currentScreen_ == summaryScreen_ && screenView == ScreenView.SCREEN_SUMMARY) {
            mainScreen_.updateTaskList(taskList);
            mainAllScreen_.updateTaskList(taskList);
        }
    }

    // Used at startup so that highlighting can start immediately from the first very operation
    protected void initialUpdateMainScreen(List<Task> taskList) {
        mainScreen_.updateTaskList(taskList);
        mainAllScreen_.updateTaskList(taskList);
    }

    // Handle to pass search string between classes
    protected void receiveSearchStringAndPassToSearchScreen(String searchString) {
        searchScreen_.updateSearchHeaderLabelText(searchString);
    }

    // Methods below for scrolling current screen with key input. Scroll bar
    // value is incremented/decremented twice to enable the user scroll faster
    protected void scrollDownCurrentScreen() {
        ScrollPane currScrollPane = ((ScrollPane) (currentScreen_.getNode().lookup(SELECTOR_SCROLL_PANE)));

        ScrollBar currScrollBar = (ScrollBar) currScrollPane.lookup(SELECTOR_SCROLL_BAR);
        currScrollBar.increment();
        currScrollBar.increment();
    }

    protected void scrollUpCurrentScreen() {
        ScrollPane currScrollPane = ((ScrollPane) (currentScreen_.getNode().lookup(SELECTOR_SCROLL_PANE)));

        ScrollBar currScrollBar = (ScrollBar) currScrollPane.lookup(SELECTOR_SCROLL_BAR);
        currScrollBar.decrement();
        currScrollBar.decrement();
    }

    // ================================================================================
    // ImageOverlay Methods
    // ================================================================================

    // A handle to help switch between pages of the HelpOverlay if it is
    // currently being shown.
    protected void showNextHelpPage() {
        if (currentOverlay_ != helpOverlay_) {
            return;
        }
        helpOverlay_.nextPage();
    }

    /**
     * Starts the fade out transition that lasts for TIME_HELP_SCREEN_FADEOUT
     * seconds if the stack contains it and it is the current overlay screen.
     * Each call will create a new FadeTransition to be used for fading the
     * overlay out.
     */
    protected void hideHelpOverlay() {
        if (currentOverlay_ != helpOverlay_ || !centerStackPane_.getChildren().contains(helpOverlayNode_)) {
            return;
        }

        FadeTransition helpOverlayFadeOut = getFadeOutTransition(TIME_HELP_SCREEN_FADEOUT, helpOverlayNode_);
        helpOverlayFadeOut.setOnFinished(e -> {
            centerStackPane_.getChildren().remove(helpOverlayNode_);
            currentOverlay_ = null;
        });
        helpOverlayFadeOut.play();
    }

    /**
     * Fast-forwards the fade animation if user starts typing before TIME_SPLASH_SCREEN_INTERRUPT.
     * The splash screen is automatically removed from the centerStackPane once it has finished
     * playing.
     */
    protected void hideSplashOverlay() {
        if (currentOverlay_ == splashOverlay_ && centerStackPane_.getChildren().contains(splashOverlayNode_)) {
            Duration interruptTime = Duration.millis(TIME_SPLASH_SCREEN_INTERRUPT);
            // Only fast forward the timeline if the current time of the
            // animation is smaller than the given interrupt time. Else, just
            // wait for the animation to end.
            if (splashScreenTimeline_.getCurrentTime().lessThan(interruptTime)) {
                splashScreenTimeline_.jumpTo(Duration.millis(TIME_SPLASH_SCREEN_INTERRUPT));
            }

            splashScreenTimeline_.jumpTo(Duration.millis(TIME_SPLASH_SCREEN_FADE));
        }
    }

    /**
     * Shows the HelpOverlay only if the HelpOverlay is not present. Each call
     * creates a new FadeTransition to be used for fading the overlay in.
     */
    protected void showHelpOverlay() {
        if (currentOverlay_ == helpOverlay_ || centerStackPane_.getChildren().contains(helpOverlay_)) {
            return;
        }

        currentOverlay_ = helpOverlay_;
        centerStackPane_.getChildren().add(helpOverlayNode_);
        helpOverlayNode_.toFront();

        FadeTransition helpOverlayFadeIn = getFadeInTransition(TIME_HELP_SCREEN_FADEIN, helpOverlayNode_);
        helpOverlayFadeIn.play();
    }

    /**
     * Shows the SplashOverlay which is only used at start-up. The main
     * animation of the overlay is contained within the
     * buildSplashScreenAnimation method.
     */
    protected void showSplashOverlay() {
        currentOverlay_ = splashOverlay_;
        centerStackPane_.getChildren().add(splashOverlayNode_);

        buildSplashScreenAnimation();
        splashScreenTimeline_.play();
    }

    // ================================================================================
    // Transition Methods
    // ================================================================================

    /**
     * Creates a splash screen that maintains full opacity for
     * TIME_SPLASH_SCREEN_FULL_OPACITY seconds before completely fading out in
     * (TIME_SPLASH_SCREEN_FADE-TIME_SPLASH_SCREEN_FULL_OPACITY) seconds or
     * until the user starts to type.
     */
    private void buildSplashScreenAnimation() {
        Duration fullOpacityDuration = Duration.millis(TIME_SPLASH_SCREEN_FULL_OPACITY);
        KeyValue fullOpacityKeyValue = new KeyValue(splashOverlayNode_.opacityProperty(), OPACITY_FULL);
        KeyFrame fullOpacityFrame = new KeyFrame(fullOpacityDuration, fullOpacityKeyValue);

        Duration zeroOpacityDuration = Duration.millis(TIME_SPLASH_SCREEN_FADE);
        KeyValue zeroOpacityKeyValue = new KeyValue(splashOverlayNode_.opacityProperty(), OPACITY_ZERO);
        KeyFrame zeroOpacityFrame = new KeyFrame(zeroOpacityDuration, zeroOpacityKeyValue);

        splashScreenTimeline_ = new Timeline(fullOpacityFrame, zeroOpacityFrame);
        splashScreenTimeline_.setOnFinished(e -> {
                                              centerStackPane_.getChildren().remove(splashOverlayNode_);
                                              currentOverlay_ = null;
                                              if (!summaryScreen_.isSummarising()) {
                                                  startScreenSwitchSequenceNoAnimation(mainScreenNode_, mainScreen_);
                                              }
        });
    }

    private FadeTransition getFadeOutTransition(double timeInMs, Node transitingNode) {
        FadeTransition fadeTransition = new FadeTransition(Duration.millis(timeInMs), transitingNode);

        fadeTransition.setFromValue(OPACITY_FULL);
        fadeTransition.setToValue(OPACITY_ZERO);
        fadeTransition.setInterpolator(Interpolator.EASE_OUT);

        return fadeTransition;
    }

    private FadeTransition getFadeInTransition(double timeInMs, Node transitingNode) {
        FadeTransition fadeTransition = new FadeTransition(Duration.millis(timeInMs), transitingNode);

        fadeTransition.setFromValue(OPACITY_ZERO);
        fadeTransition.setToValue(OPACITY_FULL);
        fadeTransition.setInterpolator(Interpolator.EASE_IN);

        return fadeTransition;
    }

    /**
     * Combines the screen changing transitions of the outgoing and incoming
     * screens by playing them in sequence.
     *
     * @param nodeToSwitchIn    must be the corresponding Node of the CenterScreen passed in.
     * @param screenToSwitchIn  the CenterScreen to be switched in and should not be contained
     *                          within the centerStackPane.
     */
    private void startScreenSwitchSequence(Node nodeToSwitchIn, CenterScreen screenToSwitchIn) {
        ParallelTransition incomingScreenTransition = screenToSwitchIn.getScreenSwitchInSequence();
        incomingScreenTransition.setOnFinished(incoming -> currentScreen_ = screenToSwitchIn);

        SequentialTransition outgoingScreenTransition = currentScreen_.getScreenSwitchOutSequence();
        outgoingScreenTransition.setOnFinished(outgoing -> {
            centerStackPane_.getChildren().remove(currentScreen_.getNode());
            centerStackPane_.getChildren().add(nodeToSwitchIn);
            incomingScreenTransition.play();
        });
        outgoingScreenTransition.play();
    }

    private void startScreenSwitchSequenceNoAnimation(Node nodeToSwitchIn, CenterScreen screenToSwitchIn) {
        ParallelTransition incomingScreenTransition = screenToSwitchIn.getScreenSwitchInSequence();
        incomingScreenTransition.setOnFinished(incoming -> currentScreen_ = screenToSwitchIn);

        centerStackPane_.getChildren().remove(currentScreen_.getNode());
        centerStackPane_.getChildren().add(nodeToSwitchIn);

        incomingScreenTransition.jumpTo(TRANSITION_CUE_POINT_END);
        incomingScreenTransition.play();
    }


    // Exception case for switching to SummaryScreen, which wouldn't show
    // correctly if the screen switch transition of the outgoing screen is
    // played together.
    private void switchToSummaryScreen() {
        centerStackPane_.getChildren().add(summaryScreenNode_);
        centerStackPane_.getChildren().remove(currentScreen_.getNode());

        summaryScreen_.getScreenSwitchInSequence().play();

        currentScreen_ = summaryScreen_;
    }

    // ================================================================================
    // Init Methods
    // ================================================================================

    private void createOverlays() {
        createHelpOverlay();
        createSplashOverlay();
    }

    private void createScreens() {
        createMainScreen();
        createMainAllScreen();
        createDoneScreen();
        createSearchScreen();
        createSummaryScreen();
    }

    private void createHelpOverlay() {
        this.helpOverlay_ = new HelpOverlay();
        this.helpOverlayNode_ = helpOverlay_.getNode();
    }

    private void createSplashOverlay() {
        this.splashOverlay_ = new SplashOverlay();
        this.splashOverlayNode_ = splashOverlay_.getNode();
    }

    private void createMainScreen() {
        this.mainScreen_ = new MainScreen();
        this.mainScreenNode_ = mainScreen_.getNode();
        addMouseDragListeners(mainScreenNode_);
    }

    private void createMainAllScreen() {
        this.mainAllScreen_ = new MainScreen();
        this.mainAllScreenNode_ = mainAllScreen_.getNode();
        addMouseDragListeners(mainAllScreenNode_);
    }

    private void createDoneScreen() {
        this.doneScreen_ = new DoneScreen();
        this.doneScreenNode_ = doneScreen_.getNode();
        addMouseDragListeners(doneScreenNode_);
    }

    private void createSearchScreen() {
        this.searchScreen_ = new SearchScreen();
        this.searchScreenNode_ = searchScreen_.getNode();
        addMouseDragListeners(searchScreenNode_);
    }

    private void createSummaryScreen() {
        this.summaryScreen_ = new SummaryScreen();
        this.summaryScreenNode_ = summaryScreen_.getNode();
        addMouseDragListeners(summaryScreenNode_);
    }

    private void setToSummaryScreen() {
        centerStackPane_.getChildren().add(summaryScreenNode_);
        currentScreen_ = summaryScreen_;
    }

```
###### procrastinate\ui\CenterScreen.java
``` java
package procrastinate.ui;

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Calendar;
import java.util.Date;
import java.util.List;

import javafx.animation.FadeTransition;
import javafx.animation.Interpolator;
import javafx.animation.ParallelTransition;
import javafx.animation.SequentialTransition;
import javafx.beans.binding.Bindings;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.SimpleIntegerProperty;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Node;
import javafx.scene.layout.VBox;
import javafx.util.Duration;
import javafx.util.converter.NumberStringConverter;
import procrastinate.task.Task;

/**
 * <h1>This class is the parent class of all the Screens implemented which loads the layout
 * required and applies the CSS styling.</h1>
 *
 * It contains mostly utility methods to be used by its subclasses which are fully implemented
 * and some abstract methods for its subclasses.
 */
public abstract class CenterScreen extends VBox {

    // ================================================================================
    // Message Strings
    // ================================================================================

    protected static final String FX_BACKGROUND_IMAGE_NULL = "-fx-background-image: null;";

    protected static final String MESSAGE_UNABLE_TO_DETERMINE_TYPE = "Unable to determine TaskType for adding.";
    protected static final String MESSAGE_UNABLE_TO_RECOGNISE_NODE = "Unable to recognise Node.";

    protected static final String SELECTOR_CATEGORY_VBOX = "#categoryVBox";

    protected static final String SEPARATOR_EVENT_DATE_GENERAL = "\nto ";
    protected static final String SEPARATOR_EVENT_DATE_SAME_DAY = " to ";
    protected static final String SEPARATOR_FRIENDLY_DATE_OR_TIME = " ";

    private static final String LOCATION_CENTER_SCREEN_LAYOUT = "views/CenterScreen.fxml";

    private static final String SEPARATOR_UI_NUMBER = ". ";

    private static final String DATE_TODAY = "Today";
    private static final String DATE_TOMORROW = "Tomorrow";

    // ================================================================================
    // Constants
    // ================================================================================

    protected static final double OPACITY_ZERO = 0;
    protected static final double OPACITY_FULL = 1;

    // Can be changed to adjust the number of subcategories shown in the 'Upcoming' category
    private static final int NUMBER_OF_DAYS_IN_A_WEEK = 7;

    // ================================================================================
    // Class Variables
    // ================================================================================

    protected IntegerProperty taskCount = new SimpleIntegerProperty(1);
    protected StringProperty taskCountFormatted = new SimpleStringProperty();
    protected StringProperty taskCountString = new SimpleStringProperty();

    protected SimpleDateFormat dateFormatter = new SimpleDateFormat("d MMM");
    protected SimpleDateFormat timeFormatter = new SimpleDateFormat("h:mma");

    private SimpleDateFormat dateFormatterWithFriendlyDayAndYear_ = new SimpleDateFormat("EEE d MMM''yy h:mma");
    private SimpleDateFormat friendlyDayFormatter_ = new SimpleDateFormat("EEE");
    private SimpleDateFormat yearFormatter_ = new SimpleDateFormat("yyyy");

    private Node node_;

    private Date today_;
    private Date currentDate_;
    private Date endOfWeek_;

    // ================================================================================
    // FXML Field Variables
    // ================================================================================

    @FXML
    private VBox mainVBox;

    // ================================================================================
    // CenterScreen Constructor
    // ================================================================================

    protected CenterScreen() {
        loadLayout();
        setupBinding();
    }

    // ================================================================================
    // CenterScreen Methods
    // ================================================================================

    /**
     * Setup the various categories that tasks can fall under
     */
    protected abstract void createCategories();

    /**
     * The list of tasks displayed is updated by removing all previously added
     * tasks and re-adding them back to allow the line number to be sorted by
     * category and not insertion time.
     *
     * Dreams are directly added via this method but Deadlines and Events are
     * passed to two different addTask methods depending on their (start) dates.
     *
     * @param taskList    to be added onto the screen
     */
    protected abstract void updateTaskList(List<Task> taskList);

    // SequentialTransition used to provide a node by node fade out effect
    protected abstract SequentialTransition getScreenSwitchOutSequence();

    // ParallelTransition used to prevent animation clashing
    protected abstract ParallelTransition getScreenSwitchInSequence();

    protected void setMainVBoxBackgroundImage(VBox mainVBox, String value) {
        mainVBox.setStyle(value);
    }

    /**
     * Updates the class variable Dates that are used to compare the event dates
     * and generate subcategories for 'Upcoming'
     */
    protected void updateDates() {
        today_ = Date.from(getInstantFromLocalDateTime(getDateTimeStartOfToday()));
        currentDate_ = new Date();
        endOfWeek_ = getEndOfWeekDate(today_);
    }

    // ================================================================================
    // Animation Methods
    // ================================================================================

    protected FadeTransition generateFadeInTransition(Node nodeToFade, int fadeInTime) {
        FadeTransition transition = new FadeTransition(Duration.millis(fadeInTime), nodeToFade);

        transition.setFromValue(OPACITY_ZERO);
        transition.setToValue(OPACITY_FULL);
        transition.setInterpolator(Interpolator.EASE_IN);

        return transition;
    }

    protected FadeTransition generateFadeOutTransition(Node nodeToFade, int fadeOutTime) {
        FadeTransition transition = new FadeTransition(Duration.millis(fadeOutTime), nodeToFade);

        transition.setFromValue(OPACITY_FULL);
        transition.setToValue(OPACITY_ZERO);
        transition.setInterpolator(Interpolator.EASE_IN);

        return transition;
    }

    // ================================================================================
    // Date Format Methods
    // ================================================================================

    protected String getDateFormatForDeadlineWithDifferentYear(Date date) {
        return dateFormatterWithFriendlyDayAndYear_.format(date);
    }

    protected String getDateFormatForEventWithDifferentYearButInOneDay(Date date, Date endDate) {
        return dateFormatterWithFriendlyDayAndYear_.format(date) + SEPARATOR_EVENT_DATE_SAME_DAY +
               timeFormatter.format(endDate);
    }

    protected String getDateFormatForEventWithDifferentYearAndDifferentDays(Date date, Date endDate) {
        return dateFormatterWithFriendlyDayAndYear_.format(date) + SEPARATOR_EVENT_DATE_GENERAL +
               dateFormatterWithFriendlyDayAndYear_.format(endDate);
    }

    protected String getDateFormatForDeadlineWithSameYear(Date date) {
        return getFriendlyDayFormat(date) + SEPARATOR_FRIENDLY_DATE_OR_TIME +
               dateFormatter.format(date) + SEPARATOR_FRIENDLY_DATE_OR_TIME +
               timeFormatter.format(date);
    }

    protected String getDateFormatForEventWithSameYearAndInOneDay(Date date, Date endDate) {
        return getFriendlyDayFormat(date) + SEPARATOR_FRIENDLY_DATE_OR_TIME +
               dateFormatter.format(date) + SEPARATOR_FRIENDLY_DATE_OR_TIME +
               timeFormatter.format(date) + SEPARATOR_EVENT_DATE_SAME_DAY +
               timeFormatter.format(endDate);
    }

    protected String getDateFormatForEventWithSameYearAndDifferentDays(Date date, Date endDate) {
        return getFriendlyDayFormat(date) + SEPARATOR_FRIENDLY_DATE_OR_TIME +
               dateFormatter.format(date) + SEPARATOR_FRIENDLY_DATE_OR_TIME +
               timeFormatter.format(date) + SEPARATOR_EVENT_DATE_GENERAL +
               getFriendlyDayFormat(endDate) + SEPARATOR_FRIENDLY_DATE_OR_TIME +
               dateFormatter.format(endDate) + SEPARATOR_FRIENDLY_DATE_OR_TIME +
               timeFormatter.format(endDate);
    }

    protected String getDateFormatForUpcomingEventAndInOneDay(Date startDate, Date endDate) {
        return timeFormatter.format(startDate) + SEPARATOR_EVENT_DATE_SAME_DAY +
               timeFormatter.format(endDate);
    }

    protected String getDateFormatForUpcomingEventButDifferentDays(Date startDate, Date endDate) {
        return timeFormatter.format(startDate) + SEPARATOR_EVENT_DATE_GENERAL +
               getFriendlyDayFormatForUpcomingCategory(endDate) + SEPARATOR_FRIENDLY_DATE_OR_TIME +
               timeFormatter.format(endDate);
    }

    protected String getDateFormatForUpcomingEventButDifferentWeek(Date startDate, Date endDate) {
        return timeFormatter.format(startDate) + SEPARATOR_EVENT_DATE_GENERAL +
               getFriendlyDayFormat(endDate) + SEPARATOR_FRIENDLY_DATE_OR_TIME +
               dateFormatter.format(endDate) + SEPARATOR_FRIENDLY_DATE_OR_TIME +
               timeFormatter.format(endDate);
    }

    protected String getDateFormatForUpcomingEventButDifferentYear(Date startDate, Date endDate) {
        return timeFormatter.format(startDate) + SEPARATOR_EVENT_DATE_GENERAL +
               dateFormatterWithFriendlyDayAndYear_.format(endDate);
    }

    // ================================================================================
    // Utility methods
    // ================================================================================

    protected boolean isSameYear(Date firstDate, Date secondDate) {
        return yearFormatter_.format(firstDate).equals(yearFormatter_.format(secondDate));
    }

    protected boolean isSameDay(Date firstDate, Date secondDate) {
        Calendar calendar = Calendar.getInstance();

        calendar.setTime(firstDate);
        int firstDay = calendar.get(Calendar.DAY_OF_YEAR);

        calendar.setTime(secondDate);
        int secondDay = calendar.get(Calendar.DAY_OF_YEAR);

        return firstDay == secondDay;
    }

    /**
     * Converts a LocalDateTime to an Instant
     *
     * @param localDateTime    to be converted
     * @return Instant         generated from the given LocalDateTime
     */
    protected Instant getInstantFromLocalDateTime(LocalDateTime localDateTime) {
        return localDateTime.atZone(ZoneId.systemDefault()).toInstant();
    }

    /**
     * Creates a LocalDateTime that reflects today's date at 0000hrs, to be used
     * for more accurate comparison of the date of tasks.
     *
     * @return LocalDateTime of today at 0000hrs
     */
    protected LocalDateTime getDateTimeStartOfToday() {
        return LocalDate.now().atStartOfDay();
    }

    private String getFriendlyDayFormat(Date date) {
        return friendlyDayFormatter_.format(date);
    }

    // Generates the date comparing tasks to be placed in the 'Upcoming' category
    private Date getEndOfWeekDate(Date today) {
        Calendar calendar = Calendar.getInstance();

        calendar.setFirstDayOfWeek(Calendar.MONDAY);
        calendar.setTime(today);
        calendar.add(Calendar.DAY_OF_WEEK, NUMBER_OF_DAYS_IN_A_WEEK);

        return calendar.getTime();
    }

    private String getFriendlyDayFormatForUpcomingCategory(Date date) {
        LocalDateTime startingDateTime = LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());
        if (startingDateTime.getDayOfMonth() == getDateTimeStartOfToday().getDayOfMonth()) {
            return DATE_TODAY;

        } else if (startingDateTime.getDayOfMonth() == getDateTimeStartOfToday().plusDays(1).getDayOfMonth()) {
            return DATE_TOMORROW;

        } else {
            return getFriendlyDayFormat(date);
        }
    }

    // ================================================================================
    // Init Methods
    // ================================================================================

    private void loadLayout() {
        FXMLLoader loader = new FXMLLoader(getClass().getResource(LOCATION_CENTER_SCREEN_LAYOUT));
        loader.setController(this); // Required due to different package
                                    // declaration from Main
        try {
            this.node_ = loader.load();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Creates a formatted task counter for use when adding tasks onto screen.
     */
    private void setupBinding() {
        taskCountString.bindBidirectional(taskCount, new NumberStringConverter());
        taskCountFormatted.bind(Bindings.concat(taskCountString).concat(SEPARATOR_UI_NUMBER));
    }

    // ================================================================================
    // Getter Methods
    // ================================================================================

```
###### procrastinate\ui\DoneScreen.java
``` java
package procrastinate.ui;

import java.util.Date;
import java.util.List;

import javafx.scene.layout.VBox;
import procrastinate.task.Deadline;
import procrastinate.task.Event;
import procrastinate.task.Task;

/**
 * <h1>DoneScreen is a subclass of the SingleCategoryScreen that shows all
 * tasks which are done in a single CategoryBox.</h1>
 *
 * It will only add tasks which are done into its CategoryBox while ignoring all
 * other tasks passed in via the updateTaskList method.
 */
public class DoneScreen extends SingleCategoryScreen {

    // ================================================================================
    // Message strings
    // ================================================================================

    private static final String HEADER_TEXT = "Your completed tasks";

    private static final String FX_BACKGROUND_IMAGE_NO_DONE_TASKS = "-fx-background-image: url('/procrastinate/ui/images/no-done-tasks.png')";

    // ================================================================================
    // DoneScreen Constructor
    // ================================================================================

    protected DoneScreen() {
        super(HEADER_TEXT);
    }

    // ================================================================================
    // DoneScreen Methods
    // ================================================================================

    @Override
    protected void updateTaskList(List<Task> taskList) {
        getUpdatedDates();
        clearTaskList();

        mainVBox.getChildren().add(thisCategoryNode);

        String dateString;

        for (Task task : taskList) {
            if (task.isDone()) {
                taskCount.set(taskCount.get() + 1);

                switch (task.getType()) {

                    case DEADLINE : {
                        Date date =((Deadline) task).getDate();

                        dateString = getDateFormatForDateline(date);

                        addDoneTask(taskCountFormatted.get(), task, dateString);
                        break;
                    }

                    case EVENT : {
                        Date startDate = ((Event) task).getStartDate();
                        Date endDate = ((Event) task).getEndDate();

                        dateString = getDateFormatForEvent(startDate, endDate);

                        addDoneTask(taskCountFormatted.get(), task, dateString);
                        break;
                    }

                    case DREAM : {
                        addDoneTask(taskCountFormatted.get(), task, null);
                        break;
                    }

                    default: {
                        System.out.println(MESSAGE_UNABLE_TO_DETERMINE_TYPE);
                        break;
                    }
                }
            }
        }

        checkIfMainVBoxIsEmpty(mainVBox);
    }

    private void addDoneTask(String taskCount, Task task, String dateString) {
        TaskEntry taskEntry;

        if (dateString == null) {
            taskEntry = new TaskEntry(taskCount, task.getDescription(), task.isDone());
        } else {
            taskEntry = new TaskEntry(taskCount, task.getDescription(), dateString, task.isDone());
        }

        thisCategoryTaskList.getChildren().add(taskEntry.getEntryDisplay());
    }

    private String getDateFormatForDateline(Date date) {
        String dateString;

        boolean isSameYear = isSameYear(date, today);
        if (isSameYear) {
            dateString = getDateFormatForDeadlineWithSameYear(date);

        } else {
            dateString = getDateFormatForDeadlineWithDifferentYear(date);
        }

        return dateString;
    }

    private String getDateFormatForEvent(Date startDate, Date endDate) {
        String dateString;

        boolean isStartSameYear = isSameYear(startDate, today);
        if (isStartSameYear) {
            if (isSameDay(startDate, endDate)) {
                dateString = getDateFormatForEventWithSameYearAndInOneDay(startDate, endDate);

            } else {
                dateString = getDateFormatForEventWithSameYearAndDifferentDays(startDate, endDate);
            }

        } else {
            dateString = getDateFormatForEventWithDifferentYearAndDifferentDays(startDate, endDate);
        }

        return dateString;
    }

    // ================================================================================
    // Utility Methods
    // ================================================================================

    private void checkIfMainVBoxIsEmpty(VBox mainVBox) {
        if (thisCategoryTaskList.getChildren().isEmpty()) {
            mainVBox.getChildren().remove(thisCategoryNode);
            mainVBox.setStyle(FX_BACKGROUND_IMAGE_NO_DONE_TASKS);

        } else {
            setMainVBoxBackgroundImage(mainVBox, FX_BACKGROUND_IMAGE_NULL);
        }
    }
}
```
###### procrastinate\ui\HelpOverlay.java
``` java
package procrastinate.ui;

import javafx.geometry.Pos;
import javafx.scene.image.Image;
import javafx.scene.layout.VBox;

/**
 * <h1>HelpOverlay contain the reference sheets to be shown as a 'help' screen.</h1>
 *
 * The reference sheets are pictures set within a ImageView and there are currently
 * 2 different pictures to be shown/switched.
 */
public class HelpOverlay extends ImageOverlay {

    // ================================================================================
    // Message Strings
    // ================================================================================

    private static final String LOCATION_REFERENCE_SHEET = "images/referencesheet.png";
    private static final String LOCATION_REFERENCE_SHEET_2 = "images/referencesheet2.png";

    private static final String STYLE_CONTAINER_PADDING = "-fx-padding: 0 30 0 30;";
    private static final String STYLE_WRAPPER_BACKGROUND_RADIUS = "-fx-background-radius: 20;";
    private static final String STYLE_WRAPPER_BACKGROUND_COLOR = "-fx-background-color: #365fac;";

    // ================================================================================
    // Constants
    // ================================================================================

    private static final int WRAPPER_PREF_HEIGHT = 430;
    private static final int WRAPPER_PREF_WIDTH = 400;

    // ================================================================================
    // Class Variables
    // ================================================================================

    private boolean isFirstPage_ = true;

    // ================================================================================
    // HelpOverlay Constructor
    // ================================================================================

    protected HelpOverlay() {
        setImage();
        adjustStylesAndAddWrapper();
    }

    // ================================================================================
    // HelpOverlay Methods
    // ================================================================================

```
###### procrastinate\ui\HelpOverlay.java
``` java
    @Override
    protected void setImage() {
        // Set to first page of Help sheet
        imageView.setImage(new Image(HelpOverlay.class.getResource(LOCATION_REFERENCE_SHEET).toExternalForm()));
        imageView.fitWidthProperty().set(400);
    }

    /**
     * Fits the loaded image into the center of the screen with the specified side padding.
     */
    private void adjustStylesAndAddWrapper() {
        container.setStyle(STYLE_CONTAINER_PADDING);

        container.getChildren().clear();
        container.getChildren().add(createWrapper());
    }

    /**
     * Creates the wrapper required to keep the reference sheet in the center of the screen.
     * It is required as the background color and box surrounding the help commands are rendered
     * within Java and not just from the background image provided.
     *
     * @return VBox    to wrap the present ImageView and provide it with customised styling and sizing.
     */
    private VBox createWrapper() {
        VBox wrapper = new VBox(imageView);

        wrapper.setAlignment(Pos.TOP_CENTER);
        wrapper.setPrefSize(WRAPPER_PREF_WIDTH, WRAPPER_PREF_HEIGHT);
        wrapper.setStyle(STYLE_WRAPPER_BACKGROUND_COLOR +
                         STYLE_WRAPPER_BACKGROUND_RADIUS);

        return wrapper;
    }
}
```
###### procrastinate\ui\ImageOverlay.java
``` java
package procrastinate.ui;

import java.io.IOException;

import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Node;
import javafx.scene.image.ImageView;
import javafx.scene.layout.VBox;

/**
 * <h1>ImageOverlay contains an ImageView wrapped in a VBox that is placed on top of
 * a white translucent background to provide an overlay effect.</h1>
 *
 * Different images can be set in the ImageView and additional nodes can be added into
 * the VBox provided.
 */
public abstract class ImageOverlay {

    // ================================================================================
    // Message Strings
    // ================================================================================

    private static final String LOCATION_HELP_OVERLAY_LAYOUT = "views/ImageOverlay.fxml";

    // ================================================================================
    // Class Variables
    // ================================================================================

    protected Node node;

    // ================================================================================
    // FXML Field Variables
    // ================================================================================

    @FXML
    protected ImageView imageView;
    @FXML
    protected VBox container;

    // ================================================================================
    // ImageOverlay Constructor
    // ================================================================================

    protected ImageOverlay() {
        loadLayout();
    }

    // ================================================================================
    // ImageOverlay Methods
    // ================================================================================

    protected abstract void setImage();

    // ================================================================================
    // Init Methods
    // ================================================================================

    private void loadLayout() {
        FXMLLoader loader = new FXMLLoader(getClass().getResource(LOCATION_HELP_OVERLAY_LAYOUT));
        loader.setController(this); // Required due to different package
                                    // declaration from Main
        try {
            this.node = loader.load();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    // ================================================================================
    // Getter Methods
    // ================================================================================

```
###### procrastinate\ui\MainScreen.java
``` java
package procrastinate.ui;

import javafx.scene.layout.VBox;

/**
 * <h1>MainScreen is a subclass of the MultiCategoryScreen and is used to show all
 * the outstanding tasks or all the different tasks.</h1>
 *
 * The MainScreen is the most frequently used screen which will be shown and updated
 * after most commands are executed.
 */
public class MainScreen extends MultiCategoryScreen {

    // ================================================================================
    // Message Strings
    // ================================================================================

    private static final String FX_BACKGROUND_IMAGE_NO_TASKS = "-fx-background-image: url('/procrastinate/ui/images/no-tasks.png')";

    // ================================================================================
    // MainScreen Constructor
    // ================================================================================

    protected MainScreen() {
        super();
    }

    // ================================================================================
    // MainScreen Methods
    // ================================================================================

    @Override
    protected void setBackgroundImageIfMainVBoxIsEmpty(VBox mainVBox) {
        if (mainVBox.getChildren().isEmpty()) {
            mainVBox.setStyle(FX_BACKGROUND_IMAGE_NO_TASKS);
        }
    }

}
```
###### procrastinate\ui\MultiCategoryScreen.java
``` java
package procrastinate.ui;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.TextStyle;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.stream.Collectors;

import javafx.animation.FadeTransition;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.ParallelTransition;
import javafx.animation.SequentialTransition;
import javafx.animation.Timeline;
import javafx.scene.Node;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.VBox;
import javafx.util.Duration;
import procrastinate.task.Deadline;
import procrastinate.task.Event;
import procrastinate.task.Task;

/**
 * <h1>A subclass of CenterScreen and contains multiple categories in their
 * respective CategoryBox.</h1>
 *
 * There are 5 different categories - Overdue, Upcoming, Future, Dreams and Done.
 *
 * <p>It is important to note that the 'Upcoming' CategoryBox contains
 * SubcategoryBox as its children and the different TaskEntry should be
 * added into the SubcategoryBox instead.
 */
public abstract class MultiCategoryScreen extends CenterScreen {

    // ================================================================================
    // Message Strings
    // ================================================================================

    private static final String CATEGORY_OVERDUE = "Overdue";
    private static final String CATEGORY_UPCOMING = "Upcoming";
    private static final String CATEGORY_FUTURE = "Future";
    private static final String CATEGORY_DREAMS = "Dreams";
    private static final String CATEGORY_DONE = "Done";

    private static final String SUBCATEGORY_TODAY = "Today";
    private static final String SUBCATEGORY_TOMORROW = "Tomorrow";

    // ================================================================================
    // Animation Values
    // ================================================================================
    // Time values used are in milliseconds
    private static final int TIME_TRANSITION_CATEGORY_FADE_IN = 250;
    private static final int TIME_TRANSITION_CATEGORY_FADE_OUT = 200;
    private static final int TIME_TRANSITION_SUBCATEGORY_FADE_IN = 200;
    private static final int TIME_TRANSITION_SUBCATEGORY_FADE_OUT = 150;

    private static final int TIME_TRANSITION_TASK_ENTRY_FADE_OUT = 100;

    private static final int TIME_TRANSITION_SCREEN_SWITCH_IN = 500;
    private static final int TIME_TRANSITION_SCREEN_SWITCH_OUT = 150;

    private static final int STYLE_BACKGROUND_HIGHLIGHT_FRAME_TIME = 10;
    private static final int STYLE_BACKGROUND_HIGHLIGHT_FULL_OPACITY = 100;

    private static final double STYLE_BACKGROUND_HIGHLIGHT_RATE = 0.8;

    private static final String STYLE_BACKGROUND_HIGHLIGHT_FORMAT = "-fx-background-color: rgb(250,221,177, %.2f);";

    // ================================================================================
    // Class Variables
    // ================================================================================
    // Nodes are used to add them onto the screen
    protected Node overdueNode;
    protected Node upcomingNode;
    protected Node futureNode;
    protected Node dreamsNode;
    protected Node doneNode;

    protected ArrayList<Node> nodeList = new ArrayList<>();
    protected ArrayList<VBox> upcomingSubcategories = new ArrayList<>();

    // Used to determine if the subcategory is to be faded in or out.
    // Each element of subcategoryVisibilityTracker corresponds to the subcategory at a particular index,
    // '0' indicates visible/faded in and '1' indicates it has been faded out previously.
    protected int[] subcategoryVisibilityTracker;

    // The main variables to call when adding tasks since they act as a task
    // list for a TaskEntry to be displayed
    protected VBox overdueTaskList;
    protected VBox upcomingTaskList;
    protected VBox futureTaskList;
    protected VBox dreamsTaskList;
    protected VBox doneTaskList;

    protected Date today;
    protected Date currentDate;
    protected Date endOfWeek;

    protected VBox mainVBox;

    // Used for tracking changes and animating add/edit/deletes
    protected ArrayList<Task> prevTaskList;

    // ================================================================================
    // MultiCategoryScreen Constructor
    // ================================================================================

    protected MultiCategoryScreen() {
        super();
        createCategories();
        retrieveFxmlElements();
    }

    // ================================================================================
    // MultiCategoryScreen Methods
    // ================================================================================

    // To allow different background images to be set
    protected abstract void setBackgroundImageIfMainVBoxIsEmpty(VBox mainVBox);

    @Override
    protected void updateTaskList(List<Task> taskList) {
        FadeTransition fadeOutDeletedTaskEntry = fadeOutDeletedTaskEntry(taskList);

        fadeOutDeletedTaskEntry.setOnFinished(finish -> {
            getUpdatedDates();
            clearTaskList();

            for (Task task : taskList) {
                taskCount.set(taskCount.get() + 1);

                addTaskByType(task);
            }

            updateDisplay();
            highlightAddedOrEditedTaskEntry(taskList);
            prevTaskList = (ArrayList<Task>) taskList;
        });

        fadeOutDeletedTaskEntry.play();
    }

    @Override
    protected SequentialTransition getScreenSwitchOutSequence() {
        SequentialTransition switchOutTransition = new SequentialTransition();

        for (Node node : nodeList) {
            if (mainVBox.getChildren().contains(node)) {
                switchOutTransition.getChildren().add(0, generateFadeOutTransition(node, TIME_TRANSITION_SCREEN_SWITCH_OUT));
            }
        }

        return switchOutTransition;
    }

    @Override
    protected ParallelTransition getScreenSwitchInSequence() {
        ParallelTransition switchInTransition = new ParallelTransition();

        for (Node node : nodeList) {
            if (mainVBox.getChildren().contains(node)) {
                switchInTransition.getChildren().add(generateFadeInTransition(node, TIME_TRANSITION_SCREEN_SWITCH_IN));
            }
        }

        return switchInTransition;
    }

    /**
     * Used when updating the task list, removes all tasks and resets the task counter
     */
    protected void clearTaskList() {
        resetTaskCount();
        resetTaskList();

        generateUpcomingSubcategories();
    }

    protected void getUpdatedDates() {
        updateDates();

        today = getToday();
        endOfWeek = getEndOfWeek();
        currentDate = getCurrentDate();
    }

    // ================================================================================
    // Task Adding Methods
    // ================================================================================

    protected void addTaskByType(Task task) {
        Date taskDate;
        switch (task.getType()) {

            case DEADLINE : {
                taskDate = ((Deadline) task).getDate();
                addDeadlineOrEvent(task, taskDate);
                break;
            }

            case EVENT : {
                taskDate = ((Event) task).getStartDate();
                addDeadlineOrEvent(task, taskDate);
                break;
            }

            case DREAM : {
                TaskEntry taskEntry = new TaskEntry(taskCountFormatted.get(), task.getDescription(), task.isDone());
                addDream(task, taskEntry);
                break;
            }

            default: {
                System.out.println(MESSAGE_UNABLE_TO_DETERMINE_TYPE);
                break;
            }
        }
    }

    // After tasks are filtered by type, it is filtered by the year of the (start) date
    private void addDeadlineOrEvent(Task task, Date taskDate) {
        boolean isSameStartYear = isSameYear(today, taskDate);

        if (isSameStartYear) {
            addSameStartYearTask(task, taskDate);
        } else {
            addDifferentStartYearTask(task, taskDate);
        }
    }

    private void addDream(Task task, TaskEntry taskEntry) {
        if (task.isDone()) {
            doneTaskList.getChildren().add(taskEntry.getEntryDisplay());
        } else {
            dreamsTaskList.getChildren().add(taskEntry.getEntryDisplay());
        }
    }

    private void addSameStartYearTask(Task task, Date date) {
        String dateString;

        switch (task.getType()) {

            case DEADLINE : {
                dateString = getDateFormatForDeadlineWithSameYear(date);

                String taskCount = taskCountFormatted.get();
                TaskEntry taskEntry = new TaskEntry(taskCount, task.getDescription(), dateString, task.isDone());

                addSameStartYearTaskToTaskList(task, date, taskCount, taskEntry);
                break;
            }

            case EVENT : {
                Date endDate = ((Event) task).getEndDate();
                boolean isSameEndYear = isSameYear(today, endDate);
                dateString = getDateFormatForEventWithSameStartYear(date, endDate, isSameEndYear);

                String taskCount = taskCountFormatted.get();
                TaskEntry taskEntry = new TaskEntry(taskCount, task.getDescription(), dateString, task.isDone());

                addSameStartYearTaskToTaskList(task, date, taskCount, taskEntry);
                break;
            }

            default: {
                System.out.println(MESSAGE_UNABLE_TO_DETERMINE_TYPE);
                break;
            }
        }
    }

    private void addSameStartYearTaskToTaskList(Task task, Date date, String taskCount, TaskEntry taskEntry) {
        if        (task.isDone()) {
            doneTaskList.getChildren().add(taskEntry.getEntryDisplay());

        } else if (date.before(currentDate)) {
            overdueTaskList.getChildren().add(taskEntry.getEntryDisplay());

        } else if (date.before(endOfWeek)) {
            addUpcomingTask(task, date, taskCount);

        } else {
            futureTaskList.getChildren().add(taskEntry.getEntryDisplay());
        }
    }

    private void addDifferentStartYearTask(Task task, Date date) {
        String dateString;

        switch (task.getType()) {

            case DEADLINE : {
                dateString = getDateFormatForDeadlineWithDifferentYear(date);

                TaskEntry taskEntry = new TaskEntry(taskCountFormatted.get(), task.getDescription(), dateString, task.isDone());

                addDifferentStartYearTaskToTaskList(task, date, taskEntry);
                break;
            }

            case EVENT : {
                Date endDate = ((Event) task).getEndDate();
                boolean isSameEndYear = isSameYear(date, endDate);

                dateString = getDateFormatForEventWithDifferentStartYear(date, endDate, isSameEndYear);
                TaskEntry taskEntry = new TaskEntry(taskCountFormatted.get(), task.getDescription(), dateString, task.isDone());

                addDifferentStartYearTaskToTaskList(task, date, taskEntry);
                break;
            }

            default: {
                System.out.println(MESSAGE_UNABLE_TO_DETERMINE_TYPE);
                break;
            }
        }
    }

    private void addDifferentStartYearTaskToTaskList(Task task, Date date, TaskEntry taskEntry) {
        if        (task.isDone()) {
            doneTaskList.getChildren().add(taskEntry.getEntryDisplay());

        } else if (date.before(today)) {
            overdueTaskList.getChildren().add(taskEntry.getEntryDisplay());

        } else {
            futureTaskList.getChildren().add(taskEntry.getEntryDisplay());
        }
    }

    // Iterates through the list of subcategories and find the corresponding
    // date of the task to go into. If it is unable to find one, it will add the
    // task into the 'Future' category instead.
    private void addUpcomingTask(Task task, Date startDate, String taskCount) {
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(today);
        calendar.add(Calendar.DATE, 1);

        Date deadline = calendar.getTime();

        switch (task.getType()) {

            case DEADLINE : {
                TaskEntry taskEntry = new TaskEntry(taskCount, task.getDescription(), timeFormatter.format(startDate), task.isDone());

                addThisUpcomingTaskToTaskList(startDate, calendar, deadline, taskEntry);
                break;
            }

            case EVENT : {
                Date endDate = ((Event) task).getEndDate();
                boolean isSameEndYear = isSameYear(endDate, today);

                String dateString = getDateFormatForEventThisWeek(startDate, endDate, isSameEndYear);
                TaskEntry taskEntry = new TaskEntry(taskCount, task.getDescription(), dateString, task.isDone());

                addThisUpcomingTaskToTaskList(startDate, calendar, deadline, taskEntry);
                break;
            }

            default:
                System.out.println(MESSAGE_UNABLE_TO_DETERMINE_TYPE);
                break;
        }
    }

    private void addThisUpcomingTaskToTaskList(Date startDate, Calendar calendar, Date deadline, TaskEntry taskEntry) {
        boolean isAdded = false;

        for (VBox vBox : upcomingSubcategories) {
            if (startDate.before(deadline)) {
                vBox.getChildren().add(taskEntry.getEntryDisplay());
                isAdded = true;
                break;

            } else {
                calendar.add(Calendar.DATE, 1);
                deadline = calendar.getTime();
            }
        }

        if (!isAdded) {
            futureTaskList.getChildren().add(taskEntry.getEntryDisplay());
        }
    }

    private String getDateFormatForEventWithSameStartYear(Date date, Date endDate, boolean isSameEndYear) {
        String dateString;

        if (isSameEndYear) {

            if (isSameDay(date, endDate)) {
                dateString = getDateFormatForEventWithSameYearAndInOneDay(date, endDate);
            } else {
                dateString = getDateFormatForEventWithSameYearAndDifferentDays(date, endDate);
            }

        } else {
            dateString = getDateFormatForEventWithDifferentYearAndDifferentDays(date, endDate);
        }

        return dateString;
    }

    private String getDateFormatForEventWithDifferentStartYear(Date date, Date endDate, boolean isSameEndYear) {
        String dateString;

        if (isSameEndYear && isSameDay(date, endDate)) {
            dateString = getDateFormatForEventWithDifferentYearButInOneDay(date, endDate);
        } else {
            dateString = getDateFormatForEventWithDifferentYearAndDifferentDays(date, endDate);
        }

        return dateString;
    }

    private String getDateFormatForEventThisWeek(Date startDate, Date endDate, boolean isSameEndYear) {
        String dateString;

        if (isSameEndYear) {

            if        (isSameDay(startDate, endDate)) {
                dateString = getDateFormatForUpcomingEventAndInOneDay(startDate, endDate);

            } else if (endDate.before(endOfWeek)) {
                dateString = getDateFormatForUpcomingEventButDifferentDays(startDate, endDate);

            } else {
                dateString = getDateFormatForUpcomingEventButDifferentWeek(startDate, endDate);
            }

        } else {
            dateString = getDateFormatForUpcomingEventButDifferentYear(startDate, endDate);
        }

        return dateString;
    }

    // ================================================================================
    // Task Display methods
    // ================================================================================

    /**
     * Updates the display using fade transitions. When the screen is first
     * initialised, all categories are faded in and shown. After the user
     * executes a command, empty categories are faded out and non-empty
     * categories are faded in.
     */
    protected void updateDisplay() {
        setMainVBoxBackgroundImage(mainVBox, FX_BACKGROUND_IMAGE_NULL);

        SequentialTransition sequentialTransition = new SequentialTransition();
        for (Node node : nodeList) {
            // Need to take care of special case with 'Upcoming' category
            if (node.equals(upcomingNode)) {
                ParallelTransition parallelTransition = new ParallelTransition();

                int totalUpcomingTasks = 0;
                for (int i = 0; i < upcomingSubcategories.size(); i++) {
                    totalUpcomingTasks += upcomingSubcategories.get(i).getChildren().size();
                    addOrRemoveUpcomingSubcategories(parallelTransition, i);
                }

                // Next, to settle the main parent node for all the subcategories
                addOrRemoveUpcomingNode(sequentialTransition, parallelTransition, totalUpcomingTasks);

            } else if (((VBox) node.lookup(SELECTOR_CATEGORY_VBOX)).getChildren().isEmpty()) {
                removeNodeIfEmptyAndInDisplay(sequentialTransition, node);
            } else {
                addNodeIfNotEmptyAndNotInDisplay(sequentialTransition, node);
            }
        }
        sequentialTransition.setOnFinished(checkEmpty -> setBackgroundImageIfMainVBoxIsEmpty(mainVBox));
        sequentialTransition.play();
    }

    /**
     * Determines the correct position for each node and adds it back.
     *
     * @param node    to be added
     */
    private void addNodeBackToScreen(Node node) {
        String nodeName = determineNodeName(node);

        switch (nodeName) {

            // This node is always at the top.
            case CATEGORY_OVERDUE : {
                mainVBox.getChildren().add(0, node);
                break;
            }

            // Check if the 'Overdue' node is on screen or not and adds this node after it.
            // Else this node would take precedence at the top.
            case CATEGORY_UPCOMING : {
                if (mainVBox.getChildren().contains(overdueNode)) {
                    mainVBox.getChildren().add(mainVBox.getChildren().indexOf(overdueNode) + 1, node);
                } else {
                    mainVBox.getChildren().add(0, node);
                }
                break;
            }

            // Check if 'Overdue' and 'This Week' nodes are added before. This node takes position after them.
            // Then check if either one is available. Else it will go to the top.
            case CATEGORY_FUTURE : {
                if        (mainVBox.getChildren().contains(overdueNode) && mainVBox.getChildren().contains(upcomingNode)) {
                    mainVBox.getChildren().add(mainVBox.getChildren().indexOf(upcomingNode) + 1, node);

                } else if (mainVBox.getChildren().contains(overdueNode) && !mainVBox.getChildren().contains(upcomingNode)) {
                    mainVBox.getChildren().add(mainVBox.getChildren().indexOf(overdueNode) + 1, node);

                } else if (mainVBox.getChildren().contains(upcomingNode)) {
                    mainVBox.getChildren().add(mainVBox.getChildren().indexOf(upcomingNode) + 1, node);

                } else {
                    mainVBox.getChildren().add(0, node);
                }
                break;
            }

            // Only needs to check if the only Node that can be lower than it (doneNode) is on the screen.
            case CATEGORY_DREAMS : {
                if (mainVBox.getChildren().contains(doneNode)) {
                    mainVBox.getChildren().add(mainVBox.getChildren().indexOf(doneNode), node);
                } else {
                    mainVBox.getChildren().add(node);
                }
                break;
            }

            // Takes position at the bottom of the list
            case CATEGORY_DONE : {
                mainVBox.getChildren().add(node);
                break;
            }

            default: {
                System.out.println(MESSAGE_UNABLE_TO_RECOGNISE_NODE);
                break;
            }
        }
    }

    private void addNodeIfNotEmptyAndNotInDisplay(SequentialTransition sequentialTransition, Node node) {
        if (!mainVBox.getChildren().contains(node)) {
            FadeTransition fadeIn = generateFadeInTransition(node, TIME_TRANSITION_CATEGORY_FADE_IN);

            addNodeBackToScreen(node);

            sequentialTransition.getChildren().add(fadeIn);
        }
    }

    private void addOrRemoveUpcomingNode(SequentialTransition sequentialTransition,
                                         ParallelTransition parallelTransition, int totalUpcomingTasks) {

        if (totalUpcomingTasks == 0 && mainVBox.getChildren().contains(upcomingNode)) {
            FadeTransition fadeOut = generateFadeOutTransition(upcomingNode, TIME_TRANSITION_CATEGORY_FADE_OUT);

            fadeOut.setOnFinished(done -> mainVBox.getChildren().remove(upcomingNode));

            sequentialTransition.getChildren().add(parallelTransition);
            sequentialTransition.getChildren().add(fadeOut);

        } else if (totalUpcomingTasks != 0 && !mainVBox.getChildren().contains(upcomingNode)) {
            FadeTransition fadeIn = generateFadeInTransition(upcomingNode, TIME_TRANSITION_CATEGORY_FADE_IN);

            addNodeBackToScreen(upcomingNode);

            sequentialTransition.getChildren().add(fadeIn);

        } else {
            sequentialTransition.getChildren().add(parallelTransition);
        }
    }

    private void addOrRemoveUpcomingSubcategories(ParallelTransition parallelTransition, int currSubcategoryIndex) {
        // 2 cases, either it has been faded in or not faded in previously.
        if (upcomingSubcategories.get(currSubcategoryIndex).getChildren().isEmpty()) {

            // If faded out previously/not faded in yet, just remove away from the view
            if (subcategoryVisibilityTracker[currSubcategoryIndex] == 0) {
                upcomingTaskList.getChildren().remove(upcomingSubcategories.get(currSubcategoryIndex).getParent());

            // If faded in, set it up to fade out since it has been emptied.
            } else {
                Node parentNode = upcomingSubcategories.get(currSubcategoryIndex).getParent();

                FadeTransition fadeOut = generateFadeOutTransition(parentNode, TIME_TRANSITION_SUBCATEGORY_FADE_OUT);
                fadeOut.setOnFinished(done -> upcomingTaskList.getChildren().remove(parentNode));

                parallelTransition.getChildren().add(fadeOut);
                subcategoryVisibilityTracker[currSubcategoryIndex] = 0;
            }

        // All non-empty and faded out should be faded back in.
        } else if (!(upcomingSubcategories.get(currSubcategoryIndex).getChildren().isEmpty()) &&
                    (subcategoryVisibilityTracker[currSubcategoryIndex] == 0)) {
            FadeTransition fadeIn = generateFadeInTransition(upcomingSubcategories.get(currSubcategoryIndex).getParent(),
                                                             TIME_TRANSITION_SUBCATEGORY_FADE_IN);
            parallelTransition.getChildren().add(fadeIn);
            subcategoryVisibilityTracker[currSubcategoryIndex] = 1;

        // Other cases can just ignore.
        } else {
        }
    }

    private void removeNodeIfEmptyAndInDisplay(SequentialTransition sequentialTransition, Node node) {
        if (mainVBox.getChildren().contains(node)) {
            FadeTransition fadeOut = generateFadeOutTransition(node, TIME_TRANSITION_CATEGORY_FADE_OUT);
            fadeOut.setOnFinished(done -> mainVBox.getChildren().remove(node));
            sequentialTransition.getChildren().add(fadeOut);
        }
    }

    // ================================================================================
    // TaskList Change Animation Methods
    // ================================================================================

    protected FadeTransition fadeOutDeletedTaskEntry(List<Task> taskList) {
        boolean isInitialised = initialisePrevTaskList(taskList);
        boolean isDelete = isTaskChangeDelete(taskList);

        if (isInitialised && isDelete) {
            int index = findIndexOfDeletedTask(taskList);
            return fadeOutDeletedTask(index);
        }

        return new FadeTransition();
    }

    protected void highlightAddedOrEditedTaskEntry(List<Task> taskList) {
        boolean isInitialised = initialisePrevTaskList(taskList);
        boolean isDelete = isTaskChangeDelete(taskList);

        if (isInitialised && !isDelete) {
            int index = findIndexOfAddedOrEditedTask(taskList);
            highlightTask(index);
        }
    }

    private FadeTransition fadeOutDeletedTask(int index) {
        int prevCount = 0;
        int currCount = 0;
        int indexOfTaskEntry = -1;

        for (Node node : nodeList) {
            // Need to check all the different nodes in order to get to the index
            if (node == upcomingNode) {
                prevCount = currCount;
                currCount = currCount + findNumberOfTasksInUpcomingSubcategories();

                if (currCount > index) {
                    indexOfTaskEntry = index - prevCount;
                    for (VBox vBox : upcomingSubcategories) {
                        // Check each subcategory until the index is found
                        if (indexOfTaskEntry < vBox.getChildren().size()) {
                            GridPane newTaskEntry = (GridPane) vBox.getChildren().get(indexOfTaskEntry);

                            return generateFadeOutTransition(newTaskEntry, TIME_TRANSITION_TASK_ENTRY_FADE_OUT);
                        }

                        indexOfTaskEntry -= vBox.getChildren().size();
                    }
                    break;
                }

            } else {
                prevCount = currCount;
                VBox currTaskList = ((VBox) node.lookup(SELECTOR_CATEGORY_VBOX));
                currCount = currCount + currTaskList.getChildren().size();

                if (currCount > index) {
                    indexOfTaskEntry = index - prevCount;

                    GridPane newTaskEntry = (GridPane) currTaskList.getChildren().get(indexOfTaskEntry);

                    return generateFadeOutTransition(newTaskEntry, TIME_TRANSITION_TASK_ENTRY_FADE_OUT);
                }
            }
        }
        return new FadeTransition();
    }

    private void highlightTask(int index) {
        if (index == -1) {
            return;
        }

        int prevCount = 0;
        int currCount = 0;
        int indexOfTaskEntry = -1;

        for (Node node : nodeList) {
            if (node == doneNode) {
                break;
            }

            if (node == upcomingNode) {
                prevCount = currCount;
                currCount = currCount + findNumberOfTasksInUpcomingSubcategories();

                if (currCount > index) {
                    indexOfTaskEntry = index - prevCount;
                    for (VBox vBox : upcomingSubcategories) {
                        // Check each subcategory until the index is found
                        if (indexOfTaskEntry < vBox.getChildren().size()) {
                            GridPane newTaskEntry = (GridPane) vBox.getChildren().get(indexOfTaskEntry);

                            Timeline highlightTimeline = generateHighlightTimeline(newTaskEntry);
                            highlightTimeline.play();
                            break;
                        }

                        indexOfTaskEntry -= vBox.getChildren().size();
                    }
                    break;
                }

            } else {
                prevCount = currCount;
                VBox currTaskList = ((VBox) node.lookup(SELECTOR_CATEGORY_VBOX));
                currCount = currCount + currTaskList.getChildren().size();

                if (currCount > index) {
                    indexOfTaskEntry = index - prevCount;

                    GridPane newTaskEntry = (GridPane) currTaskList.getChildren().get(indexOfTaskEntry);

                    Timeline highlightTimeline = generateHighlightTimeline(newTaskEntry);
                    highlightTimeline.play();
                    break;
                }
            }
        }
    }

```
###### procrastinate\ui\MultiCategoryScreen.java
``` java
    private int findIndexOfDeletedTask(List<Task> taskList) {
        Task prevTaskListTask;
        Task currTaskListTask;

        for (int i = 0; i < taskList.size(); i++) {
            currTaskListTask = taskList.get(i);
            prevTaskListTask = prevTaskList.get(i);

            // Check for the task at an index that differs between the
            // two task lists
            if (currTaskListTask.equals(prevTaskListTask) &&
                currTaskListTask.getId().equals(prevTaskListTask.getId())) {
                    continue;

            } else {
                return i;
            }
        }
        return taskList.size();
    }

    private int findIndexOfAddedOrEditedTask(List<Task> taskList) {
        List<Task> filteredTaskList = new ArrayList<>(taskList);

        // To retrieve the newly added/edited task, filter
        // the new task list to get the new task that has changed.
        for (Task task : prevTaskList) {
            filteredTaskList = filteredTaskList.stream()
                               .filter(filterTask -> (!filterTask.getId().equals(task.getId())))
                               .collect(Collectors.toList());
        }

        // To catch an edit that does not do any changes
        if (filteredTaskList.isEmpty()) {
            return -1;
        }

        Task newTask = filteredTaskList.get(0);
        for (int i = 0; i < taskList.size(); i++) {
            Task currTask = taskList.get(i);
            if (currTask.equals(newTask) && currTask.getId().equals(newTask.getId())) {
                return i;
            }
        }

        // Should be another 'show' command
        return -1;
    }

    private int findNumberOfTasksInUpcomingSubcategories() {
        int numTasks = 0;

        for (VBox vBox : upcomingSubcategories) {
            numTasks += vBox.getChildren().size();
        }

        return numTasks;
    }

    private boolean initialisePrevTaskList(List<Task> taskList) {
        if (prevTaskList == null) {
            prevTaskList = (ArrayList<Task>) taskList;
            return false;
        }
        return true;
    }

    private boolean isTaskChangeDelete(List<Task> taskList) {
        if (taskList.size() < prevTaskList.size()) {
            return true;
        } else {
            return false;
        }
    }

    // ================================================================================
    // Utility methods
    // ================================================================================

    private String determineNodeName(Node node) {
        if        (node.equals(overdueNode)) {
            return CATEGORY_OVERDUE;
        } else if (node.equals(upcomingNode)) {
            return CATEGORY_UPCOMING;
        } else if (node.equals(futureNode)) {
            return CATEGORY_FUTURE;
        } else {
            return CATEGORY_DREAMS;
        }
    }

    /**
     * Generates the relative date sub-headers for the 'Upcoming' category
     * and places them in the upcomingTaskList.
     */
    private void generateUpcomingSubcategories() {
        ArrayList<Node> thisWeekDateBoxes = new ArrayList<>();
        int count = 1;

        LocalDateTime startingDateTime = getDateTimeStartOfToday();
        while (!(getInstantFromLocalDateTime(startingDateTime)).equals(endOfWeek.toInstant())) {
            SubcategoryBox newDateBox;
            String shortDate = ", " + startingDateTime.format(DateTimeFormatter.ofPattern(dateFormatter.toPattern()));

            if        (count == 1) {
                newDateBox = new SubcategoryBox(SUBCATEGORY_TODAY + shortDate);
            } else if (count == 2) {
                newDateBox = new SubcategoryBox(SUBCATEGORY_TOMORROW + shortDate);
            } else {
                newDateBox = new SubcategoryBox(startingDateTime.getDayOfWeek()
                                                .getDisplayName(TextStyle.FULL, Locale.getDefault()) +
                                                shortDate);
            }

            VBox newDateVBox = newDateBox.getTaskListVBox();

            upcomingSubcategories.add(newDateVBox);
            thisWeekDateBoxes.add(newDateBox.getSubcategoryBox());

            startingDateTime = startingDateTime.plusDays(1);
            count++;
        }

        if (subcategoryVisibilityTracker == null || (subcategoryVisibilityTracker.length != thisWeekDateBoxes.size())) {
            subcategoryVisibilityTracker = new int[thisWeekDateBoxes.size()];
        }

        upcomingTaskList.getChildren().addAll(thisWeekDateBoxes);
    }

    private void resetTaskCount() {
        taskCount.set(0);
    }

    private void resetTaskList() {
        overdueTaskList.getChildren().clear();
        upcomingTaskList.getChildren().clear();
        futureTaskList.getChildren().clear();
        dreamsTaskList.getChildren().clear();
        doneTaskList.getChildren().clear();

        upcomingSubcategories.clear();
    }

    // ================================================================================
    // Init Methods
    // ================================================================================

    @Override
    protected void createCategories() {
        CategoryBox overdueBox = new CategoryBox(CATEGORY_OVERDUE);
        CategoryBox upcomingBox = new CategoryBox(CATEGORY_UPCOMING);
        CategoryBox futureBox = new CategoryBox(CATEGORY_FUTURE);
        CategoryBox dreamsBox = new CategoryBox(CATEGORY_DREAMS);
        CategoryBox doneBox = new CategoryBox(CATEGORY_DONE);

        this.overdueNode = overdueBox.getCategoryBox();
        this.overdueTaskList = overdueBox.getTaskListVBox();
        nodeList.add(overdueNode);

        this.upcomingNode = upcomingBox.getCategoryBox();
        this.upcomingTaskList = upcomingBox.getTaskListVBox();
        nodeList.add(upcomingNode);

        this.futureNode = futureBox.getCategoryBox();
        this.futureTaskList = futureBox.getTaskListVBox();
        nodeList.add(futureNode);

        this.dreamsNode = dreamsBox.getCategoryBox();
        this.dreamsTaskList = dreamsBox.getTaskListVBox();
        nodeList.add(dreamsNode);

        this.doneNode = doneBox.getCategoryBox();
        this.doneTaskList = doneBox.getTaskListVBox();
        nodeList.add(doneNode);
    }

    private void retrieveFxmlElements() {
        this.mainVBox = getMainVBox();
    }

    // ================================================================================
    // Getter Methods
    // ================================================================================

```
###### procrastinate\ui\SearchScreen.java
``` java
package procrastinate.ui;

import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.layout.VBox;

/**
 * <h1>SearchScreen is a subclass of MultiCategoryScreen and is used to show the search results
 * of a user's query.</h1>
 *
 * On top of the different categories present, it creates an additional Label that remains above
 * the categories to show the user's search query.
 */
public class SearchScreen extends MultiCategoryScreen {

    // ================================================================================
    // Message Strings
    // ================================================================================

    private static final String FX_BACKGROUND_IMAGE_NO_SEARCH_RESULTS = "-fx-background-image: url('/procrastinate/ui/images/no-search-results.png')";

    private static final String SEARCH_HEADER = "Search results for ";

    private static final String SELECTOR_PARENT_OF_MAIN_VBOX = "#scrollPane";

    private static final String STYLE_SEARCH_HEADER_FONT_FAMILY = "-fx-font-family: 'Helvetica Neue';";
    private static final String STYLE_SEARCH_HEADER_FONT_WEIGHT = "-fx-font-weight: bold;";
    private static final String STYLE_SEARCH_HEADER_FONT_SIZE = "-fx-font-size: 18px;";
    private static final String STYLE_SEARCH_HEADER_PADDING = "-fx-padding: 10 0 0 10;";

    private static final String STYLE_WRAPPER_BACKGROUND_COLOR = "-fx-background-color: white;";

    // ================================================================================
    // Constants
    // ================================================================================

    private static final int MAIN_VBOX_PREF_HEIGHT = 450;
    private static final int MAIN_VBOX_PREF_WIDTH = 450;

    // ================================================================================
    // Class Variables
    // ================================================================================

    private Label searchHeader_ = new Label();

    // ================================================================================
    // SearchScreen Constructor
    // ================================================================================

    protected SearchScreen() {
        super();
        adjustLabelStyle();
        wrapSearchHeaderLabelWithMainVBox();
    }

    // ================================================================================
    // SearchScreen Methods
    // ================================================================================

    @Override
    protected void setBackgroundImageIfMainVBoxIsEmpty(VBox mainVBox) {
        if (mainVBox.getChildren().isEmpty()) {
            mainVBox.setStyle(FX_BACKGROUND_IMAGE_NO_SEARCH_RESULTS);
        }
    }

    protected void updateSearchHeaderLabelText(String searchString) {
        searchHeader_.setText(SEARCH_HEADER + searchString.trim());
    }

    // ================================================================================
    // Init Methods
    // ================================================================================

    private void adjustLabelStyle() {
        searchHeader_.setWrapText(true);
        searchHeader_.setFocusTraversable(false);
        searchHeader_.setStyle(STYLE_SEARCH_HEADER_FONT_FAMILY +
                               STYLE_SEARCH_HEADER_FONT_WEIGHT +
                               STYLE_SEARCH_HEADER_FONT_SIZE +
                               STYLE_SEARCH_HEADER_PADDING);
    }

    /**
     * Wraps the searchHeader label with the current mainVBox within a new VBox to
     * maintain the current workings of the mainVBox.
     */
    private void wrapSearchHeaderLabelWithMainVBox() {
        ScrollPane parentOfMainVBox = (ScrollPane) this.getNode().lookup(SELECTOR_PARENT_OF_MAIN_VBOX);

        setMainVBoxSizeForWrapping();

        VBox wrapper = buildWrapper();
        parentOfMainVBox.setContent(wrapper);
    }

    private void setMainVBoxSizeForWrapping() {
        mainVBox.setPrefSize(MAIN_VBOX_PREF_WIDTH, MAIN_VBOX_PREF_HEIGHT);
    }

    private VBox buildWrapper() {
        VBox wrapper = new VBox(searchHeader_, mainVBox);

        wrapper.setStyle(STYLE_WRAPPER_BACKGROUND_COLOR);

        return wrapper;
    }

}
```
###### procrastinate\ui\SingleCategoryScreen.java
``` java
package procrastinate.ui;

import java.util.Date;

import javafx.animation.ParallelTransition;
import javafx.animation.SequentialTransition;
import javafx.scene.Node;
import javafx.scene.layout.VBox;

/**
 * <h1>A subclass of CenterScreen and contain only a single CategoryBox.</h1>
 *
 * The constructor takes in a string to be used as the text of the CategoryBox
 * header.
 */
public abstract class SingleCategoryScreen extends CenterScreen {

    // ================================================================================
    // Class Variables
    // ================================================================================

    protected Node thisCategoryNode;

    protected VBox thisCategoryTaskList;

    protected Date today;

    protected VBox mainVBox;

    private String headerName_;

    // ================================================================================
    // Animation Values
    // ================================================================================
    // Time values used are in milliseconds
    private static final int TIME_TRANSITION_FADE = 250;

    // ================================================================================
    // SingleCategoryScreen Constructor
    // ================================================================================

    protected SingleCategoryScreen(String headerName) {
        super();
        createCategories(headerName);
        retrieveFxmlElements();
    }

    // ================================================================================
    // Screen Transition Methods
    // ================================================================================

    @Override
    protected SequentialTransition getScreenSwitchOutSequence() {
        SequentialTransition switchOutTransition = new SequentialTransition();
        switchOutTransition.getChildren().add(generateFadeOutTransition(thisCategoryNode, TIME_TRANSITION_FADE));
        return switchOutTransition;
    }

    @Override
    protected ParallelTransition getScreenSwitchInSequence() {
        ParallelTransition switchInTransition = new ParallelTransition();
        switchInTransition.getChildren().add(generateFadeInTransition(thisCategoryNode, TIME_TRANSITION_FADE));
        return switchInTransition;
    }

    // ================================================================================
    // Init Methods
    // ================================================================================

    @Override
    protected void createCategories() {
        CategoryBox categoryBox = new CategoryBox(headerName_);

        this.thisCategoryNode = categoryBox.getCategoryBox();
        this.thisCategoryTaskList = categoryBox.getTaskListVBox();
    }

    private void createCategories(String headerName) {
        this.headerName_ = headerName;

        createCategories();
    }

    private void retrieveFxmlElements() {
        this.mainVBox = getMainVBox();
    }

    // ================================================================================
    // Utility Methods
    // ================================================================================

    /**
     * Used when updating the task list, removes all tasks and resets the task counter
     */
    protected void clearTaskList() {
        taskCount.set(0);

        mainVBox.getChildren().clear();
        thisCategoryTaskList.getChildren().clear();
    }

    protected void getUpdatedDates() {
        updateDates();

        today = getToday();
    }

    // ================================================================================
    // Getter Methods
    // ================================================================================

```
###### procrastinate\ui\SplashOverlay.java
``` java
package procrastinate.ui;

import javafx.geometry.Pos;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import javafx.scene.text.TextAlignment;

public class SplashOverlay extends ImageOverlay {

    // ================================================================================
    // Message Strings
    // ================================================================================

    private static final String ID_SUBTITLE_LABEL = "subtitleLabel";
    private static final String ID_TITLE_LABEL = "titleLabel";

    private static final String LOCATION_SPLASH_IMAGE = "images/icon.png";

    private static final String MESSAGE_SUBTITLE = "What would you like to Procrastinate today?";
    private static final String MESSAGE_WELCOME = "Welcome to Procrastinate!";

    // ================================================================================
    // Class Variables
    // ================================================================================

    private Label subtitleLabel_;
    private Label titleLabel_;

    // ================================================================================
    // SplashOverlay Constructor
    // ================================================================================

    protected SplashOverlay (){
        setImage();
        createLabels();
        setLabels();
        addLabels();
    }

    // ================================================================================
    // Init Methods
    // ================================================================================

    @Override
    protected void setImage() {
        imageView.setImage(new Image(ImageOverlay.class.getResource(LOCATION_SPLASH_IMAGE).toExternalForm()));
        imageView.fitWidthProperty().set(250);
    }

    private void createLabels() {
        titleLabel_ = new Label(MESSAGE_WELCOME);
        subtitleLabel_ = new Label(MESSAGE_SUBTITLE);
    }

    /**
     * Sets the alignment and positioning of the Labels to be placed under the icon image
     * used in the splash screen. Both labels also have their IDs updated for the CSS styling
     * to be applied.
     */
    private void setLabels() {
        titleLabel_.setAlignment(Pos.CENTER);
        titleLabel_.setTextAlignment(TextAlignment.CENTER);
        titleLabel_.setId(ID_TITLE_LABEL);

        subtitleLabel_.setId(ID_SUBTITLE_LABEL);

        VBox.setVgrow(titleLabel_, Priority.ALWAYS);
        VBox.setVgrow(subtitleLabel_, Priority.ALWAYS);
    }

    private void addLabels() {
        container.getChildren().addAll(titleLabel_, subtitleLabel_);
    }
}
```
###### procrastinate\ui\SubcategoryBox.java
``` java
package procrastinate.ui;

import java.io.IOException;

import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.VBox;

/**
 * <h1>Another VBox wrapper structure that is similar to CategoryBox.</h1>
 * It is mainly used as a child of CategoryBox to contain the TaskEntry instead.
 *
 * <p><b>Note:</b>
 * <br>It is used in the 'Upcoming' category of the MultiCategoryScreen to provide
 * subheaders.
 *
 * <br>The CSS style class for SubcategoryBox is 'subcategoryBox' and the styling
 * applied differentiates it from CategoryBox.
 */
public class SubcategoryBox extends VBox {

    // ================================================================================
    // Message strings
    // ================================================================================

    private static final String LOCATION_DATEBOX_FXML = "views/SubcategoryBox.fxml";

    // ================================================================================
    // Class variables
    // ================================================================================

    private Node subcategoryBox_;

    // ================================================================================
    // FXML field variables
    // ================================================================================

    @FXML
    private Label subcategoryLabel;
    @FXML
    private VBox subcategoryVBox;

    // ================================================================================
    // CategoryBox methods
    // ================================================================================

    /**
     * Creates a SubcategoryBox that encloses a Label as the header text and a VBox
     * to be used to contain the list of tasks.
     *
     * @param subcategoryHeader    to be used as the header text of the subcategory
     */
    protected SubcategoryBox(String subcategoryHeader) {
        loadLayout();
        setLabelText(subcategoryHeader);
    }

    // ================================================================================
    // Init Methods
    // ================================================================================

    private void loadLayout() {
        FXMLLoader loader = new FXMLLoader(getClass().getResource(LOCATION_DATEBOX_FXML));
        loader.setController(this); // Required due to different package
                                    // declaration from Main
        try {
            this.subcategoryBox_ = loader.load();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private void setLabelText(String subcategoryHeader) {
        this.subcategoryLabel.setText(subcategoryHeader);
    }

    // ================================================================================
    // Getter methods
    // ================================================================================

```
###### procrastinate\ui\SummaryScreen.java
``` java
package procrastinate.ui;

import java.util.Arrays;
import java.util.List;

import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import procrastinate.task.Task;

/**
 * <h1>SummaryScreen is a subclass of MultiCategoryScreen and is used to show an overview of
 * the pending tasks.</h1>
 *
 * It resizes all the pending tasks to fit into the screen without scrolling by removing
 * tasks from view and replacing them with ellipses.
 */
public class SummaryScreen extends MultiCategoryScreen {

    // ================================================================================
    // Message Strings
    // ================================================================================

    private static final String DESCRIPTION_ELLIPSIS_STRING = "...";

    private static final String ELLIPSIS_STRING = "... ";
    private static final String ELLIPSIS_MESSAGE_TASKS_HIDDEN = " tasks hidden ...";
    private static final String ELLIPSIS_MESSAGE_TASK_HIDDEN = " task hidden ...";

    private static final String FX_BACKGROUND_IMAGE_NO_TASKS = "-fx-background-image: url('/procrastinate/ui/images/no-summary.png')";

    private static final String SELECTOR_SCROLLPANE = "#scrollPane";

    // ================================================================================
    // Constants
    // ================================================================================

    private static final double SCROLLPANE_TOTAL_TOP_BOTTOM_PADDING = 20.0;

    private static final double MAINVBOX_CHILDREN_SPACING = 5.0;

    private static final int DESCRIPTION_MAX_LENGTH = 50;
    private static final int DESCRIPTION_ELLIPSIS_LENGTH = 3;

    private static final int PARTITION_COUNT_OVERDUE = 2;
    private static final int PARTITION_COUNT_UPCOMING = 3;
    private static final int PARTITION_COUNT_FUTURE = 1;
    private static final int PARTITION_COUNT_DREAMS = 1;

    private static final int TEST_ELLIPSIS_COUNT = 666;

    // ================================================================================
    // Class variables
    // ================================================================================

    private static double ellipsisBoxHeight_ = -1;

    private boolean isSummarising_ = false;

    // ================================================================================
    // SummaryScreen Constructor
    // ================================================================================

    protected SummaryScreen() {
        super();
    }

    // ================================================================================
    // SummaryScreen methods
    // ================================================================================

    @Override
    // Override to remove highlight/fade out animation and call summarising method
    protected void updateTaskList(List<Task> taskList) {
        getUpdatedDates();
        clearTaskList();

        for (Task task : taskList) {
            taskCount.set(taskCount.get() + 1);

            addTaskByType(task);
        }

        updateDisplay();
        setupSummaryView(taskList);
    }

```
###### procrastinate\ui\SummaryScreen.java
``` java
    @Override
    protected void setBackgroundImageIfMainVBoxIsEmpty(VBox mainVBox) {
        if (mainVBox.getChildren().isEmpty()) {
            mainVBox.setStyle(FX_BACKGROUND_IMAGE_NO_TASKS);
        }
    }

    /**
     * Resizes the current displayed task list to fit into screen without
     * scrolling by removing tasks from view and replacing them with ellipses.
     * The entire screen is partitioned depending on the number of categories
     * present and the ellipses shows the number of tasks hidden in each
     * category.
     */
```
###### procrastinate\ui\SummaryScreen.java
``` java
    private void resizeScreenToFit(double maxMainVBoxHeight) {
        int numCategoriesPresent = calculateNumberOfCategoriesPresent();
        int numPartitionsToSplit = calculateNumberOfPartitionsToSplit();

        double remainingHeightForTaskDisplay = maxMainVBoxHeight -
                                               SCROLLPANE_TOTAL_TOP_BOTTOM_PADDING -
                                               ((numCategoriesPresent - 1) * MAINVBOX_CHILDREN_SPACING);
        double rollOverHeight = 0;
        double singlePartitionHeight = remainingHeightForTaskDisplay / numPartitionsToSplit;

        DoubleNodePair[] allCategoryHeightNodePair = getHeightNodePairings();

        Arrays.sort(allCategoryHeightNodePair);

        for (DoubleNodePair currHeightNodePair : allCategoryHeightNodePair) {
            double currCategoryHeight = currHeightNodePair.getHeight();
            Node currCategoryNode = currHeightNodePair.getNode();

            if (currCategoryHeight == 0) {
                continue;
            }

            if        (currCategoryNode == overdueNode) {
                double maxOverdueCategoryHeight = (singlePartitionHeight * PARTITION_COUNT_OVERDUE) + rollOverHeight;

                rollOverHeight = getLeftoverHeightAfterResize(rollOverHeight, currCategoryHeight,
                                                              maxOverdueCategoryHeight, overdueNode);

            } else if (currCategoryNode == upcomingNode) {
                double maxUpcomingCategoryHeight = (singlePartitionHeight * PARTITION_COUNT_UPCOMING) + rollOverHeight;

                rollOverHeight = getLeftoverHeightAfterResize(rollOverHeight, currCategoryHeight,
                                                              maxUpcomingCategoryHeight, upcomingNode);

            } else if (currCategoryNode == futureNode) {
                double maxFutureCategoryHeight = (singlePartitionHeight * PARTITION_COUNT_FUTURE) + rollOverHeight;

                rollOverHeight = getLeftoverHeightAfterResize(rollOverHeight, currCategoryHeight,
                                                              maxFutureCategoryHeight, futureNode);

            } else if (currCategoryNode == dreamsNode) {
                double maxDreamsCategoryHeight = (singlePartitionHeight * PARTITION_COUNT_DREAMS) + rollOverHeight;

                rollOverHeight = getLeftoverHeightAfterResize(rollOverHeight, currCategoryHeight,
                                                              maxDreamsCategoryHeight, dreamsNode);

            } else {
                continue;
            }
        }
    }

    private DoubleNodePair[] getHeightNodePairings() {
        DoubleNodePair overdueCategoryHeightNodePair = new DoubleNodePair(getHeightOfCategoryNode(overdueNode), overdueNode);
        DoubleNodePair upcomingCategoryHeightNodePair = new DoubleNodePair(getHeightOfCategoryNode(upcomingNode), upcomingNode);
        DoubleNodePair futureCategoryHeightNodePair = new DoubleNodePair(getHeightOfCategoryNode(futureNode), futureNode);
        DoubleNodePair dreamsCategoryHeightNodePair = new DoubleNodePair(getHeightOfCategoryNode(dreamsNode), dreamsNode);
        DoubleNodePair[] allCategoryHeightNodePair = { overdueCategoryHeightNodePair, upcomingCategoryHeightNodePair,
                                                       futureCategoryHeightNodePair, dreamsCategoryHeightNodePair };
        return allCategoryHeightNodePair;
    }

    /**
     * Checks if the current category height exceeds the allocated maximum height and resizes it to fit.
     * It also retrieves the remaining height of each category and returns it as rollOverHeight for other
     * categories to use.
     *
     * @param rollOverHeight        to be updated after each category is resized
     * @param currCategoryHeight    height of the currCategoryNode
     * @param maxCategoryHeight     max height of the currCategoryNode
     * @param currCategoryNode      node to be checked against upcomingNode which is resized differently.
     * @return                      updated rollOverHeight
     */
    private double getLeftoverHeightAfterResize(double rollOverHeight, double currCategoryHeight,
                                                double maxCategoryHeight, Node currCategoryNode) {

        rollOverHeight = 0;
        if        ((currCategoryHeight > maxCategoryHeight) && (currCategoryNode != upcomingNode)) {
            resizeTaskListOfOtherCategoriesToFit(currCategoryNode, maxCategoryHeight);
            rollOverHeight += (maxCategoryHeight - getHeightOfCategoryNode(currCategoryNode));

        } else if ((currCategoryHeight > maxCategoryHeight) && (currCategoryNode == upcomingNode)) {
            resizeTaskListOfUpcomingCategoryToFit(currCategoryNode, maxCategoryHeight);
            rollOverHeight += (maxCategoryHeight - getHeightOfCategoryNode(currCategoryNode));

        } else {
            rollOverHeight += maxCategoryHeight - currCategoryHeight;
        }

        return rollOverHeight;
    }


    // Resizes the upcomingNode if it exceeds the given heightToFit by removing tasks from its
    // subcategories, starting from the last subcategory and removing the SubcategoryBox from
    // view when there are no more tasks contained within.
    private void resizeTaskListOfUpcomingCategoryToFit(Node upcomingNode, double heightToFit) {
        if (ellipsisBoxHeight_ == -1) {
            updateEllipsisBoxHeight(upcomingNode);
        }
        assert(ellipsisBoxHeight_ != -1);

        int numTasksRemoved = 0;
        int totalSubcategoryCount = upcomingSubcategories.size() - 1;

        for (int i = totalSubcategoryCount; i >= 0; i--) {
            VBox currSubcategory = upcomingSubcategories.get(i);
            if (currSubcategory.getChildren().isEmpty()) {
                continue;
            }

            while (!currSubcategory.getChildren().isEmpty() &&
                   (getHeightOfCategoryNode(upcomingNode) > (heightToFit - ellipsisBoxHeight_))) {
                currSubcategory.getChildren().remove(currSubcategory.getChildren().size() - 1);
                numTasksRemoved++;
                mainVBox.getParent().layout();
            }

            if (currSubcategory.getChildren().isEmpty()) {
                upcomingTaskList.getChildren().remove(upcomingTaskList.getChildren().size() - 1);
            }

            if (getHeightOfCategoryNode(upcomingNode) < (heightToFit - ellipsisBoxHeight_)) {
                break;
            }
        }

        if (numTasksRemoved != 0) {
            upcomingTaskList.getChildren().add(getEllipsis(numTasksRemoved));
            upcomingTaskList.applyCss();
            upcomingTaskList.layout();

            mainVBox.getParent().layout();
        }
    }

    // Resizes the given categoryNode by removing tasks from the category if it exceeds the given heightToFit.
    private void resizeTaskListOfOtherCategoriesToFit(Node categoryNode, double heightToFit) {
        int numTasksRemoved = 0;
        if (ellipsisBoxHeight_ == -1) {
            updateEllipsisBoxHeight(categoryNode);
        }
        assert(ellipsisBoxHeight_ != -1);

        VBox currCategoryTaskList = getCategoryTaskList(categoryNode);
        while (getHeightOfCategoryNode(categoryNode) > (heightToFit - ellipsisBoxHeight_)) {
            currCategoryTaskList.getChildren().remove(currCategoryTaskList.getChildren().size() - 1);
            numTasksRemoved++;
            mainVBox.getParent().layout();
        }

        if (numTasksRemoved != 0) {
            currCategoryTaskList.getChildren().add(getEllipsis(numTasksRemoved));
            currCategoryTaskList.applyCss();
            currCategoryTaskList.layout();

            mainVBox.getParent().layout();
        }
    }

    /**
     * Used to check the height of the ellipsis added which may differ from user
     * to user depending on hardware specifications.
     *
     * @param categoryNode    any Node of a category that is not empty in order to calculate
     *                        the height difference when an ellipsis is added.
     */
    private void updateEllipsisBoxHeight(Node categoryNode) {
        double currHeight = getHeightOfCategoryNode(categoryNode);

        VBox currCategoryTaskList = getCategoryTaskList(categoryNode);
        currCategoryTaskList.getChildren().add(getEllipsis(TEST_ELLIPSIS_COUNT));
        currCategoryTaskList.applyCss();
        currCategoryTaskList.layout();

        mainVBox.getParent().layout();

        currCategoryTaskList.getChildren().remove(currCategoryTaskList.getChildren().size() - 1);

        double newHeight = getHeightOfCategoryNode(categoryNode);
        ellipsisBoxHeight_ = newHeight - currHeight;
    }

    private VBox getCategoryTaskList(Node categoryNode) {
        return ((VBox) categoryNode.lookup(SELECTOR_CATEGORY_VBOX));
    }

    private int calculateNumberOfPartitionsToSplit() {
        int numPartitions = 0;

        if (getHeightOfCategoryNode(overdueNode) != 0) {
            numPartitions += PARTITION_COUNT_OVERDUE;
        }

        if (getHeightOfCategoryNode(upcomingNode) != 0) {
            numPartitions += PARTITION_COUNT_UPCOMING;
        }

        if (getHeightOfCategoryNode(futureNode) != 0) {
            numPartitions += PARTITION_COUNT_FUTURE;
        }

        if (getHeightOfCategoryNode(dreamsNode) != 0) {
            numPartitions += PARTITION_COUNT_DREAMS;
        }

        return numPartitions;
    }

    private int calculateNumberOfCategoriesPresent() {
        int numCategories = 0;

        for (Node node : nodeList) {
            if (((VBox) node).getHeight() != 0) {
                numCategories++;
            }
        }

        return numCategories;
    }

    /**
     * Update the mainVBox and allows calculation of it's height after applying
     * the CSS styling and layout.
     *
     * @return    updated height of the mainVBox
     */
    private double getCurrentMainVBoxHeight() {
        mainVBox.getParent().applyCss();
        mainVBox.getParent().layout();
        return mainVBox.getHeight();
    }

    private double getHeightOfCategoryNode(Node categoryNode) {
        return ((VBox) categoryNode).getHeight();
    }

    private HBox getEllipsis(int numTaskLeft) {
        String message = ELLIPSIS_STRING + numTaskLeft;

        if (numTaskLeft > 1) {
            message += ELLIPSIS_MESSAGE_TASKS_HIDDEN;
        } else {
            message += ELLIPSIS_MESSAGE_TASK_HIDDEN;
        }

        Label ellipsisMessage = new Label(message);

        HBox ellipsisBox = new HBox(ellipsisMessage);
        ellipsisBox.setAlignment(Pos.CENTER);

        return ellipsisBox;
    }

```
###### procrastinate\ui\TaskEntry.java
``` java
package procrastinate.ui;

import java.io.IOException;

import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;

/**
 * <h1>A GridPane wrapper structure used to display the different Tasks.</h1>
 *
 * It is laid out in 3 columns and displays the information of the Task
 * in the order of:
 * <li>Line Number,
 * <li>Task Description
 * <li>Date/Time String
 * <br>
 * Text wrapping also is enabled for long task descriptions while the date/time strings
 * are to be properly formatted before being passed in.
 *
 * <p><b>Note:</b>
 * A tick will be displayed for Tasks that are marked as done and will be placed beside
 * the line number of the Task displayed.
 */
public class TaskEntry extends GridPane {

    // ================================================================================
    // Message Strings
    // ================================================================================

    private static final String EMPTY_STRING = "";

    private static final String LOCATION_TASK_ENTRY_FXML = "views/TaskEntry.fxml";
    private static final String LOCATION_TICK_IMAGE = "images/tick.png";

    private static final String STYLE_TICK_CENTERING_PADDING = "-fx-padding: 4 5 0 0;";
    private static final String STYLE_REMOVE_PADDING = "-fx-padding: 0;";

    // ================================================================================
    // Constants
    // ================================================================================

    private static final int GRIDPANE_LINE_NUMBER_ROW_INDEX = 0;
    private static final int GRIDPANE_LINE_NUMBER_COLUMN_INDEX = 0;
    private static final int GRIDPANE_LINE_NUMBER_POSITION = 0;

    private static final int STYLE_TICK_WIDTH = 10;
    private static final int STYLE_TICK_HEIGHT = 10;
    private static final int STYLE_NO_SPACING = 0;

    // ================================================================================
    // Class Variables
    // ================================================================================

    private Node taskEntry_;

    // ================================================================================
    // FXML Field Variables
    // ================================================================================

    @FXML
    private Label lineNum;
    @FXML
    private Label description;
    @FXML
    private Label time;

    // ================================================================================
    // TaskEntry Constructor
    // ================================================================================

    /**
     * Constructor to be used for displaying "DREAMS"
     *
     * @param lineNum        formatted line numbering of the corresponding task
     * @param description    the entire task description
     * @param isDone         if true, a tick will be displayed beside the line number
     */
    protected TaskEntry(String lineNum, String description, boolean isDone) {
        loadLayout();
        if (isDone) {
            addTickBeforeLineNumber();
        }
        setLabels(lineNum, description, EMPTY_STRING);
    }

    /**
     * Constructor to be used for displaying all other TaskTypes
     *
     * @param lineNum        formatted line numbering of the corresponding task
     * @param description    the entire task description
     * @param time           formatted string to be displayed in the 'time' Label
     * @param isDone         if true, a tick will be displayed beside the line number
     */
    protected TaskEntry(String lineNum, String description, String time, boolean isDone) {
        loadLayout();
        if (isDone) {
            addTickBeforeLineNumber();
        }
        setLabels(lineNum, description, time);
    }

    // ================================================================================
    // Init Methods
    // ================================================================================

    private void loadLayout() {
        FXMLLoader loader = new FXMLLoader(getClass().getResource(LOCATION_TASK_ENTRY_FXML));
        loader.setController(this); // Required due to different package
                                    // declaration from Main
        try {
            this.taskEntry_ = loader.load();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private void setLabels(String lineNum, String description, String time) {
        this.lineNum.setText(lineNum);
        this.description.setText(description);
        this.time.setText(time);

        if (time.equals(EMPTY_STRING)) {
            this.time.setMinWidth(0);
            this.time.setStyle(STYLE_REMOVE_PADDING);
        }
    }

    /**
     * Two HBoxes are created as wrapper for the line number and tick image individually,
     * before they are wrapped again in another HBox to replace the current line number Label
     * in the taskEntry.
     */
    private void addTickBeforeLineNumber() {
        HBox lineNumberWrapper = getLabelWrapper();
        HBox tickWrapper = getTickWrapper();

        addTickAndLabelToTaskEntry(lineNumberWrapper, tickWrapper);
    }

    private HBox getLabelWrapper() {
        Label lineNumberLabel = getLabelAndRemovePadding();
        return wrapLabel(lineNumberLabel);
    }

    private HBox getTickWrapper() {
        ImageView tick = getTick();
        return wrapTick(tick);
    }

    private Label getLabelAndRemovePadding() {
        Label lineNumberLabel = (Label) ((GridPane) taskEntry_).getChildren().get(GRIDPANE_LINE_NUMBER_POSITION);
        lineNumberLabel.setStyle(STYLE_REMOVE_PADDING);

        return lineNumberLabel;
    }

    private void addTickAndLabelToTaskEntry(HBox lineNumberWrapper, HBox checkBoxWrapper) {
        HBox combinedWrapper = new HBox(checkBoxWrapper, lineNumberWrapper);
        ((GridPane) taskEntry_).add(combinedWrapper, GRIDPANE_LINE_NUMBER_COLUMN_INDEX, GRIDPANE_LINE_NUMBER_ROW_INDEX);
    }

    private HBox wrapTick(ImageView tick) {
        HBox tickWrapper = new HBox(tick);

        tickWrapper.setSpacing(STYLE_NO_SPACING);
        tickWrapper.setStyle(STYLE_TICK_CENTERING_PADDING);

        return tickWrapper;
    }

    private ImageView getTick() {
        ImageView tickImage = new ImageView();

        setTickImage(tickImage);

        return tickImage;
    }

    private void setTickImage(ImageView tickImage) {
        tickImage.setImage(new Image(TaskEntry.class.getResource(LOCATION_TICK_IMAGE).toExternalForm()));
        tickImage.setFocusTraversable(false);
        tickImage.setSmooth(true);
        tickImage.setFitHeight(STYLE_TICK_HEIGHT);
        tickImage.setFitWidth(STYLE_TICK_WIDTH);
    }


    private HBox wrapLabel(Label lineNumberLabel) {
        HBox lineNumberWrapper = new HBox(lineNumberLabel);
        lineNumberWrapper.setSpacing(STYLE_NO_SPACING);

        return lineNumberWrapper;
    }

    // ================================================================================
    // Getter Methods
    // ================================================================================
```
###### procrastinate\ui\UI.java
``` java
package procrastinate.ui;

import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.sun.javafx.tk.Toolkit;

import javafx.application.Platform;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import javafx.beans.value.ChangeListener;
import javafx.event.EventHandler;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyEvent;
import javafx.stage.Stage;
import procrastinate.task.Task;

/**
 * <h1>The main class of the UI component.</h1>
 * It instantiates all the other UI components required and provides
 * handle methods for the Logic component to call upon.
 */
public class UI {

    public static enum ScreenView {
        SCREEN_DONE, SCREEN_MAIN, SCREEN_MAIN_ALL, SCREEN_SEARCH, SCREEN_SUMMARY
    }

    private static final Logger logger = Logger.getLogger(UI.class.getName());

    private static boolean showTray_ = true;

    // ================================================================================
    // Message Strings
    // ================================================================================

    private static final String DEBUG_UI_INIT = "UI initialised.";
    private static final String DEBUG_UI_LOAD = "View is now loaded!";

    private static final String ELLIPSIS = "...";

    // ================================================================================
    // Class Variables
    // ================================================================================

    private Stage primaryStage_;

    private CenterPaneController centerPaneController_;

    private DialogPopupHandler dialogPopupHandler_;

    private WindowHandler windowHandler_;

    private BooleanProperty isExit_ = new SimpleBooleanProperty(false);

    private StringProperty userInput_ = new SimpleStringProperty();
    private StringProperty statusLabelText_ = new SimpleStringProperty();

    // ================================================================================
    // UI Methods
    // ================================================================================

    protected UI() {
    }

    public UI(Stage stage) {
        assert(stage != null);
        primaryStage_ = stage;

        initWindow();
        initDialogPopupHandler();
        initTaskDisplay();
        setupBinding();
        setupAndShowStage();

        logger.log(Level.INFO, DEBUG_UI_INIT);
    }

    // Retrieves the current user input from the TextField.
    public String getInput() {
        return userInput_.get();
    }

    public void setInput(String input) {
        userInput_.set(input);
        getUserInputField().end();
    }

    public void clearInput() {
        getUserInputField().clear();
    }

```
###### procrastinate\ui\UI.java
``` java
    public void updateTaskList(List<Task> taskList, ScreenView screenView) {
        centerPaneController_.updateScreen(taskList, screenView);
    }

    public void resetIsExit() {
        isExit_.set(false);
    }

    public void attachHandlersAndListeners(EventHandler<KeyEvent> keyPressHandler,
                                           ChangeListener<String> userInputListener,
                                           ChangeListener<Boolean> isExitListener) {
        TextField userInputField = getUserInputField();
        userInputField.setOnKeyPressed(keyPressHandler);
        userInputField.textProperty().addListener(userInputListener);

        isExit_.addListener(isExitListener);
    }

    public void hide() {
        Platform.runLater(() -> primaryStage_.hide());
    }

    // ================================================================================
    // CenterPaneController Methods
    // ================================================================================

    public void passSearchStringToSearchScreen(String searchString) {
        centerPaneController_.receiveSearchStringAndPassToSearchScreen(searchString);
    }

    public void showHelpOverlay() {
        centerPaneController_.showHelpOverlay();
    }

    public void nextHelpPage() {
        centerPaneController_.showNextHelpPage();
    }

    private void showSplashOverlay() {
        centerPaneController_.showSplashOverlay();
    }

    public void hideHelpOverlay() {
        centerPaneController_.hideHelpOverlay();
    }

    public void hideSplashOverlay() {
        centerPaneController_.hideSplashOverlay();
    }

    public void scrollUpScreen() {
        centerPaneController_.scrollUpCurrentScreen();
    }

    public void scrollDownScreen() {
        centerPaneController_.scrollDownCurrentScreen();
    }

    // ================================================================================
    // DialogPopupHandler Methods
    // ================================================================================

    public void createErrorDialog(String header, String message) {
        dialogPopupHandler_.createErrorDialogPopup(header, message);
    }

    public void createErrorDialogWithTrace(Exception e) {
        dialogPopupHandler_.createErrorDialogPopupWithTrace(e);
    }

```
###### procrastinate\ui\UI.java
``` java
    private void initWindow() {
        windowHandler_ = new WindowHandler(primaryStage_);
        windowHandler_.loadWindowConfigurations(showTray_);
    }

    private void initDialogPopupHandler() {
        dialogPopupHandler_ = new DialogPopupHandler(primaryStage_);
    }

    private void initTaskDisplay() {
        this.centerPaneController_ = new CenterPaneController(windowHandler_.getCenterScreen());
    }

    private void setupBinding() {
        assert(windowHandler_ != null);
        windowHandler_.bindAsExitIndicator(isExit_);

        userInput_.bindBidirectional(windowHandler_.getUserInputField().textProperty());
        statusLabelText_.bindBidirectional(windowHandler_.getStatusLabel().textProperty());
    }

    private void setupAndShowStage() {
        assert(primaryStage_ != null);

        primaryStage_.show();
        showSplashOverlay();

        logger.log(Level.INFO, DEBUG_UI_LOAD);
    }

    // ================================================================================
    // Utility Methods
    // ================================================================================

    private TextField getUserInputField() {
        return windowHandler_.getUserInputField();
    }

```
###### procrastinate\ui\UITestHelper.java
``` java
package procrastinate.ui;

import java.util.List;

import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.image.ImageView;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import procrastinate.task.Task;
import procrastinate.ui.UI.ScreenView;

public class UITestHelper {

    // Some test variables that are utilised multiple times in a test body
    public CenterPaneController centerPaneController;

    // ================================================================================
    // CenterPaneController methods
    // ================================================================================

    public CenterPaneController getNewCenterPaneController(StackPane stackPane) {
        centerPaneController = new CenterPaneController(stackPane);
        return centerPaneController;
    }

    public CenterScreen getCPCCurrentScreen() {
        return centerPaneController.getCurrentScreen();
    }

    public Node getCPCCurrentScreenNode() {
        return centerPaneController.getCurrentScreen().getNode();
    }

    public ImageOverlay getCPCCurrentOverlay() {
        return centerPaneController.getCurrentOverlay();
    }

    public Node getCPCCurrentOverlayNode() {
        return centerPaneController.getCurrentOverlay().getNode();
    }

    public void changeCPCScreen(List<Task> taskList, ScreenView screenView) {
        centerPaneController.updateScreen(taskList, screenView);
    }

    public Node getDoneScreenNode() {
        return centerPaneController.getDoneScreenNode();
    }

    public Node getMainScreenNode() {
        return centerPaneController.getMainScreenNode();
    }

    public Node getSearchScreenNode() {
        return centerPaneController.getSearchScreenNode();
    }

    public Node getSummaryScreenNode() {
        return centerPaneController.getSummaryScreenNode();
    }

    public Node getHelpOverlayNode() {
        return centerPaneController.getHelpOverlayNode();
    }

    public Node getSplashOverlayNode() {
        return centerPaneController.getSplashOverlayNode();
    }

    public void showSplash() {
        centerPaneController.showSplashOverlay();
    }

    public void hideSplash() {
        centerPaneController.hideSplashOverlay();
    }

    public void showHelp() {
        centerPaneController.showHelpOverlay();
    }

    public void hideHelp() {
        centerPaneController.hideHelpOverlay();
    }

    // ================================================================================
    // CenterScreen methods
    // ================================================================================

    public Node getCenterScreenNode(CenterScreen centerScreen) {
        return centerScreen.getNode();
    }

    public VBox getCenterScreenVBox(CenterScreen centerScreen) {
        return centerScreen.getMainVBox();
    }

    public void updateScreenTaskList(CenterScreen centerScreen, List<Task> taskList) {
        centerScreen.updateTaskList(taskList);
    }

    // ================================================================================
    // MultiCategoryScreen methods
    // ================================================================================

    public MultiCategoryScreen getNewMainScreen() {
        return new MainScreen();
    }

    public MultiCategoryScreen getNewSearchScreen() {
        return new SearchScreen();
    }

    public MultiCategoryScreen getNewSummaryScreen() {
        return new SummaryScreen();
    }

    public Node getOverdueNode(MultiCategoryScreen multiCategoryScreen) {
        return multiCategoryScreen.getOverdueNode();
    }

    public Node getUpcomingNode(MultiCategoryScreen multiCategoryScreen) {
        return multiCategoryScreen.getUpcomingNode();
    }

    public Node getFutureNode(MultiCategoryScreen multiCategoryScreen) {
        return multiCategoryScreen.getFutureNode();
    }

    public Node getDreamsNode(MultiCategoryScreen multiCategoryScreen) {
        return multiCategoryScreen.getDreamsNode();
    }

    public Node getDoneNode(MultiCategoryScreen multiCategoryScreen) {
        return multiCategoryScreen.getDoneNode();
    }

    public VBox getOverdueTaskList(MultiCategoryScreen multiCategoryScreen) {
        return multiCategoryScreen.getOverdueTaskList();
    }

    public VBox getUpcomingTaskList(MultiCategoryScreen multiCategoryScreen) {
        return multiCategoryScreen.getUpcomingTaskList();
    }

    public VBox getFutureTaskList(MultiCategoryScreen multiCategoryScreen) {
        return multiCategoryScreen.getFutureTaskList();
    }

    public VBox getDreamsTaskList(MultiCategoryScreen multiCategoryScreen) {
        return multiCategoryScreen.getDreamsTaskList();
    }

    public VBox getDoneTaskList(MultiCategoryScreen multiCategoryScreen) {
        return multiCategoryScreen.getDoneTaskList();
    }

    // ================================================================================
    // SingleCategoryScreen methods
    // ================================================================================

    public SingleCategoryScreen getNewDoneScreen() {
        return new DoneScreen();
    }

    public Node getSingleCategoryNode(SingleCategoryScreen singleCategoryScreen) {
        return singleCategoryScreen.getCategoryNode();
    }

    public VBox getSingleCategoryTaskList(SingleCategoryScreen singleCategoryScreen) {
        return singleCategoryScreen.getCategoryTaskList();
    }

    // ================================================================================
    // ImageOverlay methods
    // ================================================================================

    public ImageOverlay getNewHelpOverlay() {
        return new HelpOverlay();
    }

    public void switchHelpOverlayPage(HelpOverlay helpOverlay) {
        helpOverlay.nextPage();
    }

    public ImageOverlay getNewSplashOverlay() {
        return new SplashOverlay();
    }

    public ImageView getOverlayImageView(ImageOverlay imageOverlay) {
        return imageOverlay.getImageView();
    }

    public VBox getOverlayContainer(ImageOverlay imageOverlay) {
        return imageOverlay.getContainer();
    }

    // ================================================================================
    // CategoryBox methods
    // ================================================================================

    public CategoryBox getNewCategoryBox(String headerText) {
        return new CategoryBox(headerText);
    }

    public VBox getCategoryBoxVBox(CategoryBox categoryBox) {
        return categoryBox.getTaskListVBox();
    }

    public Label getCategoryBoxLabel(CategoryBox categoryBox) {
        return categoryBox.getCategoryLabel();
    }

    // ================================================================================
    // SubcategoryBox methods
    // ================================================================================

    public SubcategoryBox getNewSubcategoryBox(String headerText) {
        return new SubcategoryBox(headerText);
    }

    public VBox getSubcategoryBoxVBox(SubcategoryBox subcategoryBox) {
        return subcategoryBox.getTaskListVBox();
    }

    public Label getSubcategoryBoxLabel(SubcategoryBox subcategoryBox) {
        return subcategoryBox.getSubcategoryLabel();
    }

    // ================================================================================
    // TaskEntry methods
    // ================================================================================

    public TaskEntry getNewDreamTaskEntry(String lineNum, String des) {
        return new TaskEntry(lineNum, des, false);
    }

    public TaskEntry getNewOthersTaskEntry(String lineNum, String des, String time) {
        return new TaskEntry(lineNum, des, time, false);
    }

    public TaskEntry getNewDoneTaskEntry(String lineNum, String des, String time) {
        return new TaskEntry(lineNum, des, time, true);
    }

    public Label getTaskEntryLineNum(TaskEntry taskEntry) {
        return taskEntry.getLineNum();
    }

    public Label getTaskEntryDescription(TaskEntry taskEntry) {
        return taskEntry.getDescription();
    }

    public Label getTaskEntryTime(TaskEntry taskEntry) {
        return taskEntry.getTime();
    }

    public Node getTaskEntryNode(TaskEntry taskEntry) {
        return taskEntry.getEntryDisplay();
    }
}
```
###### procrastinate\ui\views\CategoryBox.fxml
``` fxml
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.VBox?>

<VBox maxHeight="1.7976931348623157E308" minHeight="-Infinity" styleClass="categoryBox" xmlns="http://javafx.com/javafx/8.0.40" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <Label fx:id="categoryLabel" text="Label" VBox.vgrow="ALWAYS" />
      <VBox fx:id="categoryVBox" maxHeight="1.7976931348623157E308" minHeight="-Infinity" VBox.vgrow="ALWAYS" />
   </children>
</VBox>
```
###### procrastinate\ui\views\CenterScreen.fxml
``` fxml
<?import javafx.scene.control.ScrollPane?>
<?import javafx.scene.layout.VBox?>

<ScrollPane fx:id="scrollPane" fitToHeight="true" fitToWidth="true" focusTraversable="false" hbarPolicy="NEVER" style="-fx-background-color:white;" vbarPolicy="NEVER" xmlns="http://javafx.com/javafx/8.0.40" xmlns:fx="http://javafx.com/fxml/1">
	<content>
		<VBox fx:id="mainVBox" styleClass="centerScreen">
		</VBox>
	</content>
</ScrollPane>
```
###### procrastinate\ui\views\ImageOverlay.fxml
``` fxml
<?import javafx.scene.image.ImageView?>
<?import javafx.scene.layout.Region?>
<?import javafx.scene.layout.StackPane?>
<?import javafx.scene.layout.VBox?>

<StackPane styleClass="imageOverlay" xmlns="http://javafx.com/javafx/8.0.40" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <Region fx:id="overlay" />
      <VBox fx:id="container" >
          <children>
            <ImageView fx:id="imageView" nodeOrientation="INHERIT" pickOnBounds="true" preserveRatio="true" VBox.vgrow="ALWAYS" />
          </children>
      </VBox>
   </children>
</StackPane>
```
###### procrastinate\ui\views\MainWindowLayout.fxml
``` fxml
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.layout.StackPane?>
<?import javafx.scene.layout.VBox?>

<BorderPane fx:id="mainBorderPane" prefHeight="600.0" prefWidth="500.0" styleClass="mainWindow" xmlns="http://javafx.com/javafx/8.0.40" xmlns:fx="http://javafx.com/fxml/1">
    <bottom>
        <VBox fx:id="bottom" BorderPane.alignment="CENTER">
            <children>
                <TextField fx:id="userInputField" />
                <Label fx:id="statusLabel" />
            </children>
        </VBox>
    </bottom>
    <center>
          <StackPane fx:id="centerScreen">
                </StackPane>
    </center>
</BorderPane>
```
###### procrastinate\ui\views\procrastinate.css
``` css
/*
 * ================================================================
 * Font Declarations
 * ================================================================
 */
@font-face {
	font-family: "Helvetica Neue";
	font-style: bold;
	src: url("/procrastinate/ui/fonts/helvetica-neue-bold.ttf");
}

@font-face {
	font-family: Titillium;
	font-style: normal;
	src: url("/procrastinate/ui/fonts/titillium/Titillium-Regular.otf");
}

@font-face {
	font-family: FontAwesome;
	font-weight: 400;
	font-style: normal;
	src: url("/procrastinate/ui/fonts/FontAwesome.otf");
}

/*
 * ================================================================
 * MainWindow Styling
 * ================================================================
 */
.root {
}

.mainWindow {
    -fx-background-color: transparent;
    -fx-focus-color: #365fac;
    -fx-accent: #365fac;
}

.mainWindow #mainBorderPane {
  -fx-effect: dropshadow( gaussian, derive(lightslategray, -20%), 10, 0, 3, 3);
  -fx-alignment: center;
  -fx-border-color: white;
  -fx-border-width: 5;
  -fx-border-insets: 10;
  -fx-border-radius: 6;
}

.mainWindow #bottom {
    -fx-font-family: Titillium;
    -fx-background-color: white;
    -fx-padding: 2 10 2 10;
    -fx-spacing: 2;
}

.mainWindow #userInputField {
    -fx-font-size: 18px;
    -fx-text-fill: #314976;
}

.mainWindow #statusLabel {
    -fx-font-size: 16px;
}

.mainWindow #top {
    -fx-background-color: white;
}

/*
 * ================================================================
 * ImageOverlay Styling
 * ================================================================
 */
.imageOverlay #container {
    -fx-alignment: center;
    -fx-padding: 10 0 0 0;
    -fx-spacing: 10;
}

.imageOverlay #overlay {
    -fx-background-color: white;
    -fx-opacity: 0.8;
}

.imageOverlay #titleLabel {
    -fx-font-family: "Helvetica Neue";
    -fx-font-weight: bold;
    -fx-font-size: 24px;
}

.imageOverlay #subtitleLabel {
    -fx-font-family: Titillium;
    -fx-font-size: 14px;
}

/*
 * ================================================================
 * CenterScreen Styling
 * ================================================================
 */
.centerScreen {
    -fx-background-color: white;
    -fx-padding: 10;
    -fx-spacing: 5;
}

#mainVBox {
    -fx-background-position: center center;
    -fx-background-repeat: no-repeat;
    -fx-background-size: 400 400;
}

/*
 * ================================================================
 * CategoryBox Styling
 * ================================================================
 */
.categoryBox #categoryLabel {
    -fx-font-family: "Helvetica Neue";
	-fx-font-weight: bold;
	-fx-font-size: 20px;
	-fx-text-fill: #395c9c;
}

.categoryBox #categoryVBox {
    -fx-padding: 0 0 0 5;
}

/*
 * ================================================================
 * SubcategoryBox Styling
 * ================================================================
 */
.subcategoryBox #subcategoryLabel {
    -fx-font-family: "Helvetica Neue";
	-fx-font-weight: bold;
	-fx-font-size: 16px;
	-fx-text-fill: #455a64;
}

.subcategoryBox #subcategoryVBox {
    -fx-padding: 2 0 10 0;
}

/*
 * ================================================================
 * TaskEntry Styling
 * ================================================================
 */
.taskEntry {
    -fx-font-family: Titillium;
    -fx-font-size: 16px;
    -fx-padding: 2 0 3 0;
}

.taskEntry #lineNum {
    -fx-font-family: "Helvetica Neue";
    -fx-font-size: 14px;
    -fx-font-weight: bold;
    -fx-padding: 0 5 0 15;
}

.taskEntry #description {
    -fx-wrap-text: true;
}

.taskEntry #time {
    -fx-font-family: "Helvetica Neue";
    -fx-font-size: 13px;
    -fx-font-weight: bold;
    -fx-padding: 0 0 0 25;
    -fx-wrap-text: true;
}

/*
 * ================================================================
 * TitleBar Styling
 * ================================================================
 */

.titleBar {
    -fx-background-color: white;
    -fx-font: 16px FontAwesome;
}

.titleBar #title {
	-fx-font-family: "Helvetic Neue";
	-fx-font-size: 17px;
	-fx-font-weight: bold;
}

.titleBar #close {
    -fx-label-padding: 0 0 0 10;
}
```
###### procrastinate\ui\views\SubcategoryBox.fxml
``` fxml
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.VBox?>

<VBox maxHeight="1.7976931348623157E308" minHeight="-Infinity" alignment="CENTER" styleClass="subcategoryBox" xmlns="http://javafx.com/javafx/8.0.40" xmlns:fx="http://javafx.com/fxml/1">
    <children>
        <Label fx:id="subcategoryLabel" text="Label" VBox.vgrow="ALWAYS" />
        <VBox fx:id="subcategoryVBox" maxHeight="1.7976931348623157E308" minHeight="-Infinity" VBox.vgrow="ALWAYS" />
    </children>
</VBox>
```
###### procrastinate\ui\views\TaskEntry.fxml
``` fxml
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.*?>

<GridPane maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" styleClass="taskEntry" xmlns="http://javafx.com/javafx/8.0.40" xmlns:fx="http://javafx.com/fxml/1">
<columnConstraints>
   <ColumnConstraints halignment="LEFT" hgrow="SOMETIMES" maxWidth="1.7976931348623157E308" minWidth="50" />
   <ColumnConstraints halignment="LEFT" hgrow="ALWAYS" />
   <ColumnConstraints halignment="RIGHT" hgrow="SOMETIMES" maxWidth="1.7976931348623157E308" minWidth="-Infinity" />
</columnConstraints>
<rowConstraints>
   <RowConstraints vgrow="ALWAYS" />
</rowConstraints>
<children>
   <Label fx:id="lineNum" text="Label" GridPane.halignment="LEFT" GridPane.valignment="TOP" />
   <Label fx:id="description" text="Label" wrapText="true" GridPane.columnIndex="1" GridPane.halignment="LEFT" GridPane.valignment="TOP" />
   <Label fx:id="time" text="Label" textAlignment="RIGHT" GridPane.columnIndex="2" GridPane.halignment="RIGHT" GridPane.valignment="TOP" />
</children>
</GridPane>
```
###### procrastinate\ui\views\TitleBar.fxml
``` fxml
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.Cursor?>
<?import javafx.scene.image.Image?>
<?import javafx.scene.image.ImageView?>
<?import javafx.scene.layout.*?>

<HBox styleClass="titleBar" xmlns="http://javafx.com/javafx/8.0.40" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <HBox HBox.hgrow="ALWAYS">
         <children>
            <ImageView fitHeight="20.0" fitWidth="20.0" pickOnBounds="true" preserveRatio="true">
               <image>
                  <Image url="/procrastinate/ui/images/icon.png" />
               </image>
            </ImageView>
         </children>
      </HBox>
      <HBox alignment="TOP_CENTER" HBox.hgrow="ALWAYS">
         <children>
            <Label fx:id="title" alignment="TOP_CENTER" focusTraversable="false" text="Procrastinate" />
         </children>
         <HBox.margin>
            <Insets left="25.0" />
         </HBox.margin>
      </HBox>
      <HBox alignment="TOP_RIGHT" HBox.hgrow="ALWAYS">
         <children>
            <Label fx:id="minimise" focusTraversable="false" text="Minimise">
               <cursor>
                  <Cursor fx:constant="HAND" />
               </cursor>
            </Label>
            <Label fx:id="close" focusTraversable="false" text="Close">
               <cursor>
                  <Cursor fx:constant="HAND" />
               </cursor>
            </Label>
         </children>
      </HBox>
   </children>
</HBox>
```
###### procrastinate\ui\WindowHandler.java
``` java
package procrastinate.ui;

import java.awt.SystemTray;
import java.io.IOException;

import javafx.beans.property.BooleanProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.image.Image;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;
import javafx.stage.StageStyle;

/**
 * <h1>WindowHandler handles the configuration and Scene settings of the primary Stage.</h1>
 * It also instantiates the SystemTrayHandler class if SystemTray is supported.
 */
public class WindowHandler {

    // ================================================================================
    // Fixed Variables
    // ================================================================================

    private static final String LOCATION_CSS_STYLESHEET = "views/procrastinate.css";
    private static final String LOCATION_MAIN_WINDOW_LAYOUT = "views/MainWindowLayout.fxml";
    private static final String LOCATION_TITLE_BAR_FXML = "views/TitleBar.fxml";
    private static final String LOCATION_WINDOW_ICON = "images/icon.png";

    private static final String WINDOW_TITLE = "Procrastinate";
    private static final double WINDOW_WIDTH = 500;
    private static final double WINDOW_MIN_WIDTH = 500;
    private static final double WINDOW_HEIGHT = 600;
    private static final double WINDOW_MIN_HEIGHT = 600;

    private static final String ICON_CLOSE = "\uf00d";
    private static final String ICON_MINIMISE = "\uf068";
    private static final String STYLE_CLASS_MAIN_WINDOW = "mainWindow";
    private static final int WRAPPER_PREF_WIDTH = 800;
    private static final int WRAPPER_PREF_HEIGHT = 800;

    // ================================================================================
    // Class Variables
    // ================================================================================

    private Stage primaryStage_;

    private Parent root_;

    private SystemTray systemTray_;

    private SystemTrayHandler systemTrayHandler_;

    private BooleanProperty exitIndicator_ = new SimpleBooleanProperty(false);

    private static double xOffset_, yOffset_;

    // ================================================================================
    // FXML Field Variables
    // ================================================================================

    @FXML
    private BorderPane mainBorderPane;
    @FXML
    private Label close;
    @FXML
    private Label minimise;
    @FXML
    private Label statusLabel;
    @FXML
    private StackPane centerScreen;
    @FXML
    private TextField userInputField;

    // ================================================================================
    // WindowHandler Constructor
    // ================================================================================

    protected WindowHandler(Stage stage) {
        this.primaryStage_ = stage;
    }

    // ================================================================================
    // WindowHandler Methods
    // ================================================================================

    protected void loadWindowConfigurations(boolean showTray) {
        loadMainWindowLayout();
        if (showTray) {
            initTray();
        }
        overwriteDecorations();
        windowSetUp();
    }

    protected void bindAsExitIndicator(BooleanProperty isExit) {
        exitIndicator_.bindBidirectional(isExit);
        systemTrayHandler_.bindExitIndicator(isExit);
    }

    private void loadMainWindowLayout() {
        FXMLLoader loader = new FXMLLoader(getClass().getResource(LOCATION_MAIN_WINDOW_LAYOUT));
        loader.setController(this); // Required due to different package
                                    // declaration from Main
        try {
            root_ = loader.load();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void windowSetUp() {
        configurePrimaryStage();
        setUpScene();
    }

    private void configurePrimaryStage() {
        primaryStage_.setTitle(WINDOW_TITLE);
        primaryStage_.setMinHeight(WINDOW_MIN_HEIGHT);
        primaryStage_.setMinWidth(WINDOW_MIN_WIDTH);

        primaryStage_.getIcons().add(new Image(WindowHandler.class.getResource(LOCATION_WINDOW_ICON).toExternalForm()));
    }

    private void setUpScene() {
        Scene primaryScene = new Scene(root_, WINDOW_WIDTH, WINDOW_HEIGHT);
        primaryScene.setFill(Color.TRANSPARENT);
        primaryScene.getStylesheets().add(getClass().getResource(LOCATION_CSS_STYLESHEET).toExternalForm());

        primaryStage_.setScene(primaryScene);
    }

    private void initTray() {
        if (isSysTraySupported()) {
            systemTrayHandler_ = new SystemTrayHandler(primaryStage_, userInputField);
            // userInputField is passed to SystemTrayHandler to request for
            // focus whenever the window is shown
            systemTray_ = systemTrayHandler_.initialiseTray();
            assert(systemTray_ != null);
        }
    }

    /**
     * Removes all window decorations, replacing a custom title bar and allow
     * dragging of window
     */
    private void overwriteDecorations() {
        createTitleBar();
        setTransparentStageStyle();
        setMouseEvents();
        wrapCurrentRoot();
    }

```
###### procrastinate\ui\WindowHandler.java
``` java
    /**
     * Creates a title bar for minimising and closing of Procrastinate.
     */
    private void createTitleBar() {
        FXMLLoader loader = new FXMLLoader(getClass().getResource(LOCATION_TITLE_BAR_FXML));
        try {
            loader.setController(this);
            HBox titleBar = loader.load();

            close.setText(ICON_CLOSE);
            close.setOnMouseClicked(mouseEvent -> {
                                    exitIndicator_.set(false);
                                    exitIndicator_.set(true);
            });

            minimise.setText(ICON_MINIMISE);
            if (systemTrayHandler_ != null) {
                minimise.setOnMouseClicked(mouseEvent -> systemTrayHandler_.windowHideOrShow());
            } else {
                minimise.setOnMouseClicked(mouseEvent -> primaryStage_.setIconified(true));
            }

            ((BorderPane) root_).setTop(titleBar);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private boolean isSysTraySupported() {
        return SystemTray.isSupported();
    }

    // ================================================================================
    // Getter Methods
    // ================================================================================

```
