# A0121597B
###### procrastinate\ui\CategoryBox.java
``` java
package procrastinate.ui;

import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.effect.BlurType;
import javafx.scene.effect.DropShadow;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;

import java.io.IOException;

public class CategoryBox extends VBox {

    // ================================================================================
    // Message strings
    // ================================================================================

    private static final String LOCATION_CATEGORYBOX_FXML = "views/CategoryBox.fxml";

    // ================================================================================
    // Class variables
    // ================================================================================

    private Node categoryBox;

    // ================================================================================
    // FXML field variables
    // ================================================================================

    @FXML private Label categoryLabel;
    @FXML private VBox categoryVBox;

    // ================================================================================
    // CategoryBox methods
    // ================================================================================

    /**
     * Creates a category with the given label for tasks to go into
     * @param label
     */
    protected CategoryBox(String label) {
        FXMLLoader loader = new FXMLLoader(getClass().getResource(LOCATION_CATEGORYBOX_FXML));
        loader.setController(this); // Required due to different package declaration from Main
        try {
            this.categoryBox = loader.load();
            this.categoryLabel.setText(label);
            DropShadow ds = new DropShadow(BlurType.GAUSSIAN, Color.GRAY, 6, 0, 0, 2.0f);
            categoryLabel.setEffect(ds);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    // ================================================================================
    // Getter methods
    // ================================================================================
```
###### procrastinate\ui\CenterPaneController.java
``` java
package procrastinate.ui;

import javafx.animation.FadeTransition;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.SequentialTransition;
import javafx.animation.Timeline;
import javafx.scene.Node;
import javafx.scene.control.ScrollPane;
import javafx.scene.layout.StackPane;
import javafx.util.Duration;
import procrastinate.task.Task;
import procrastinate.ui.UI.ScreenView;

import java.util.List;

public class CenterPaneController {

    // ================================================================================
    // Message strings
    // ================================================================================

    private static final String LOCATION_CENTER_SCREEN_LAYOUT = "views/CenterScreen.fxml";

    private static final String MESSAGE_UNABLE_RECOGNISE_SCREEN_TYPE = "Unable to recognise ScreenType";

    // ================================================================================
    // Animation time values
    // ================================================================================

    private static final double OPACITY_FULL = 1;
    private static final double OPACITY_ZERO = 0;

    // Time values are in milliseconds
    private static final double TIME_HELP_SCREEN_FADEIN = 150;
    private static final double TIME_HELP_SCREEN_FADEOUT = 200;

    private static final double TIME_SPLASH_SCREEN_FADE = 3000;
    private static final double TIME_SPLASH_SCREEN_FULL_OPACITY = 2000;
    private static final double TIME_SPLASH_SCREEN_INTERRUPT = 2700;

    // ================================================================================
    // Class variables
    // ================================================================================

    private static double xOffset, yOffset;

 // Changed to protected for testing purposes.
    protected CenterScreen currentScreenView;
    protected ImageOverlay currentOverlay;

    private Timeline splashScreenTimeline;

    private Node mainScreenNode;
    private Node doneScreenNode;
    private Node searchScreenNode;
    private Node summaryScreenNode;

    private Node helpOverlayNode;
    private Node splashOverlayNode;

    private ImageOverlay helpOverlay;
    private ImageOverlay splashOverlay;

    private MainScreen mainScreen;
    private SearchScreen searchScreen;
    private SummaryScreen summaryScreen;

    private DoneScreen doneScreen;

    private StackPane centerStackPane;

    private boolean isInitial = true;

    // ================================================================================
    // CenterPaneController methods
    // ================================================================================

    // New CenterPaneController should only contain one screen node at all times, excluding the overlay nodes.
    protected CenterPaneController(StackPane centerStackPane) {
        this.centerStackPane = centerStackPane;
        createScreens();
        createOverlays();
        setToSummaryScreen();
    }

    protected void updateScreen(List<Task> taskList, ScreenView screenView) {
        if (isInitial) {
            summaryScreen.updateTaskList(taskList);
            mainScreen.updateTaskList(taskList);
            isInitial = false;
            return;
        }

        switch (screenView) {

            case SCREEN_DONE: {
                if (currentScreenView == doneScreen) {
                    doneScreen.updateTaskList(taskList);
                    break;
                } else {
                    startScreenSwitchSequence(taskList, doneScreenNode, doneScreen);
                    break;
                }
            }

            case SCREEN_MAIN: {
                if (currentScreenView == mainScreen) {
                    mainScreen.updateTaskList(taskList);
                    break;
                } else if (currentScreenView == summaryScreen) {
                    removeSummaryScreen(taskList);
                    break;
                } else {
                    startScreenSwitchSequence(taskList, mainScreenNode, mainScreen);
                    break;
                }
            }

            case SCREEN_SEARCH: {
                if (currentScreenView == searchScreen) {
                    searchScreen.updateTaskList(taskList);
                    break;
                } else {
                    startScreenSwitchSequence(taskList, searchScreenNode, searchScreen);
                    break;
                }
            }

            default:
                System.out.println(MESSAGE_UNABLE_RECOGNISE_SCREEN_TYPE);
                break;
        }
    }

    /**
     * Starts the fade out transition that lasts for 0.5 seconds if the stack contains it
     * and it is the current overlay screen.
     */
    protected void hideHelpOverlay() {
        if (currentOverlay != helpOverlay || !centerStackPane.getChildren().contains(helpOverlayNode)) {
            return;
        }
        FadeTransition helpOverlayFadeOut = getFadeOutTransition(TIME_HELP_SCREEN_FADEOUT, helpOverlayNode);
        helpOverlayFadeOut.setOnFinished(e -> {
            centerStackPane.getChildren().remove(helpOverlayNode);
            currentOverlay = null;
        });
        helpOverlayFadeOut.play();
    }

    /**
     * Fast-forwards the fade animation if user starts typing, which will remove the entire
     * node from the stack once it has finished fading.
     */
    protected void hideSplashOverlay() {
        if (currentOverlay == splashOverlay && centerStackPane.getChildren().contains(splashOverlayNode)) {
            Duration interruptTime = Duration.millis(TIME_SPLASH_SCREEN_INTERRUPT);
            // Only fast forward the timeline if the current time of the animation is smaller than the given
            // interrupt time. Else, just wait for the animation to end.
            if (splashScreenTimeline.getCurrentTime().lessThan(interruptTime)) {
                splashScreenTimeline.jumpTo(Duration.millis(TIME_SPLASH_SCREEN_INTERRUPT));
            }
            splashScreenTimeline.jumpTo(Duration.millis(TIME_SPLASH_SCREEN_FADE));
        }
    }

    /**
     * Creates a splash screen that maintains full opacity for 2 seconds before completely fading out in 1 second
     * or until the user starts to type.
     */
    protected void showSplashOverlay() {
        currentOverlay = splashOverlay;
        centerStackPane.getChildren().add(splashOverlayNode);

        buildSplashScreenAnimation();
        splashScreenTimeline.play();
    }

    protected void showHelpOverlay() {
        if (currentOverlay == helpOverlay || centerStackPane.getChildren().contains(helpOverlay)) {
            return;
        }
        currentOverlay = helpOverlay;
        centerStackPane.getChildren().add(helpOverlayNode);
        helpOverlayNode.toFront();

        FadeTransition helpOverlayFadeIn = getFadeInTransition(TIME_HELP_SCREEN_FADEIN, helpOverlayNode);
        helpOverlayFadeIn.play();
    }

    protected void nextHelpPage() {
        if (currentOverlay != helpOverlay) {
            return;
        }
        ((HelpOverlay) helpOverlay).nextPage();
    }

    // ================================================================================
    // Utility methods
    // ================================================================================

    protected void receiveSearchStringAndPassToSearchScreen(String searchString) {
        searchScreen.updateSearchStringLabel(searchString);
    }

    private void startScreenSwitchSequence(List<Task> taskList, Node nodeToSwitchIn, CenterScreen screenToSwitchIn) {
        SequentialTransition screenSwitchSequence;
        screenSwitchSequence = currentScreenView.getScreenSwitchOutSequence();
        screenSwitchSequence.setOnFinished(e -> {
            centerStackPane.getChildren().clear();
            centerStackPane.getChildren().add(nodeToSwitchIn);
            screenToSwitchIn.getScreenSwitchInSequence().play();
            screenToSwitchIn.updateTaskList(taskList);
            currentScreenView = screenToSwitchIn;
        });
        screenSwitchSequence.play();
    }

    private FadeTransition getFadeOutTransition(double timeInMs, Node transitingNode) {
        FadeTransition fadeTransition = new FadeTransition(Duration.millis(timeInMs), transitingNode);
        fadeTransition.setFromValue(OPACITY_FULL);
        fadeTransition.setToValue(OPACITY_ZERO);
        fadeTransition.setInterpolator(Interpolator.EASE_OUT);
        return fadeTransition;
    }

    private FadeTransition getFadeInTransition(double timeInMs, Node transitingNode) {
        FadeTransition fadeTransition = new FadeTransition(Duration.millis(timeInMs), transitingNode);
        fadeTransition.setFromValue(OPACITY_ZERO);
        fadeTransition.setToValue(OPACITY_FULL);
        fadeTransition.setInterpolator(Interpolator.EASE_IN);
        return fadeTransition;
    }

    private void buildSplashScreenAnimation() {
        // Set SplashScreen opacity at full for 2 seconds.
        Duration fullOpacityDuration = Duration.millis(TIME_SPLASH_SCREEN_FULL_OPACITY);
        KeyValue fullOpacityKeyValue = new KeyValue(splashOverlayNode.opacityProperty(), OPACITY_FULL);
        KeyFrame fullOpacityFrame = new KeyFrame(fullOpacityDuration, fullOpacityKeyValue);

        // Set SplashScreen to fade out completely at time = 3 seconds
        Duration zeroOpacityDuration = Duration.millis(TIME_SPLASH_SCREEN_FADE);
        KeyValue zeroOpacityKeyValue = new KeyValue(splashOverlayNode.opacityProperty(), OPACITY_ZERO);
        KeyFrame zeroOpacityFrame = new KeyFrame(zeroOpacityDuration, zeroOpacityKeyValue);

        splashScreenTimeline= new Timeline(fullOpacityFrame, zeroOpacityFrame);
        splashScreenTimeline.setOnFinished(e -> {
            centerStackPane.getChildren().remove(splashOverlayNode);
            currentOverlay = null;
        });
    }

    // ================================================================================
    // Init methods
    // ================================================================================

    private void createOverlays() {
        createHelpOverlay();
        createSplashOverlay();
    }

    /**
     * This creates and holds a list of the screens that can be easily added onto the center pane
     * @return list of screens
     */
    private void createScreens() {
        createMainScreen();
        createDoneScreen();
        createSearchScreen();
        createSummaryScreen();
    }

    private void createHelpOverlay() {
        this.helpOverlay = new HelpOverlay();
        this.helpOverlayNode = helpOverlay.getNode();
    }

    private void createSplashOverlay() {
        this.splashOverlay = new SplashOverlay();
        this.splashOverlayNode = splashOverlay.getNode();
    }

    private void createMainScreen() {
        this.mainScreen = new MainScreen(LOCATION_CENTER_SCREEN_LAYOUT);
        this.mainScreenNode = mainScreen.getNode();
        addMouseDragListeners(mainScreenNode);
    }

    private void createDoneScreen() {
        this.doneScreen = new DoneScreen(LOCATION_CENTER_SCREEN_LAYOUT);
        this.doneScreenNode = doneScreen.getNode();
        addMouseDragListeners(doneScreenNode);
    }

    private void createSearchScreen() {
        this.searchScreen = new SearchScreen(LOCATION_CENTER_SCREEN_LAYOUT);
        this.searchScreenNode = searchScreen.getNode();
        addMouseDragListeners(searchScreenNode);
    }

    private void createSummaryScreen() {
        this.summaryScreen = new SummaryScreen(LOCATION_CENTER_SCREEN_LAYOUT);
        this.summaryScreenNode = summaryScreen.getNode();
        addMouseDragListeners(summaryScreenNode);
    }

    /**
     * Hide the MainScreen below the SummaryScreen since it'll take some time to start up later on.
     */
    private void setToSummaryScreen() {
        centerStackPane.getChildren().add(mainScreenNode);
        centerStackPane.getChildren().add(summaryScreenNode);
        currentScreenView = summaryScreen;
        summaryScreenNode.toFront();
        summaryScreenNode.setOpacity(OPACITY_FULL);
    }

    private void removeSummaryScreen(List<Task> taskList) {
        centerStackPane.getChildren().remove(summaryScreenNode);
        mainScreen.updateTaskList(taskList);
        currentScreenView = mainScreen;
    }

```
###### procrastinate\ui\CenterScreen.java
``` java
package procrastinate.ui;

import javafx.animation.FadeTransition;
import javafx.animation.Interpolator;
import javafx.animation.SequentialTransition;
import javafx.beans.binding.Bindings;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.SimpleIntegerProperty;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Node;
import javafx.scene.layout.VBox;
import javafx.util.Duration;
import javafx.util.converter.NumberStringConverter;
import procrastinate.task.Task;

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Calendar;
import java.util.Date;
import java.util.List;

public abstract class CenterScreen extends VBox {

    protected static final String MESSAGE_UNABLE_TO_DETERMINE_TYPE = "Unable to determine TaskType for adding.";
    protected static final String MESSAGE_UNABLE_TO_RECOGNISE_NODE = "Unable to recognise Node.";

    protected static final String EVENT_DATE_SEPARATOR_GENERAL = "\nto ";
    protected static final String EVENT_DATE_SEPARATOR_SAME_DAY = " to ";
    protected static final String FRIENDLY_DATE_OR_TIME_SEPARATOR = " ";

    protected static final String SELECTOR_CATEGORY_VBOX = "#categoryVBox";

    protected static final String FX_BACKGROUND_IMAGE_NULL = "-fx-background-image: null;";

    protected static final double OPACITY_ZERO = 0;
    protected static final double OPACITY_FULL = 1;

    private static final String UI_NUMBER_SEPARATOR = ". ";

    private static final String DATE_TODAY = "Today";
    private static final String DATE_TOMORROW = "Tomorrow";

    // ================================================================================
    // Class variables
    // ================================================================================

    protected IntegerProperty taskCount = new SimpleIntegerProperty(1);
    protected StringProperty taskCountFormatted = new SimpleStringProperty();
    protected StringProperty taskCountString = new SimpleStringProperty();

    protected SimpleDateFormat dateFormatWithFriendlyDayAndYear = new SimpleDateFormat("EEE d MMM''yy h:mma");
    protected SimpleDateFormat dateFormat = new SimpleDateFormat("d MMM");
    protected SimpleDateFormat timeFormat = new SimpleDateFormat("h:mma");
    protected SimpleDateFormat yearFormat = new SimpleDateFormat("yyyy");

    private Node node;

    private Date today;
    private Date currentDate;
    private Date endOfWeek;

    // ================================================================================
    // FXML field variables
    // ================================================================================

    @FXML private VBox mainVBox;

    // ================================================================================
    // CenterScreen Constructor
    // ================================================================================

    protected CenterScreen(String filePath) {
        loadLayout(filePath);
        setupBinding();
    }

    // ================================================================================
    // Init methods
    // ================================================================================

    /**
     * Setup the various categories that tasks can fall under
     */
    protected abstract void createCategories();

    /**
     * The list of tasks displayed is updated by removing all previously added tasks and re-adding them back to allow
     * the line number to be sorted by category and not insertion time.
     *
     * Dreams are directly added via this method but Deadlines and Events are passed to two different
     * addTask methods depending on their (start) dates.
     * @param taskList List of Tasks to be added onto the screen
     */
    protected abstract void updateTaskList(List<Task> taskList);
    protected abstract SequentialTransition getScreenSwitchOutSequence();
    protected abstract SequentialTransition getScreenSwitchInSequence();

    private void loadLayout(String filePath) {
        FXMLLoader loader = new FXMLLoader(getClass().getResource(filePath));
        loader.setController(this); // Required due to different package declaration from Main
        try {
            node = loader.load();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Creates a formatted shared task counter for use when adding tasks onto the screen
     */
    private void setupBinding() {
        taskCountString.bindBidirectional(taskCount, new NumberStringConverter());
        taskCountFormatted.bind(Bindings.concat(taskCountString).concat(UI_NUMBER_SEPARATOR));
    }

    // ================================================================================
    // Animation methods
    // ================================================================================

    protected FadeTransition generateFadeInTransition(Node nodeToFade, int fadeInTime) {
        FadeTransition transition = new FadeTransition(Duration.millis(fadeInTime), nodeToFade);
        transition.setFromValue(OPACITY_ZERO);
        transition.setToValue(OPACITY_FULL);
        transition.setInterpolator(Interpolator.EASE_IN);
        return transition;
    }

    protected FadeTransition generateFadeOutTransition(Node nodeToFade, int fadeOutTime) {
        FadeTransition transition = new FadeTransition(Duration.millis(fadeOutTime), nodeToFade);
        transition.setFromValue(OPACITY_FULL);
        transition.setToValue(OPACITY_ZERO);
        transition.setInterpolator(Interpolator.EASE_IN);
        return transition;
    }

    // ================================================================================
    // Date Format methods
    // ================================================================================

    protected String getDifferentYearDeadlineDateFormat(Date date) {
        return dateFormatWithFriendlyDayAndYear.format(date);
    }

    protected String getDifferentYearSameDayEventDateFormat(Date date, Date endDate) {
        return dateFormatWithFriendlyDayAndYear.format(date)
                + EVENT_DATE_SEPARATOR_SAME_DAY
                + timeFormat.format(endDate);
    }

    protected String getDifferentYearEventDateFormat(Date date, Date endDate) {
        return dateFormatWithFriendlyDayAndYear.format(date)
                    + EVENT_DATE_SEPARATOR_GENERAL
                    + dateFormatWithFriendlyDayAndYear.format(endDate);
    }

    protected String getSameYearDeadlineDateFormat(Date date) {
        return getDayOfWeek(date)
                    + FRIENDLY_DATE_OR_TIME_SEPARATOR
                    + dateFormat.format(date)
                    + FRIENDLY_DATE_OR_TIME_SEPARATOR
                    + timeFormat.format(date);
    }

    protected String getSameYearSameDayEventDateFormat(Date date, Date endDate) {
        return getDayOfWeek(date)
                + FRIENDLY_DATE_OR_TIME_SEPARATOR
                + dateFormat.format(date)
                + FRIENDLY_DATE_OR_TIME_SEPARATOR
                + timeFormat.format(date)
                + EVENT_DATE_SEPARATOR_SAME_DAY
                + timeFormat.format(endDate);
    }

    protected String getSameYearDifferentDayEventDateFormat(Date date, Date endDate) {
        return getDayOfWeek(date)
                + FRIENDLY_DATE_OR_TIME_SEPARATOR
                + dateFormat.format(date)
                + FRIENDLY_DATE_OR_TIME_SEPARATOR
                + timeFormat.format(date)
                + EVENT_DATE_SEPARATOR_GENERAL
                + getDayOfWeek(endDate)
                + FRIENDLY_DATE_OR_TIME_SEPARATOR
                + dateFormat.format(endDate)
                + FRIENDLY_DATE_OR_TIME_SEPARATOR
                + timeFormat.format(endDate);
    }

    protected String getThisWeekSameDayEventDateFormat(Date startDate, Date endDate) {
        return timeFormat.format(startDate)
                + EVENT_DATE_SEPARATOR_SAME_DAY
                + timeFormat.format(endDate);
    }

    protected String getThisWeekEndDifferentDayEventDateFormat(Date startDate, Date endDate) {
        return getFriendlyDayFormatThisWeek(startDate)
                + FRIENDLY_DATE_OR_TIME_SEPARATOR
                + timeFormat.format(startDate)
                + EVENT_DATE_SEPARATOR_GENERAL
                + getFriendlyDayFormatThisWeek(endDate)
                + FRIENDLY_DATE_OR_TIME_SEPARATOR
                + timeFormat.format(endDate);
    }

    protected String getThisWeekEndDifferentWeekEventDateFormat(Date startDate, Date endDate) {
        return getFriendlyDayFormatThisWeek(startDate)
                + FRIENDLY_DATE_OR_TIME_SEPARATOR
                + timeFormat.format(startDate)
                + EVENT_DATE_SEPARATOR_GENERAL
                + getDayOfWeek(endDate)
                + FRIENDLY_DATE_OR_TIME_SEPARATOR
                + dateFormat.format(endDate)
                + FRIENDLY_DATE_OR_TIME_SEPARATOR
                + timeFormat.format(endDate);
    }

    protected String getThisWeekEndDifferentYearDateFormat(Date startDate, Date endDate) {
        return getFriendlyDayFormatThisWeek(startDate)
                    + FRIENDLY_DATE_OR_TIME_SEPARATOR
                    + timeFormat.format(startDate)
                    + EVENT_DATE_SEPARATOR_GENERAL
                    + dateFormatWithFriendlyDayAndYear.format(endDate);
    }

    // ================================================================================
    // Utility methods
    // ================================================================================

    protected void setMainVBoxBackgroundImage(VBox mainVBox, String value) {
        mainVBox.setStyle(value);
    }

    protected void updateDates() {
        today = Date.from(getInstantFromLocalDateTime(getDateTimeStartOfToday()));    // To get today's Date at 0000hrs
        currentDate = new Date();
        endOfWeek = getEndOfWeekDate(today);
    }

    protected LocalDateTime getDateTimeStartOfToday() {
        return LocalDate.now().atStartOfDay();
    }

    /**
     * Converts a LocalDateTime to an Instant
     * @param localDateTime to be converted
     * @return Instant generated from the given LocalDateTime
     */
    protected Instant getInstantFromLocalDateTime(LocalDateTime localDateTime) {
        return localDateTime.atZone(ZoneId.systemDefault()).toInstant();
    }

    protected boolean checkIfTwoDatesOfSameYear(Date date1, Date date2) {
        return yearFormat.format(date1).equals(yearFormat.format(date2));
    }

    protected boolean checkIfStartAndEndSameDay(Date firstDate, Date secondDate) {
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(firstDate);
        int firstDay = calendar.get(Calendar.DAY_OF_YEAR);
        calendar.setTime(secondDate);
        int secondDay = calendar.get(Calendar.DAY_OF_YEAR);
        return firstDay == secondDay;
    }

    protected String getFriendlyDayFormatThisWeek(Date date) {
        LocalDateTime startingDateTime = LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());
        if (startingDateTime.getDayOfMonth() == getDateTimeStartOfToday().getDayOfMonth()) {
            return DATE_TODAY;
        } else if (startingDateTime.getDayOfMonth() == getDateTimeStartOfToday().plusDays(1).getDayOfMonth()) {
            return DATE_TOMORROW;
        } else {
            return getDayOfWeek(date);
        }
    }

    protected String getDayOfWeek(Date date) {
        SimpleDateFormat dateFormat = new SimpleDateFormat("EEE");
        return dateFormat.format(date);
    }

    /**
     * Generates the date of the end of the week for task date comparisons
     * @param today Current date at 0000hrs
     * @return Date of next Monday at 0000hrs for comparing tasks due this week
     */
    private Date getEndOfWeekDate(Date today) {
        Calendar calendar = Calendar.getInstance();
        calendar.setFirstDayOfWeek(Calendar.MONDAY);
        calendar.setTime(today);
        calendar.add(Calendar.DAY_OF_WEEK, 7);
        return calendar.getTime();
    }

    // ================================================================================
    // Getter methods
    // ================================================================================
```
###### procrastinate\ui\DateBox.java
``` java
package procrastinate.ui;

import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.VBox;

import java.io.IOException;

public class DateBox extends VBox {

    // ================================================================================
    // Message strings
    // ================================================================================

    private static final String LOCATION_DATEBOX_FXML = "views/DateBox.fxml";

    // ================================================================================
    // Class variables
    // ================================================================================

    private Node dateBox;

    // ================================================================================
    // FXML field variables
    // ================================================================================

    @FXML private Label dateLabel;
    @FXML private VBox dateVBox;

    // ================================================================================
    // CategoryBox methods
    // ================================================================================

    /**
     * Creates a category with the given label for tasks to go into
     * @param label
     */
    protected DateBox(String label) {
        FXMLLoader loader = new FXMLLoader(getClass().getResource(LOCATION_DATEBOX_FXML));
        loader.setController(this); // Required due to different package declaration from Main
        try {
            this.dateBox = loader.load();
            this.dateLabel.setText(label);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    // ================================================================================
    // Getter methods
    // ================================================================================
```
###### procrastinate\ui\DoneScreen.java
``` java
package procrastinate.ui;

import java.util.Date;
import java.util.List;

import javafx.scene.layout.VBox;
import procrastinate.task.Deadline;
import procrastinate.task.Event;
import procrastinate.task.Task;

public class DoneScreen extends SingleCategoryScreen {

    // ================================================================================
    // Message strings
    // ================================================================================

    private static final String HEADER_TEXT = "Your completed tasks";
    private static final String LOCATION_EMPTY_VIEW = "images/no-done-tasks.png";

    private static String FX_BACKGROUND_IMAGE_NO_DONE_TASKS; // will be initialised later on.

    // ================================================================================
    // DoneScreen Constructor
    // ================================================================================

    protected DoneScreen(String filePath) {
        super(filePath, HEADER_TEXT);
    }

    // ================================================================================
    // Display methods
    // ================================================================================

    @Override
    protected void updateTaskList(List<Task> taskList) {
        getUpdatedDates();
        clearTaskList();
        mainVBox.getChildren().add(thisCategoryNode);

        String dateString;

        for (Task task : taskList) {
            if (task.isDone()) {
                taskCount.set(taskCount.get() + 1);

                switch (task.getType()) {

                    case DEADLINE: {
                        Date date =((Deadline) task).getDate();
                        dateString = getDateFormatForDateline(date);
                        addDoneTask(taskCountFormatted.get(), task, dateString);
                        break;
                    }

                    case EVENT: {
                        Date startDate = ((Event) task).getStartDate();
                        Date endDate = ((Event) task).getEndDate();
                        dateString = getDateFormatForEvent(startDate, endDate);
                        addDoneTask(taskCountFormatted.get(), task, dateString);
                        break;
                    }

                    case DREAM: {
                        addDoneTask(taskCountFormatted.get(), task, null);
                        break;
                    }

                    default: {
                        System.out.println(MESSAGE_UNABLE_TO_DETERMINE_TYPE);
                        break;
                    }
                }
            }
        }
        checkIfMainVBoxIsEmpty(mainVBox);
    }

    private void addDoneTask(String taskCount, Task task, String dateString) {
        TaskEntry taskEntry;
        if (dateString == null) {
            taskEntry = new TaskEntry(taskCount, task.getDescription(), task.isDone());
        } else {
            taskEntry = new TaskEntry(taskCount, task.getDescription(), dateString, task.isDone());
        }
        thisCategoryTaskList.getChildren().add(taskEntry.getEntryDisplay());
    }

    private String getDateFormatForDateline(Date date) {
        String dateString;
        boolean isSameYear = checkIfTwoDatesOfSameYear(date, today);
        if (isSameYear) {
            dateString = getSameYearDeadlineDateFormat(date);
        } else {
            dateString = getDifferentYearDeadlineDateFormat(date);
        }
        return dateString;
    }

    private String getDateFormatForEvent(Date startDate, Date endDate) {
        String dateString;
        boolean isStartSameYear = checkIfTwoDatesOfSameYear(startDate, today);
        if (isStartSameYear) {
            if (checkIfStartAndEndSameDay(startDate, endDate)) {
                dateString = getSameYearSameDayEventDateFormat(startDate, endDate);
            } else {
                dateString = getSameYearDifferentDayEventDateFormat(startDate, endDate);
            }
        } else {
            dateString = getDifferentYearEventDateFormat(startDate, endDate);
        }
        return dateString;
    }

    // ================================================================================
    // Utility methods
    // ================================================================================

    private void checkIfMainVBoxIsEmpty(VBox mainVBox) {
        if (FX_BACKGROUND_IMAGE_NO_DONE_TASKS == null) {
            String image = DoneScreen.class.getResource(LOCATION_EMPTY_VIEW).toExternalForm();
            FX_BACKGROUND_IMAGE_NO_DONE_TASKS = "-fx-background-image: url('" + image + "');";
        }
        if (thisCategoryTaskList.getChildren().isEmpty()) {
            mainVBox.getChildren().remove(thisCategoryNode);
            mainVBox.setStyle(FX_BACKGROUND_IMAGE_NO_DONE_TASKS);
        } else {
            setMainVBoxBackgroundImage(mainVBox, FX_BACKGROUND_IMAGE_NULL);
        }
    }
}
```
###### procrastinate\ui\HelpOverlay.java
``` java
package procrastinate.ui;

import javafx.geometry.Pos;
import javafx.scene.image.Image;
import javafx.scene.layout.VBox;

public class HelpOverlay extends ImageOverlay {

    // ================================================================================
    // Message strings
    // ================================================================================

    private static final int WRAPPER_PREF_HEIGHT = 430;
    private static final int WRAPPER_PREF_WIDTH = 400;

    private static final String LOCATION_REFERENCE_SHEET = "images/referencesheet.png";
    private static final String LOCATION_REFERENCE_SHEET_2 = "images/referencesheet2.png";

    private static final String STYLE_CONTAINER_PADDING = "-fx-padding: 0 30 0 30;";
    private static final String STYLE_WRAPPER_BACKGROUND_RADIUS = "-fx-background-radius: 20;";
    private static final String STYLE_WRAPPER_BACKGROUND_COLOR = "-fx-background-color: #365fac;";

    // ================================================================================
    // Class variables
    // ================================================================================

    private boolean isFirstPage = true;

    // ================================================================================
    // HelpOverlay Constructor
    // ================================================================================

    protected HelpOverlay() {
        setImage();
        adjustStylesAndAddWrapper();
    }

    // ================================================================================
    // HelpOverlay methods
    // ================================================================================

    @Override
    protected void setImage() {
        // Set to first page of Help sheet
        imageView.setImage(new Image(HelpOverlay.class.getResource(LOCATION_REFERENCE_SHEET).toExternalForm()));
        imageView.fitWidthProperty().set(400);
    }

```
###### procrastinate\ui\HelpOverlay.java
``` java
    private void adjustStylesAndAddWrapper() {
        container.setStyle(STYLE_CONTAINER_PADDING);
        container.getChildren().clear();
        container.getChildren().add(createWrapper());
    }

    private VBox createWrapper() {
        VBox wrapper = new VBox(imageView);
        wrapper.setAlignment(Pos.TOP_CENTER);
        wrapper.setPrefSize(WRAPPER_PREF_WIDTH, WRAPPER_PREF_HEIGHT);
        wrapper.setStyle(STYLE_WRAPPER_BACKGROUND_COLOR
                + STYLE_WRAPPER_BACKGROUND_RADIUS);
        return wrapper;
    }
}
```
###### procrastinate\ui\ImageOverlay.java
``` java
package procrastinate.ui;

import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Node;
import javafx.scene.image.ImageView;
import javafx.scene.layout.VBox;

import java.io.IOException;

public abstract class ImageOverlay {

    // ================================================================================
    // Message strings
    // ================================================================================

    private static final String LOCATION_HELP_OVERLAY_LAYOUT = "views/ImageOverlay.fxml";

    // ================================================================================
    // Class variables
    // ================================================================================

    protected Node node;

    // ================================================================================
    // FXML field variables
    // ================================================================================

    @FXML protected ImageView imageView;
    @FXML protected VBox container;

    // ================================================================================
    // Overlay Constructor
    // ================================================================================

    protected ImageOverlay() {
        FXMLLoader loader = new FXMLLoader(getClass().getResource(LOCATION_HELP_OVERLAY_LAYOUT));
        loader.setController(this); // Required due to different package declaration from Main
        try {
            node = loader.load();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    protected abstract void setImage();

```
###### procrastinate\ui\MainScreen.java
``` java
package procrastinate.ui;

import java.util.List;

import javafx.scene.layout.VBox;
import procrastinate.task.Task;

public class MainScreen extends MultiCategoryScreen {

    // ================================================================================
    // Message strings
    // ================================================================================

    private static final String FX_BACKGROUND_IMAGE_NO_TASKS = "-fx-background-image: url('/procrastinate/ui/images/no-tasks.png')";

    // ================================================================================
    // MainScreen Constructor
    // ================================================================================

    protected MainScreen(String filePath) {
        super(filePath);
    }

    // ================================================================================
    // MainScreen methods
    // ================================================================================

    @Override
    protected void updateTaskList(List<Task> taskList) {
        getUpdatedDates();
        clearTaskList();

        for (Task task : taskList) {
            taskCount.set(taskCount.get() + 1);

            addTaskByType(task);
        }
        updateDisplay();
    }

    @Override
    protected void setBackgroundImageIfMainVBoxIsEmpty(VBox mainVBox) {
        if (mainVBox.getChildren().isEmpty()) {
            mainVBox.setStyle(FX_BACKGROUND_IMAGE_NO_TASKS);
        }
    }

}
```
###### procrastinate\ui\MultiCategoryScreen.java
``` java
package procrastinate.ui;

import java.time.LocalDateTime;
import java.time.format.TextStyle;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.Locale;

import javafx.animation.FadeTransition;
import javafx.animation.ParallelTransition;
import javafx.animation.SequentialTransition;
import javafx.scene.Node;
import javafx.scene.layout.VBox;
import procrastinate.task.Deadline;
import procrastinate.task.Event;
import procrastinate.task.Task;

public abstract class MultiCategoryScreen extends CenterScreen {

    // ================================================================================
    // Message strings
    // ================================================================================

    private static final String CATEGORY_OVERDUE = "Overdue";
    private static final String CATEGORY_UPCOMING = "Upcoming";
    private static final String CATEGORY_FUTURE = "Future";
    private static final String CATEGORY_DREAMS = "Dreams";
    private static final String CATEGORY_DONE = "Done";

    private static final String SUBCATEGORY_TODAY = "Today";
    private static final String SUBCATEGORY_TOMORROW = "Tomorrow";

    // ================================================================================
    // Animation Values
    // ================================================================================
    // Time values used are in milliseconds
    private static final int TIME_TRANSITION_CATEGORY_FADE_IN = 250;
    private static final int TIME_TRANSITION_CATEGORY_FADE_OUT = 200;
    private static final int TIME_TRANSITION_SUBCATEGORY_FADE_IN = 200;
    private static final int TIME_TRANSITION_SUBCATEGORY_FADE_OUT = 150;

    // ================================================================================
    // Class variables
    // ================================================================================

    // Nodes are used to add them onto the screen
    protected Node overdueNode;
    protected Node upcomingNode;
    protected Node futureNode;
    protected Node dreamsNode;
    protected Node doneNode;

    protected ArrayList<Node> nodeList = new ArrayList<>();
    protected ArrayList<VBox> upcomingSubcategories = new ArrayList<>();

    protected int[] subcategoryVisibilityTracker; // used to determine if the subcategory is to be faded in or out.

    // The main variables to call when adding tasks since they act as a task list for a TaskEntry to be displayed
    protected VBox overdueTaskList;
    protected VBox upcomingTaskList;
    protected VBox futureTaskList;
    protected VBox dreamsTaskList;
    protected VBox doneTaskList;

    protected Date today;
    protected Date currentDate;
    protected Date endOfWeek;

    protected VBox mainVBox;

    // ================================================================================
    // MultiCategoryScreen Constructor
    // ================================================================================

    protected MultiCategoryScreen(String filePath) {
        super(filePath);
        createCategories();
        retrieveFxmlElements();
    }

    // ================================================================================
    // Init methods
    // ================================================================================

    /**
     * Setup the various categories that tasks can fall under
     */
    @Override
    protected void createCategories() {
        // Create all the different categories(by time frame) for entries to go into
        CategoryBox overdueBox = new CategoryBox(CATEGORY_OVERDUE);
        CategoryBox upcomingBox = new CategoryBox(CATEGORY_UPCOMING);
        CategoryBox futureBox = new CategoryBox(CATEGORY_FUTURE);
        CategoryBox dreamsBox = new CategoryBox(CATEGORY_DREAMS);
        CategoryBox doneBox = new CategoryBox(CATEGORY_DONE);

        this.overdueNode = overdueBox.getCategoryBox();
        this.overdueTaskList = overdueBox.getTaskListVBox();
        nodeList.add(overdueNode);

        this.upcomingNode = upcomingBox.getCategoryBox();
        this.upcomingTaskList = upcomingBox.getTaskListVBox();
        nodeList.add(upcomingNode);

        this.futureNode = futureBox.getCategoryBox();
        this.futureTaskList = futureBox.getTaskListVBox();
        nodeList.add(futureNode);

        this.dreamsNode = dreamsBox.getCategoryBox();
        this.dreamsTaskList = dreamsBox.getTaskListVBox();
        nodeList.add(dreamsNode);

        this.doneNode = doneBox.getCategoryBox();
        this.doneTaskList = doneBox.getTaskListVBox();
        nodeList.add(doneNode);
    }

    private void retrieveFxmlElements() {
        this.mainVBox = getMainVBox();
    }

    // ================================================================================
    // Methods to be overridden by Child
    // ================================================================================

    protected abstract void setBackgroundImageIfMainVBoxIsEmpty(VBox mainVBox);

    // ================================================================================
    // Screen Transition methods
    // ================================================================================

    @Override
    protected SequentialTransition getScreenSwitchOutSequence() {
        SequentialTransition sequentialTransition = new SequentialTransition();
        for (Node node : nodeList) {
            if (mainVBox.getChildren().contains(node)) {
                sequentialTransition.getChildren().add(0, generateFadeOutTransition(node, TIME_TRANSITION_CATEGORY_FADE_OUT));
            }
        }
        return sequentialTransition;
    }

    @Override
    protected SequentialTransition getScreenSwitchInSequence() {
        SequentialTransition sequentialTransition = new SequentialTransition();
        for (Node node : nodeList) {
            node.setOpacity(OPACITY_FULL);
        }
        return sequentialTransition;
    }

    // ================================================================================
    // TaskDisplay methods
    // ================================================================================

    protected void addTaskByType(Task task) {
        Date taskDate;
        switch (task.getType()) {

            case DEADLINE: {
                taskDate = ((Deadline) task).getDate();
                addDeadlineOrEvent(task, taskDate);
                break;
            }

            case EVENT: {
                taskDate = ((Event) task).getStartDate();
                addDeadlineOrEvent(task, taskDate);
                break;
            }

            case DREAM: {
                TaskEntry taskEntry = new TaskEntry(taskCountFormatted.get(), task.getDescription(), task.isDone());
                addDream(task, taskEntry);
                break;
            }

            default: {
                System.out.println(MESSAGE_UNABLE_TO_DETERMINE_TYPE);
                break;
            }
        }
    }

    protected void addDeadlineOrEvent(Task task, Date taskDate) {
        boolean isSameYear;
        isSameYear = checkIfTwoDatesOfSameYear(today, taskDate);
        if (isSameYear) {
            addTaskWithSameYear(task, taskDate);
        } else {
            addTaskWithDifferentYear(task, taskDate);
        }
    }

    protected void addDream(Task task, TaskEntry taskEntry) {
        if (task.isDone()) {
            doneTaskList.getChildren().add(taskEntry.getEntryDisplay());
        } else {
            dreamsTaskList.getChildren().add(taskEntry.getEntryDisplay());
        }
    }

    private void addTaskWithSameYear(Task task, Date date) {
        String dateString;

        switch (task.getType()) {

            case DEADLINE: {
                dateString = getSameYearDeadlineDateFormat(date);
                String taskCount = taskCountFormatted.get();
                TaskEntry taskEntry = new TaskEntry(taskCount, task.getDescription(), dateString, task.isDone());
                addTaskWithSameYearToTaskList(task, date, taskCount, taskEntry);
                break;
            }

            case EVENT: {
                Date endDate = ((Event) task).getEndDate();
                boolean isSameEndYear = checkIfTwoDatesOfSameYear(endDate, today);
                dateString = getDateFormatForEventWithSameStartYear(date, endDate, isSameEndYear);
                String taskCount = taskCountFormatted.get();
                TaskEntry taskEntry = new TaskEntry(taskCount, task.getDescription(), dateString, task.isDone());
                addTaskWithSameYearToTaskList(task, date, taskCount, taskEntry);
                break;
            }

            default: {
                System.out.println(MESSAGE_UNABLE_TO_DETERMINE_TYPE);
                break;
            }
        }
    }

    protected void addTaskWithSameYearToTaskList(Task task, Date date, String taskCount, TaskEntry taskEntry) {
        if (task.isDone()) {
            doneTaskList.getChildren().add(taskEntry.getEntryDisplay());
        } else if (date.before(currentDate)) {
            overdueTaskList.getChildren().add(taskEntry.getEntryDisplay());
        } else if (date.before(endOfWeek)) {
            addThisWeekTask(task, date, taskCount);
        } else {
            futureTaskList.getChildren().add(taskEntry.getEntryDisplay());
        }
    }

    private void addTaskWithDifferentYear(Task task, Date date) {
        String dateString;

        switch (task.getType()) {

            case DEADLINE: {
                dateString = getDifferentYearDeadlineDateFormat(date);
                TaskEntry taskEntry = new TaskEntry(taskCountFormatted.get(), task.getDescription(), dateString, task.isDone());
                addTaskWithDifferentYearToTaskList(task, date, taskEntry);
                break;
            }

            case EVENT: {
                Date endDate = ((Event) task).getEndDate();
                // if same day also should be in same line.
                boolean isSameEndYear = checkIfTwoDatesOfSameYear(date, endDate);
                dateString = getDateFormatForEventWithDifferentStartYear(date, endDate, isSameEndYear);
                TaskEntry taskEntry = new TaskEntry(taskCountFormatted.get(), task.getDescription(), dateString, task.isDone());
                addTaskWithDifferentYearToTaskList(task, date, taskEntry);
                break;
            }

            default: {
                System.out.println(MESSAGE_UNABLE_TO_DETERMINE_TYPE);
                break;
            }
        }
    }

    protected String getDateFormatForEventWithSameStartYear(Date date, Date endDate, boolean isSameEndYear) {
        String dateString;
        if (isSameEndYear) {
            if (checkIfStartAndEndSameDay(date, endDate)) {
                dateString = getSameYearSameDayEventDateFormat(date, endDate);
            } else {
                dateString = getSameYearDifferentDayEventDateFormat(date, endDate);
            }
        } else {
            dateString = getDifferentYearEventDateFormat(date, endDate);
        }
        return dateString;
    }

    protected String getDateFormatForEventWithDifferentStartYear(Date date, Date endDate, boolean isSameEndYear) {
        String dateString;
        if (isSameEndYear && checkIfStartAndEndSameDay(date, endDate)) {
            dateString = getDifferentYearSameDayEventDateFormat(date, endDate);
        } else {
            dateString = getDifferentYearEventDateFormat(date, endDate);
        }
        return dateString;
    }

    protected void addTaskWithDifferentYearToTaskList(Task task, Date date, TaskEntry taskEntry) {
        if (task.isDone()) {
            doneTaskList.getChildren().add(taskEntry.getEntryDisplay());
        } else if (date.before(today)) {
            overdueTaskList.getChildren().add(taskEntry.getEntryDisplay());
        } else {
            futureTaskList.getChildren().add(taskEntry.getEntryDisplay());
        }
    }

    /**
     * Iterates through the list of subcategories and find the corresponding date of the task to go into.
     * If it is unable to find one, it will add the task into the 'Future' category instead.
     * @param taskEntry to be added
     * @param date of the task due
     */
    private void addThisWeekTask(Task task, Date startDate, String taskCount) {
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(today);
        calendar.add(Calendar.DATE, 1);
        Date deadline = calendar.getTime();

        boolean isAdded = false;
        switch (task.getType()) {

            case DEADLINE: {
                TaskEntry taskEntry = new TaskEntry(taskCount,
                        task.getDescription(),
                        timeFormat.format(startDate),
                        task.isDone());
                addThisWeekTaskToTaskList(startDate, calendar, deadline, isAdded, taskEntry);
                break;
            }

            case EVENT: {
                Date endDate = ((Event) task).getEndDate();
                String dateString;
                boolean isSameEndYear = checkIfTwoDatesOfSameYear(endDate, today);
                dateString = getDateFormatForEventThisWeek(startDate, endDate, isSameEndYear);
                TaskEntry taskEntry = new TaskEntry(taskCount, task.getDescription(), dateString, task.isDone());
                addThisWeekTaskToTaskList(startDate, calendar, deadline, isAdded, taskEntry);
                break;
            }

            default:
                System.out.println(MESSAGE_UNABLE_TO_DETERMINE_TYPE);
                break;
        }
    }

    protected String getDateFormatForEventThisWeek(Date startDate, Date endDate, boolean isSameEndYear) {
        String dateString;
        if (isSameEndYear) {
            if (checkIfStartAndEndSameDay(startDate, endDate)) {
                dateString = getThisWeekSameDayEventDateFormat(startDate, endDate);
            } else if (endDate.before(endOfWeek)) {
            dateString = getThisWeekEndDifferentDayEventDateFormat(startDate, endDate);
            } else {
                dateString = getThisWeekEndDifferentWeekEventDateFormat(startDate, endDate);
            }
        } else {
            dateString = getThisWeekEndDifferentYearDateFormat(startDate, endDate);
        }
        return dateString;
    }

    protected void addThisWeekTaskToTaskList(Date startDate, Calendar calendar, Date deadline, boolean isAdded,
            TaskEntry taskEntry) {
        for (VBox vBox : upcomingSubcategories) {
            if (startDate.before(deadline)) {
                vBox.getChildren().add(taskEntry.getEntryDisplay());
                isAdded = true;
                break;
            } else {
                calendar.add(Calendar.DATE, 1);
                deadline = calendar.getTime();
            }
        }
        if (!isAdded) {
            futureTaskList.getChildren().add(taskEntry.getEntryDisplay());
        }
    }

    /**
     * Updates the display using fade transitions.
     * When the program is first initialised, all categories are faded in and shown.
     * After the user executes a command, empty categories are faded out and
     * non-empty categories are faded in.
     */
    protected void updateDisplay() {
        // Background image will be reset back to null after each update and changed to the
        // corresponding image set in the Child class after checking that there are no tasks left on screen.
        setMainVBoxBackgroundImage(mainVBox, FX_BACKGROUND_IMAGE_NULL);

        SequentialTransition sequentialTransition = new SequentialTransition();
        for (Node node : nodeList) {
            // Remove empty nodes if it is on screen, else add non-empty nodes back into screen.
            if (node.equals(upcomingNode)) {
                // Need to take care of special case with 'This Week' category
                ParallelTransition parallelTransition = new ParallelTransition();
                int totalTasksThisWeek = 0;
                for (int i=0; i<upcomingSubcategories.size(); i++) {
                    totalTasksThisWeek += upcomingSubcategories.get(i).getChildren().size();
                    addOrRemoveThisWeekSubcategories(parallelTransition, i);
                }
                // Next, to settle the main parent node for all the subcategories
                addOrRemoveThisWeekNode(sequentialTransition, parallelTransition, totalTasksThisWeek);
            // Next, settle all the other nodes
            } else if (((VBox) node.lookup(SELECTOR_CATEGORY_VBOX)).getChildren().isEmpty()) {
                removeNodeIfEmptyAndInDisplay(sequentialTransition, node);
            } else {
                addNodeIfNotEmptyAndNotInDisplay(sequentialTransition, node);
            }
        }
        sequentialTransition.setOnFinished(checkEmpty -> setBackgroundImageIfMainVBoxIsEmpty(mainVBox));
        sequentialTransition.play();
    }

    /**
     * Determines the correct position for each node to be added back to
     * @param node to be added
     */
    private void addNodeBackToScreen(Node node) {
        String nodeName = determineNodeName(node);
        switch (nodeName) {

            case CATEGORY_OVERDUE: {
                // Just need to add to the front
                mainVBox.getChildren().add(0, node);
                break;
            }

            case CATEGORY_UPCOMING: {
                if (mainVBox.getChildren().contains(overdueNode)) {
                    // Check if the 'Overdue' node is on screen or not and adds this node after it
                    mainVBox.getChildren().add(mainVBox.getChildren().indexOf(overdueNode) + 1, node);
                } else {
                    // Else this node would take precedence at the top.
                    mainVBox.getChildren().add(0, node);
                }
                break;
            }

            case CATEGORY_FUTURE: {
                if (mainVBox.getChildren().contains(overdueNode) && mainVBox.getChildren().contains(upcomingNode)) {
                    // Check if 'Overdue' and 'This Week' nodes are added before. This node takes position after them
                    mainVBox.getChildren().add(mainVBox.getChildren().indexOf(upcomingNode) + 1, node);
                } else if (mainVBox.getChildren().contains(overdueNode) && !mainVBox.getChildren().contains(upcomingNode)) {
                    // Then check if either one is available
                    mainVBox.getChildren().add(mainVBox.getChildren().indexOf(overdueNode) + 1, node);
                } else if (mainVBox.getChildren().contains(upcomingNode)) {
                    mainVBox.getChildren().add(mainVBox.getChildren().indexOf(upcomingNode) + 1, node);
                } else {
                    // Else it will go to the top
                    mainVBox.getChildren().add(0, node);
                }
                break;
            }

            case CATEGORY_DREAMS: {
                // Only needs to check if there is a lower node than it, where there is one 1 - doneNode.
                if (mainVBox.getChildren().contains(doneNode)) {
                    mainVBox.getChildren().add(mainVBox.getChildren().indexOf(doneNode), node);
                } else {
                    mainVBox.getChildren().add(node);
                }
                break;
            }

            case CATEGORY_DONE: {
                // Takes position at the bottom of the list
                mainVBox.getChildren().add(node);
                break;
            }

            default: {
                System.out.println(MESSAGE_UNABLE_TO_RECOGNISE_NODE);
                break;
            }
        }
    }

    private void addNodeIfNotEmptyAndNotInDisplay(SequentialTransition sequentialTransition, Node node) {
        if (!mainVBox.getChildren().contains(node)) {
            FadeTransition fadeIn = generateFadeInTransition(node, TIME_TRANSITION_CATEGORY_FADE_IN);
            addNodeBackToScreen(node);
            sequentialTransition.getChildren().add(fadeIn);
        }
    }

    private void addOrRemoveThisWeekNode(SequentialTransition sequentialTransition, ParallelTransition parallelTransition, int totalTasksThisWeek) {
        if (totalTasksThisWeek == 0 && mainVBox.getChildren().contains(upcomingNode)) {
            // If there are no tasks within all the subcategories, remove the node if it is contained in the mainVBox
            FadeTransition fadeOut = generateFadeOutTransition(upcomingNode, TIME_TRANSITION_CATEGORY_FADE_OUT);
            fadeOut.setOnFinished(done -> mainVBox.getChildren().remove(upcomingNode));
            sequentialTransition.getChildren().add(parallelTransition);
            sequentialTransition.getChildren().add(fadeOut);
        } else if (totalTasksThisWeek != 0 && !mainVBox.getChildren().contains(upcomingNode)){
            // Else if there are some tasks and yet it is not contained in the mainVBox, fade it in.
            FadeTransition fadeIn = generateFadeInTransition(upcomingNode, TIME_TRANSITION_CATEGORY_FADE_IN);
            addNodeBackToScreen(upcomingNode);
            sequentialTransition.getChildren().add(fadeIn);
        } else {
            // Else just fade the subcategories
            sequentialTransition.getChildren().add(parallelTransition);
        }
    }

    private void addOrRemoveThisWeekSubcategories(ParallelTransition parallelTransition, int i) {
        // Each element of subcategoryVisibilityTracker corresponds to the subcategory at a particular
        // index, '0' indicates visible/faded in and '1' indicates it has been faded out previously.
        if (upcomingSubcategories.get(i).getChildren().isEmpty()) {
            // 2 cases, either it has been faded in or not faded in previously.
            if (subcategoryVisibilityTracker[i] == 0) {
                // If faded out previously/not faded in yet, just remove away from the view
                upcomingTaskList.getChildren().remove(upcomingSubcategories.get(i).getParent());
            } else {
                // If faded in, set it up to fade out since it has been emptied.
                Node parentNode = upcomingSubcategories.get(i).getParent();
                FadeTransition fadeOut = generateFadeOutTransition(parentNode, TIME_TRANSITION_SUBCATEGORY_FADE_OUT);
                fadeOut.setOnFinished(done -> upcomingTaskList.getChildren().remove(parentNode));
                parallelTransition.getChildren().add(fadeOut);
                subcategoryVisibilityTracker[i] = 0;
            }
        } else if (!(upcomingSubcategories.get(i).getChildren().isEmpty()) && (subcategoryVisibilityTracker[i] == 0)) {
            // All non-empty and faded out should be faded back in.
            FadeTransition fadeIn = generateFadeInTransition(upcomingSubcategories.get(i).getParent(), TIME_TRANSITION_SUBCATEGORY_FADE_IN);
            parallelTransition.getChildren().add(fadeIn);
            subcategoryVisibilityTracker[i] = 1;
        } else {
            // Other cases can just ignore.
        }
    }

    private void removeNodeIfEmptyAndInDisplay(SequentialTransition sequentialTransition, Node node) {
        if (mainVBox.getChildren().contains(node)) {
            FadeTransition fadeOut = generateFadeOutTransition(node, TIME_TRANSITION_CATEGORY_FADE_OUT);
            fadeOut.setOnFinished(done -> mainVBox.getChildren().remove(node));
            sequentialTransition.getChildren().add(fadeOut);
        }
    }

    // ================================================================================
    // Utility methods
    // ================================================================================

    /**
     * Used when updating the task list, removes all tasks and resets the task counter
     */
    protected void clearTaskList() {
        resetTaskCount();
        resetTaskList();
        generateThisWeekSubcategories();
    }

    protected void getUpdatedDates() {
        updateDates();
        today = getToday();
        endOfWeek = getEndOfWeek();
        currentDate = getCurrentDate();
    }

    private String determineNodeName(Node node) {
        if (node.equals(overdueNode)) {
            return CATEGORY_OVERDUE;
        } else if (node.equals(upcomingNode)) {
            return CATEGORY_UPCOMING;
        } else if (node.equals(futureNode)) {
            return CATEGORY_FUTURE;
        } else {
            return CATEGORY_DREAMS;
        }
    }

    /**
     * Generates the relative date sub-headers for the remaining days of the week and places them
     * in the task list for 'This Week'.
     */
    private void generateThisWeekSubcategories() {
        LocalDateTime startingDateTime = getDateTimeStartOfToday();
        ArrayList<Node> thisWeekDateBoxes = new ArrayList<>();
        int count = 1;
        while (!(getInstantFromLocalDateTime(startingDateTime)).equals(endOfWeek.toInstant())) {
            DateBox newDateBox;
            if (count == 1) {
                newDateBox = new DateBox(SUBCATEGORY_TODAY);
            } else if (count == 2) {
                newDateBox = new DateBox(SUBCATEGORY_TOMORROW);
            } else {
                newDateBox = new DateBox(startingDateTime.getDayOfWeek().getDisplayName(TextStyle.FULL, Locale.getDefault()));
            }
            VBox newDateVBox = newDateBox.getTaskListVBox();
            upcomingSubcategories.add(newDateVBox);
            thisWeekDateBoxes.add(newDateBox.getDateBox());
            startingDateTime = startingDateTime.plusDays(1);
            count++;
        }
        if (subcategoryVisibilityTracker == null || (subcategoryVisibilityTracker.length != thisWeekDateBoxes.size())) {
            subcategoryVisibilityTracker = new int[thisWeekDateBoxes.size()];
        }
        upcomingTaskList.getChildren().addAll(thisWeekDateBoxes);
    }

    private void resetTaskCount() {
        taskCount.set(0);
    }

    private void resetTaskList() {
        overdueTaskList.getChildren().clear();
        upcomingTaskList.getChildren().clear();
        futureTaskList.getChildren().clear();
        dreamsTaskList.getChildren().clear();
        doneTaskList.getChildren().clear();

        upcomingSubcategories.clear();
    }
}
```
###### procrastinate\ui\SearchScreen.java
``` java
package procrastinate.ui;

import java.util.List;

import javafx.scene.control.Label;
import javafx.scene.layout.VBox;
import procrastinate.task.Task;

public class SearchScreen extends MultiCategoryScreen {

    // ================================================================================
    // Message strings
    // ================================================================================

    private static final String FX_BACKGROUND_IMAGE_NO_SEARCH_RESULTS = "-fx-background-image: url('/procrastinate/ui/images/no-search-results.png')";

    private static final String SEARCH_HEADER = "Search results for ";

    private static final String STYLE_SEARCH_HEADER_FONT_FAMILY = "-fx-font-family: 'Helvetica Neue';";
    private static final String STYLE_SEARCH_HEADER_FONT_WEIGHT = "-fx-font-weight: bold;";
    private static final String STYLE_SEARCH_HEADER_FONT_SIZE = "-fx-font-size: 18px;";

    // ================================================================================
    // Class variables
    // ================================================================================

    Label searchHeader = new Label();

    // ================================================================================
    // SearchScreen Constructor
    // ================================================================================

    protected SearchScreen(String filePath) {
        super(filePath);
        adjustStyles();
    }

    // ================================================================================
    // SearchScreen methods
    // ================================================================================

    @Override
    protected void updateTaskList(List<Task> taskList) {
        removeSearchHeaderLabel();
        getUpdatedDates();
        clearTaskList();

        for (Task task : taskList) {
            taskCount.set(taskCount.get() + 1);

            addTaskByType(task);
        }
        updateDisplay();
        addSearchHeaderLabel();
    }

    @Override
    protected void setBackgroundImageIfMainVBoxIsEmpty(VBox mainVBox) {
        if (mainVBox.getChildren().isEmpty()) {
            mainVBox.setStyle(FX_BACKGROUND_IMAGE_NO_SEARCH_RESULTS);
        }
    }

    protected void updateSearchStringLabel(String searchString) {
        searchHeader.setText(SEARCH_HEADER + searchString.trim());
    }

    private void removeSearchHeaderLabel() {
        if (mainVBox.getChildren().contains(searchHeader)) {
            mainVBox.getChildren().remove(searchHeader);
        }
    }

    private void addSearchHeaderLabel() {
        mainVBox.getChildren().add(0, searchHeader);
    }

    private void adjustStyles() {
        searchHeader.setWrapText(true);
        searchHeader.setFocusTraversable(false);
        searchHeader.setStyle(STYLE_SEARCH_HEADER_FONT_FAMILY
                            + STYLE_SEARCH_HEADER_FONT_WEIGHT
                            + STYLE_SEARCH_HEADER_FONT_SIZE);
    }
}
```
###### procrastinate\ui\SingleCategoryScreen.java
``` java
package procrastinate.ui;

import java.util.Date;

import javafx.animation.SequentialTransition;
import javafx.scene.Node;
import javafx.scene.layout.VBox;

public abstract class SingleCategoryScreen extends CenterScreen {

    // ================================================================================
    // Class variables
    // ================================================================================

    protected Node thisCategoryNode;
    protected VBox thisCategoryTaskList;

    protected Date today;

    protected VBox mainVBox;

    private String headerName;

    // ================================================================================
    // Animation Values
    // ================================================================================
    // Time values used are in milliseconds
//  private static final int TIME_TRANSITION_FADE = 250;

    // ================================================================================
    // SingleCategoryScreen Constructor
    // ================================================================================

    protected SingleCategoryScreen(String filePath, String headerName) {
        super(filePath);
        createCategories(headerName);
        retrieveFxmlElements();
    }

    // ================================================================================
    // Screen Transition methods
    // ================================================================================

    @Override
    protected SequentialTransition getScreenSwitchOutSequence() {
        SequentialTransition sequentialTransition = new SequentialTransition();
//        sequentialTransition.getChildren().add(generateFadeOutTransition(doneNode, TIME_TRANSITION_FADE));
        return sequentialTransition;
    }

    @Override
    protected SequentialTransition getScreenSwitchInSequence() {
        SequentialTransition sequentialTransition = new SequentialTransition();
//        sequentialTransition.getChildren().add(generateFadeInTransition(doneNode, TIME_TRANSITION_FADE));
        return sequentialTransition;
    }

    // ================================================================================
    // Init methods
    // ================================================================================

    @Override
    protected void createCategories() {
        CategoryBox categoryBox = new CategoryBox(headerName);
        this.thisCategoryNode = categoryBox.getCategoryBox();
        this.thisCategoryTaskList = categoryBox.getTaskListVBox();
    }

    private void createCategories(String headerName) {
        this.headerName = headerName;
        createCategories();
    }

    private void retrieveFxmlElements() {
        this.mainVBox = getMainVBox();
    }

    // ================================================================================
    // Utility methods
    // ================================================================================

    /**
     * Used when updating the task list, removes all tasks and resets the task counter
     */
    protected void clearTaskList() {
        taskCount.set(0);
        mainVBox.getChildren().clear();
        thisCategoryTaskList.getChildren().clear();
    }

    protected void getUpdatedDates() {
        updateDates();
        today = getToday();
    }
}
```
###### procrastinate\ui\SplashOverlay.java
``` java
package procrastinate.ui;

import javafx.geometry.Pos;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import javafx.scene.text.TextAlignment;

public class SplashOverlay extends ImageOverlay {

    // ================================================================================
    // Message strings
    // ================================================================================

    private static final String ID_SUBTITLE_LABEL = "subtitleLabel";
    private static final String ID_TITLE_LABEL = "titleLabel";

    private static final String LOCATION_SPLASH_IMAGE = "images/icon.png";

    private static final String MESSAGE_SUBTITLE = "What would you like to Procrastinate today?";
    private static final String MESSAGE_WELCOME = "Welcome to Procrastinate!";

    // ================================================================================
    // Class variables
    // ================================================================================

    private Label subtitleLabel;
    private Label titleLabel;

    // ================================================================================
    // SplashOverlay Constructor
    // ================================================================================

    protected SplashOverlay (){
        setImage();
        createLabels();
        setLabels();
        addLabels();
    }

    // ================================================================================
    // SplashOverlay methods
    // ================================================================================

    @Override
    protected void setImage() {
        imageView.setImage(new Image(ImageOverlay.class.getResource(LOCATION_SPLASH_IMAGE).toExternalForm()));
    }

    private void createLabels() {
        titleLabel = new Label(MESSAGE_WELCOME);
        subtitleLabel = new Label(MESSAGE_SUBTITLE);
    }

    /**
     * Sets the alignment and positioning of the Labels to be placed under the icon image
     * used in the splash screen. Both labels also have their IDs updated for the CSS styling
     * to be applied.
     */
    private void setLabels() {
        titleLabel.setAlignment(Pos.CENTER);
        titleLabel.setTextAlignment(TextAlignment.CENTER);
        titleLabel.setId(ID_TITLE_LABEL);

        subtitleLabel.setId(ID_SUBTITLE_LABEL);

        VBox.setVgrow(titleLabel, Priority.ALWAYS);
        VBox.setVgrow(subtitleLabel, Priority.ALWAYS);
    }

    private void addLabels() {
        container.getChildren().addAll(titleLabel, subtitleLabel);
    }
}
```
###### procrastinate\ui\SummaryScreen.java
``` java
package procrastinate.ui;

import java.util.List;

import javafx.geometry.Pos;
import javafx.scene.control.Label;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import procrastinate.task.Task;

public class SummaryScreen extends MultiCategoryScreen {

    // ================================================================================
    // Message strings
    // ================================================================================

    private static final int CATEGORY_MAX_CHILD_DREAMS = 2;
    private static final int CATEGORY_MAX_CHILD_FUTURE = 2;
    private static final int CATEGORY_MAX_CHILD_OVERDUE = 3;
    private static final int CATEGORY_MAX_CHILD_UPCOMING = 2;

    private static final int UPCOMING_SUBCATEGORY_ONE_MAX_CHILD = 3;
    private static final int UPCOMING_SUBCATEGORY_TWO_MAX_CHILD = 2;

    private static final int MAX_SUMMARY_COUNT = 21;
    private static final int SUMMARY_HEADER_SIZE_COUNT = 2;
    private static final int SUMMARY_NORMAL_SIZE_COUNT = 1;

    private static final int SINGLE_LINE_DESCRIPTION_COUNT = 25;
    private static final int POSITION_DESCRIPTION_STRING = 1;
    private static final int POSITION_TIME_STRING = 2;

    private static final String ELLIPSIS_STRING = "... ";
    private static final String ELLIPSIS_MESSAGE_TASKS_HIDDEN = " tasks hidden ...";
    private static final String ELLIPSIS_MESSAGE_TASK_HIDDEN = " task hidden ...";

    private static final String FX_BACKGROUND_IMAGE_NO_TASKS = "-fx-background-image: url('/procrastinate/ui/images/no-summary.png')";

    private static final String LINE_BREAK = "\n";
    // ================================================================================
    // Class variables
    // ================================================================================

    private int summaryCount;

    // ================================================================================
    // SummaryScreen Constructor
    // ================================================================================

    protected SummaryScreen(String filePath) {
        super(filePath);
    }

    // ================================================================================
    // SummaryScreen methods
    // ================================================================================

    @Override
    protected void updateTaskList(List<Task> taskList) {
        getUpdatedDates();
        clearTaskList();

        for (Task task : taskList) {
            taskCount.set(taskCount.get() + 1);

            addTaskByType(task);
        }
        updateDisplay();
        setupSummaryView(taskList);
    }

    @Override
    protected void setBackgroundImageIfMainVBoxIsEmpty(VBox mainVBox) {
        if (mainVBox.getChildren().isEmpty()) {
            mainVBox.setStyle(FX_BACKGROUND_IMAGE_NO_TASKS);
        }
    }

    /**
     * Shows the summary view that limits the number of tasks in each category
     * The exact number of lines given to each category is declared as a final
     * int variable.
     *
     * @param taskList
     *            to build the summary view from
     */
    private void setupSummaryView(List<Task> taskList) {
        // Summary count is reset at each call just in case the screen is reused.
        // It is used to check how much the 'Upcoming' category should be summarised.
        summaryCount = MAX_SUMMARY_COUNT;

        if (mainVBox.getChildren().contains(overdueNode)) {
            adjustMaxChildInCategory(overdueTaskList, CATEGORY_MAX_CHILD_OVERDUE);
        }

        if (mainVBox.getChildren().contains(futureNode)) {
            adjustMaxChildInCategory(futureTaskList, CATEGORY_MAX_CHILD_FUTURE);
        }

        if (mainVBox.getChildren().contains(dreamsNode)) {
            adjustMaxChildInCategory(dreamsTaskList, CATEGORY_MAX_CHILD_DREAMS);
        }

        if (mainVBox.getChildren().contains(upcomingNode)) {
            adjustUpcomingCategoryChildren();
        }
    }

    /**
     * Used for all other categories except 'Upcoming'. The exact number of
     * lines given to each category is passed in as maxChildSize.
     *
     * @param categoryTaskList
     *            the category's VBox to be summarised
     * @param maxChildSize
     *            int declared to take into account the number of lines each
     *            category should have.
     */
    private void adjustMaxChildInCategory(VBox categoryTaskList, int maxChildSize) {
        int numTaskLeft;
        summaryCount -= SUMMARY_HEADER_SIZE_COUNT;
        if (categoryTaskList.getChildren().size() > maxChildSize) {
            numTaskLeft = categoryTaskList.getChildren().size();

            categoryTaskList.getChildren().remove(maxChildSize, categoryTaskList.getChildren().size());
            checkForMultiLineEvents(categoryTaskList);
            numTaskLeft -= categoryTaskList.getChildren().size();

            HBox ellipsis = buildEllipsis(numTaskLeft);
            categoryTaskList.getChildren().add(ellipsis);
            summaryCount -= SUMMARY_NORMAL_SIZE_COUNT;
        }
        summaryCount -= categoryTaskList.getChildren().size() * SUMMARY_NORMAL_SIZE_COUNT;
    }

    /**
     * Used specially for the 'Upcoming' category to limit its number of
     * subcategories to at most 2. The number of lines given to each subcategory
     * can be different and is declared above as a final int. The first subcategory
     * shown will have its own ellipsis while the second will share one with all
     * other subcategories.
     */
    private void adjustUpcomingCategoryChildren() {
        int totalSubcategoryDisplayed = 0;
        int totalTasksInSubcategories = 0;
        checkUpcomingSubcategoriesAndTasks(totalSubcategoryDisplayed, totalTasksInSubcategories);
        if (summaryCount < -3) {
            // Only summarise the view in this category if the number is less
            // than -3. Else it should still fit on screen.
            int subcategoryCount = 0;
            int numTaskLeft = 0;
            int indexToRemoveFrom = -1;
            int firstSubcategoryIndex = -1;
            int secondSubcategoryIndex = -1;

            for (int i = 0; i < upcomingSubcategories.size(); i++) {
                VBox currSubcategory = upcomingSubcategories.get(i);
                if ((subcategoryCount == CATEGORY_MAX_CHILD_UPCOMING) && (currSubcategory.getChildren().size() > 0)) {
                    numTaskLeft += currSubcategory.getChildren().size();
                    if (indexToRemoveFrom == -1) {
                        indexToRemoveFrom = i;
                    }
                    continue;
                }

                if (currSubcategory.getChildren().size() > 0) {
                    subcategoryCount++;
                    // Keep track of the index for retrieval later on
                    if (firstSubcategoryIndex == -1) {
                        firstSubcategoryIndex = i;
                    } else if ((firstSubcategoryIndex != -1) && (secondSubcategoryIndex == -1)) {
                        secondSubcategoryIndex = i;
                    }
                }
            }

            // Adjust the first and second subcategory if they are available.
            numTaskLeft = adjustSecondSubcategoryChildren(subcategoryCount, numTaskLeft, secondSubcategoryIndex);
            adjustFirstSubcategoryChildren(subcategoryCount, firstSubcategoryIndex);

            // Removes the third subcategory onwards if available.
            if (indexToRemoveFrom != -1) {
                upcomingTaskList.getChildren().remove(indexToRemoveFrom, upcomingTaskList.getChildren().size());
            }

            HBox ellipsis = buildEllipsis(numTaskLeft);
            upcomingTaskList.getChildren().add(ellipsis);
        }
    }

    private int adjustSecondSubcategoryChildren(int subcategoryCount, int numTaskLeft, int secondSubcategoryIndex) {
        if (subcategoryCount > 1) {
            VBox secondSubcategory = upcomingSubcategories.get(secondSubcategoryIndex);
            if (secondSubcategory.getChildren().size() > UPCOMING_SUBCATEGORY_TWO_MAX_CHILD) {
                numTaskLeft += secondSubcategory.getChildren().size();
                secondSubcategory.getChildren().remove(UPCOMING_SUBCATEGORY_TWO_MAX_CHILD,
                        secondSubcategory.getChildren().size());
                checkForMultiLineEvents(secondSubcategory);
                numTaskLeft -= secondSubcategory.getChildren().size();
            }
        }
        return numTaskLeft;
    }

    private void adjustFirstSubcategoryChildren(int subcategoryCount, int firstSubcategoryIndex) {
        if (subcategoryCount > 0) {
            VBox firstSubcategory = upcomingSubcategories.get(firstSubcategoryIndex);
            if (firstSubcategory.getChildren().size() > UPCOMING_SUBCATEGORY_ONE_MAX_CHILD) {
                int firstSubcategoryTaskLeft = 0;
                firstSubcategoryTaskLeft += firstSubcategory.getChildren().size();
                firstSubcategory.getChildren().remove(UPCOMING_SUBCATEGORY_ONE_MAX_CHILD,
                        firstSubcategory.getChildren().size());
                checkForMultiLineEvents(firstSubcategory);
                firstSubcategoryTaskLeft -= firstSubcategory.getChildren().size();

                HBox ellipsis = buildEllipsis(firstSubcategoryTaskLeft);
                firstSubcategory.getChildren().add(ellipsis);
            }
        }
    }

    /**
     * Counts the total number of tasks and subcategories available in the
     * current display to determine if the category should be summarised.
     *
     * @param totalSubcategoryDisplayed
     * @param totalTasksInSubcategories
     */
    private void checkUpcomingSubcategoriesAndTasks(int totalSubcategoryDisplayed, int totalTasksInSubcategories) {
        for (int i = 0; i < upcomingSubcategories.size(); i++) {
            VBox currSubcategory = upcomingSubcategories.get(i);
            if (currSubcategory.getChildren().size() > 0) {
                totalSubcategoryDisplayed++;
                totalTasksInSubcategories += currSubcategory.getChildren().size();
            }
        }
        summaryCount -= totalSubcategoryDisplayed * SUMMARY_HEADER_SIZE_COUNT;
        summaryCount -= totalTasksInSubcategories * SUMMARY_NORMAL_SIZE_COUNT;
    }

    private void checkForMultiLineEvents(VBox categoryTaskList) {
        // Check for events that spans 2 lines
        boolean isMultiLineEventFound = false;
        for (int i = 0; i < categoryTaskList.getChildren().size(); i++) {
            if (((GridPane) categoryTaskList.getChildren().get(i)).getChildren().get(POSITION_TIME_STRING).toString()
                    .contains(LINE_BREAK)) {
                isMultiLineEventFound = true;
                break;
            } else if (((GridPane) categoryTaskList.getChildren().get(i)).getChildren().get(POSITION_DESCRIPTION_STRING)
                    .toString().length() > SINGLE_LINE_DESCRIPTION_COUNT) {
                isMultiLineEventFound = true;
                break;
            }
        }
        if (isMultiLineEventFound) {
            // Remove the last task found
            categoryTaskList.getChildren().remove(categoryTaskList.getChildren().size() - 1);
        }
    }

    private HBox buildEllipsis(int numTaskLeft) {
        String message = ELLIPSIS_STRING + numTaskLeft;
        if (numTaskLeft > 1) {
            message += ELLIPSIS_MESSAGE_TASKS_HIDDEN;
        } else {
            message += ELLIPSIS_MESSAGE_TASK_HIDDEN;
        }
        Label ellipsisMessage = new Label(message);
        HBox ellipsisBox = new HBox(ellipsisMessage);
        ellipsisBox.setAlignment(Pos.CENTER);
        return ellipsisBox;
    }
}
```
###### procrastinate\ui\TaskEntry.java
``` java
package procrastinate.ui;

import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;

import java.io.IOException;

public class TaskEntry extends GridPane {

    // ================================================================================
    // Message strings
    // ================================================================================

    private static final String EMPTY_STRING = "";

    private static final String LOCATION_TASK_ENTRY_FXML = "views/TaskEntry.fxml";
    private static final String LOCATION_TICK_IMAGE = "images/tick.png";

    private static final String STYLE_TICK_CENTERING_PADDING = "-fx-padding: 4 5 0 0;";
    private static final String STYLE_REMOVE_PADDING = "-fx-padding: 0;";

    // ================================================================================
    // Class variables
    // ================================================================================

    private Node taskEntry;

    // ================================================================================
    // FXML field variables
    // ================================================================================

    @FXML private Label lineNum;
    @FXML private Label description;
    @FXML private Label time;

    // ================================================================================
    // TaskEntry methods
    // ================================================================================

    /**
     * Constructor to be used for displaying "DREAMS"
     * @param lineNum
     * @param description
     */
    protected TaskEntry(String lineNum, String description, boolean isDone) {
        loadLayout();
        if (isDone) {
            addTickBeforeLineNumber();
        }
        setLabels(lineNum, description, EMPTY_STRING);
    }

    /**
     * Constructor to be used for displaying all other TaskTypes
     * @param lineNum
     * @param description
     */
    protected TaskEntry(String lineNum, String description, String time, boolean isDone) {
        loadLayout();
        if (isDone) {
            addTickBeforeLineNumber();
        }
        setLabels(lineNum, description, time);
    }

    private void loadLayout() {
        FXMLLoader loader = new FXMLLoader(getClass().getResource(LOCATION_TASK_ENTRY_FXML));
        loader.setController(this); // Required due to different package declaration from Main
        try {
            this.taskEntry = loader.load();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void setLabels(String lineNum, String description, String time) {
        this.lineNum.setText(lineNum);
        this.description.setText(description);
        this.time.setText(time);
        if (time.equals(EMPTY_STRING)) {
            this.time.setMinWidth(0);
            this.time.setStyle(STYLE_REMOVE_PADDING);
        }
    }

    private void addTickBeforeLineNumber() {
        HBox lineNumberWrapper = getLabelWrapper();
        HBox tickWrapper = getTickWrapper();
        addTickAndLabelToTaskEntry(lineNumberWrapper, tickWrapper);
    }

    private void addTickAndLabelToTaskEntry(HBox lineNumberWrapper, HBox checkBoxWrapper) {
        HBox combinedWrapper = new HBox(checkBoxWrapper, lineNumberWrapper);
        ((GridPane)taskEntry).add(combinedWrapper, 0, 0);
    }

    private ImageView createNewTick() {
        ImageView tickImage = new ImageView();
        tickImage.setImage(new Image(TaskEntry.class.getResource(LOCATION_TICK_IMAGE).toExternalForm()));
        tickImage.setFocusTraversable(false);
        tickImage.setSmooth(true);
        tickImage.setFitHeight(10);
        tickImage.setFitWidth(10);
        return tickImage;
    }

    private HBox createTickWrapper(ImageView tick) {
        HBox tickWrapper = new HBox(tick);
        tickWrapper.setSpacing(0);
        tickWrapper.setStyle(STYLE_TICK_CENTERING_PADDING);
        return tickWrapper;
    }

    private HBox createLabelWrapper(Label lineNumberLabel) {
        HBox lineNumberWrapper = new HBox(lineNumberLabel);
        lineNumberWrapper.setSpacing(0);
        return lineNumberWrapper;
    }

    private HBox getTickWrapper() {
        ImageView tick = createNewTick();
        return createTickWrapper(tick);
    }

    private HBox getLabelWrapper() {
        Label lineNumberLabel = getLabelAndRemovePadding();
        return createLabelWrapper(lineNumberLabel);
    }

    private Label getLabelAndRemovePadding() {
        Label lineNumberLabel = (Label) ((GridPane)taskEntry).getChildren().get(0);
        lineNumberLabel.setStyle(STYLE_REMOVE_PADDING);
        return lineNumberLabel;
    }

    // ================================================================================
    // Getter methods
    // ================================================================================
```
###### procrastinate\ui\UI.java
``` java
package procrastinate.ui;

import javafx.beans.property.BooleanProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import javafx.beans.value.ChangeListener;
import javafx.event.EventHandler;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyEvent;
import javafx.stage.Stage;
import procrastinate.task.Task;

import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

public class UI {

    public static enum ScreenView {
        SCREEN_DONE, SCREEN_MAIN, SCREEN_SEARCH
    }

    private static final Logger logger = Logger.getLogger(UI.class.getName());

    private static boolean showTray = true;

    // ================================================================================
    // Message strings
    // ================================================================================

    private static final String DEBUG_UI_INIT = "UI initialised.";
    private static final String DEBUG_UI_LOAD = "View is now loaded!";

    // ================================================================================
    // Class variables
    // ================================================================================

    private Stage primaryStage;

    private CenterPaneController centerPaneController;
    private DialogPopupHandler dialogPopupHandler;
    private WindowHandler windowHandler;

    private BooleanProperty isExit = new SimpleBooleanProperty(false);

    private StringProperty userInput = new SimpleStringProperty();
    private StringProperty statusLabelText = new SimpleStringProperty();

    // ================================================================================
    // UI methods
    // ================================================================================

    protected UI() {
    }

    public UI(Stage stage) {
        assert(stage != null);
        primaryStage = stage;
        initWindow();
        initDialogPopupHandler();
        initTaskDisplay();
        setupBinding();
        setupAndShowStage();
        logger.log(Level.INFO, DEBUG_UI_INIT);
    }

    // Retrieves the current user input from the TextField.
    public String getInput() {
        return userInput.get();
    }

    public void setInput(String input) {
        userInput.set(input);
        getUserInputField().end();
    }

    public void clearInput() {
        getUserInputField().clear();
    }

    // Sets the text of the 'Status' Label directly.
    public void setStatus(String status) {
        statusLabelText.set(status);
    }

    public void updateTaskList(List<Task> taskList, ScreenView screenView) {
        centerPaneController.updateScreen(taskList, screenView);
    }

    public BooleanProperty getIsExit() {
        return isExit;
    }

    // Attaches KeyHandler and Listener to the TextField to dynamically update the 'Status' Label upon input.
    public void attachHandlersAndListeners(EventHandler<KeyEvent> keyReleaseHandler, EventHandler<KeyEvent> keyPressHandler,
            ChangeListener<String> userInputListener, ChangeListener<Boolean> isExitListener) {
        TextField userInputField = getUserInputField();
        userInputField.setOnKeyReleased(keyReleaseHandler);
        userInputField.setOnKeyPressed(keyPressHandler);
        userInputField.textProperty().addListener(userInputListener);
        isExit.addListener(isExitListener);
    }

    // ================================================================================
    // CenterPaneController methods
    // ================================================================================

    public void passSearchStringToSearchScreen(String searchString) {
        centerPaneController.receiveSearchStringAndPassToSearchScreen(searchString);
    }

    public void showHelpOverlay() {
        centerPaneController.showHelpOverlay();
    }

    public void nextHelpPage() {
        centerPaneController.nextHelpPage();
    }

    private void showSplashOverlay() {
        centerPaneController.showSplashOverlay();
    }

    public void hideHelpOverlay() {
        centerPaneController.hideHelpOverlay();
    }

    public void hideSplashOverlay() {
        centerPaneController.hideSplashOverlay();
    }

    // ================================================================================
    // DialogPopupHandler methods
    // ================================================================================

    /**
     * Used by Logic to create an Error Dialog with a given message in the popup body
     * @param message to be shown in popup body
     */
    public void createErrorDialog(String message) {
        dialogPopupHandler.createErrorDialogPopup(message);
    }

    /**
     * Used by Logic to create an Error Dialog that displays the Exception message and its stack trace
     * @param e Exception whose trace should be shown
     */
    public void createErrorDialogWithTrace(Exception e) {
        dialogPopupHandler.createErrorDialogPopupWithTrace(e);
    }

    /**
     * Used by Logic to create an Error Dialog with a given message and
     * choice for confirmation: 'OK' or 'Cancel'
     * @param message to be shown in popup body
     * @return true if 'OK', false if 'Cancel'
     */
    public boolean createErrorDialogWithConfirmation(String message) {
        return dialogPopupHandler.createErrorDialogPopupWithConfirmation(message);
    }

    // ================================================================================
    // Init methods
    // ================================================================================

    private void initWindow() {
        windowHandler = new WindowHandler(primaryStage);
        windowHandler.loadWindowConfigurations(showTray);
    }

    private void initDialogPopupHandler() {
        dialogPopupHandler = new DialogPopupHandler(primaryStage);
    }

    /**
     * Sets up controller for center pane and overlays a splash screen on top of the main screen display.
     */
    private void initTaskDisplay() {
        this.centerPaneController = new CenterPaneController(windowHandler.getCenterScreen());
    }

    private void setupBinding() {
        assert(windowHandler != null);
        windowHandler.bindAsExitIndicator(isExit);

        userInput.bindBidirectional(windowHandler.getUserInputField().textProperty());
        statusLabelText.bindBidirectional(windowHandler.getStatusLabel().textProperty());
    }

    private void setupAndShowStage() {
        assert(primaryStage != null);
        primaryStage.show();
        showSplashOverlay();
        logger.log(Level.INFO, DEBUG_UI_LOAD);
    }

    // ================================================================================
    // Utility methods
    // ================================================================================

    private TextField getUserInputField() {
        return windowHandler.getUserInputField();
    }

}
```
###### procrastinate\ui\UITestHelper.java
``` java
package procrastinate.ui;

import java.util.ArrayList;
import java.util.List;

import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import procrastinate.task.Dream;
import procrastinate.task.Task;

public class UITestHelper {

    // Some test variables that are utilised multiple times in a test body
    public CenterPaneController centerPaneController;
    public MultiCategoryScreen mainScreen;
    public TaskEntry dreamTask;
    public TaskEntry otherTask;

    // ================================================================================
    // CenterPaneController methods
    // ================================================================================

    public CenterPaneController getNewCenterPaneController(StackPane stackPane) {
        centerPaneController = new CenterPaneController(stackPane);
        return  centerPaneController;
    }

    public ImageOverlay getCPCCurrentScreen() {
        return centerPaneController.currentOverlay;
    }

    public void switchToMain() {
//        centerPaneController.changeScreen(CenterPaneController.SCREEN_MAIN);
    }

    public Node getMainScreen() {
        return centerPaneController.getMainScreen();
    }

    public void switchToHelp() {
//        centerPaneController.changeScreen(CenterPaneController.SCREEN_HELP);
    }

    public Node getHelpScreen() {
        return centerPaneController.getHelpOverlay();
    }

    // ================================================================================
    // HelpScreen methods
    // ================================================================================

    public ImageOverlay getNewHelpScreen() {
        return new HelpOverlay();
    }

    // ================================================================================
    // MainScreen methods
    // ================================================================================

    public MultiCategoryScreen getNewMainScreen() {
        mainScreen = new MainScreen("views/CenterScreen.fxml");
        return mainScreen;
    }

    public VBox getMainScreenVBox() {
        return mainScreen.getMainVBox();
    }

    public void addDreamToMainScreen(Dream dream) {
        List<Task> taskList = new ArrayList<>();
        taskList.add(dream);
        mainScreen.updateTaskList(taskList);
    }

    public VBox getDreamsTaskList() {
        // Dreams is the last category box added
        return (VBox) mainScreen.getMainVBox().getChildren().get(3);
    }

    // ================================================================================
    // CategoryBox methods
    // ================================================================================

    public CategoryBox getNewCategoryBox() {
        return new CategoryBox("Test");
    }

    public VBox getNewCategoryBoxVBox() {
        CategoryBox categoryBox = new CategoryBox("Test");
        return categoryBox.getTaskListVBox();
    }

    public Label getNewCategoryBoxLabel(String label) {
        CategoryBox categoryBox = new CategoryBox(label);
        return categoryBox.getCategoryLabel();
    }

    // ================================================================================
    // TaskEntry methods
    // ================================================================================

    public TaskEntry getNewDreamTaskEntry(String lineNum, String des) {
        dreamTask = new TaskEntry(lineNum, des, false);
        return dreamTask;
    }

    public Label getDreamTaskEntryLineNum() {
        return dreamTask.getLineNum();
    }

    public Label getDreamTaskEntryDescription() {
        return dreamTask.getDescription();
    }

    public TaskEntry getNewOthersTaskEntry(String lineNum, String des, String time) {
        otherTask = new TaskEntry(lineNum, des, time, false);
        return otherTask;
    }

    public Label getOthersTaskEntryLineNum() {
        return otherTask.getLineNum();
    }

    public Label getOthersTaskEntryDescription() {
        return otherTask.getDescription();
    }

    public Label getOthersTaskEntryTime() {
        return otherTask.getTime();
    }
}
```
###### procrastinate\ui\views\CategoryBox.fxml
``` fxml
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.VBox?>

<VBox maxHeight="1.7976931348623157E308" minHeight="-Infinity" styleClass="categoryBox" xmlns="http://javafx.com/javafx/8.0.40" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <Label fx:id="categoryLabel" text="Label" VBox.vgrow="ALWAYS" />
      <VBox fx:id="categoryVBox" maxHeight="1.7976931348623157E308" minHeight="-Infinity" VBox.vgrow="ALWAYS" />
   </children>
</VBox>
```
###### procrastinate\ui\views\CenterScreen.fxml
``` fxml
<?xml version="1.0" encoding="UTF-8"?>

<?import java.lang.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.control.ScrollPane?>
<?import javafx.scene.layout.VBox?>

<ScrollPane fx:id="scrollPane" fitToHeight="true" fitToWidth="true" focusTraversable="false" hbarPolicy="NEVER" style="-fx-background-color:white;" vbarPolicy="NEVER" xmlns="http://javafx.com/javafx/8.0.40" xmlns:fx="http://javafx.com/fxml/1">
	<content>
		<VBox fx:id="mainVBox" styleClass="centerScreen">
		</VBox>
	</content>
</ScrollPane>
```
###### procrastinate\ui\views\DateBox.fxml
``` fxml
<?xml version="1.0" encoding="UTF-8"?>

<?import java.lang.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.VBox?>

<VBox maxHeight="1.7976931348623157E308" minHeight="-Infinity" alignment="CENTER" styleClass="dateBox" xmlns="http://javafx.com/javafx/8.0.40" xmlns:fx="http://javafx.com/fxml/1">
    <children>
        <Label fx:id="dateLabel" text="Label" VBox.vgrow="ALWAYS" />
        <VBox fx:id="dateVBox" maxHeight="1.7976931348623157E308" minHeight="-Infinity" VBox.vgrow="ALWAYS" />
    </children>
</VBox>
```
###### procrastinate\ui\views\ImageOverlay.fxml
``` fxml
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.scene.control.Label?>
<?import javafx.scene.image.ImageView?>
<?import javafx.scene.layout.*?>

<StackPane styleClass="imageOverlay" xmlns="http://javafx.com/javafx/8.0.40" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <Region fx:id="overlay" />
      <VBox fx:id="container" >
          <children>
            <ImageView fx:id="imageView" nodeOrientation="INHERIT" pickOnBounds="true" preserveRatio="true" VBox.vgrow="ALWAYS" />
          </children>
      </VBox>
   </children>
</StackPane>
```
###### procrastinate\ui\views\MainWindowLayout.fxml
``` fxml
<?xml version="1.0" encoding="UTF-8"?>

<?import java.lang.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.ScrollPane?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.layout.*?>

<BorderPane fx:id="mainBorderPane" prefHeight="600.0" prefWidth="500.0" styleClass="mainWindow" xmlns="http://javafx.com/javafx/8.0.40" xmlns:fx="http://javafx.com/fxml/1">
    <bottom>
        <VBox fx:id="bottom" BorderPane.alignment="CENTER">
            <children>
                <TextField fx:id="userInputField" />
                <Label fx:id="statusLabel" />
            </children>
        </VBox>
    </bottom>
    <center>
          <StackPane fx:id="centerScreen">
                </StackPane>
    </center>
</BorderPane>
```
###### procrastinate\ui\views\procrastinate.css
``` css
/*
 * ================================================================
 * Font Declarations
 * ================================================================
 */
@font-face {
	font-family: "Helvetica Neue";
	font-style: bold;
	src: url("/procrastinate/ui/fonts/helvetica-neue-bold.ttf");
}

@font-face {
	font-family: Titillium;
	font-style: normal;
	src: url("/procrastinate/ui/fonts/titillium/Titillium-Regular.otf");
}

@font-face {
	font-family: FontAwesome;
	font-weight: 400;
	font-style: normal;
	src: url("/procrastinate/ui/fonts/FontAwesome.otf");
}

/*
 * ================================================================
 * MainWindow Styling
 * ================================================================
 */
.root {
}

.mainWindow {
    -fx-background-color: transparent;
    -fx-focus-color: #365fac;
}

.mainWindow #mainBorderPane {
  -fx-effect: dropshadow( gaussian, derive(lightslategray, -20%), 10, 0, 3, 3);
  -fx-alignment: center;
  -fx-border-color: white;
  -fx-border-width: 5;
  -fx-border-insets: 10;
  -fx-border-radius: 6;
}

.mainWindow #bottom {
    -fx-font-family: Titillium;
    -fx-background-color: white;
    -fx-padding: 2 10 2 10;
    -fx-spacing: 2;
}

.mainWindow #userInputField {
    -fx-font-size: 18px;
}

.mainWindow #statusLabel {
    -fx-font-size: 16px;
}

.mainWindow #top {
    -fx-background-color: white;
}

/*
 * ================================================================
 * ImageOverlay Styling
 * ================================================================
 */
.imageOverlay #container {
    -fx-alignment: center;
    -fx-padding: 10 0 0 0;
    -fx-spacing: 10;
}

.imageOverlay #overlay {
    -fx-background-color: white;
    -fx-opacity: 0.5;
}

.imageOverlay #titleLabel {
    -fx-font-family: "Helvetica Neue";
    -fx-font-weight: bold;
    -fx-font-size: 24px;
}

.imageOverlay #subtitleLabel {
    -fx-font-family: Titillium;
}

/*
 * ================================================================
 * CenterScreen Styling
 * ================================================================
 */
.centerScreen {
    -fx-background-color: white;
    -fx-padding: 10;
    -fx-spacing: 5;
}

#mainVBox {
    -fx-background-position: center center;
    -fx-background-repeat: no-repeat;
    -fx-background-size: contain;
}

/*
 * ================================================================
 * CategoryBox Styling
 * ================================================================
 */
.categoryBox #categoryLabel {
    -fx-font-family: "Helvetica Neue";
	-fx-font-weight: bold;
	-fx-font-size: 20px;
	-fx-text-fill: #365fac;
}

.categoryBox #categoryVBox {
    -fx-padding: 0 0 0 5;
}

/*
 * ================================================================
 * DateBox Styling
 * ================================================================
 */
.dateBox #dateLabel {
    -fx-font-family: "Helvetica Neue";
	-fx-font-weight: bold;
	-fx-font-size: 16px;
	-fx-text-fill: #455a64;
}

.dateBox #dateVBox {
    -fx-padding: 0 0 0 0;
}

/*
 * ================================================================
 * TaskEntry Styling
 * ================================================================
 */
.taskEntry {
    -fx-font-family: Titillium;
    -fx-font-size: 16px;
    -fx-padding: 0 0 5 0;
}

.taskEntry #lineNum {
    -fx-font-family: "Helvetica Neue";
    -fx-font-size: 14px;
    -fx-font-weight: bold;
    -fx-padding: 0 5 0 15;
}

.taskEntry #description {
    -fx-wrap-text: true;
}

.taskEntry #time {
    -fx-font-family: "Helvetica Neue";
    -fx-font-size: 13px;
    -fx-font-weight: bold;
    -fx-padding: 0 0 0 25;
    -fx-wrap-text: true;
}

/*
 * ================================================================
 * TitleBar Styling
 * ================================================================
 */

.titleBar {
    -fx-background-color: white;
    -fx-font: 16px FontAwesome;
}

.titleBar #title {
	-fx-font-family: "Helvetic Neue";
	-fx-font-size: 16px;
	-fx-font-weight: bold;
}

.titleBar #close {
    -fx-label-padding: 0 0 0 10;
}
```
###### procrastinate\ui\views\TaskEntry.fxml
``` fxml
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.control.*?>
<?import java.lang.*?>
<?import javafx.scene.layout.*?>

<GridPane maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" styleClass="taskEntry" xmlns="http://javafx.com/javafx/8.0.40" xmlns:fx="http://javafx.com/fxml/1">
<columnConstraints>
   <ColumnConstraints halignment="LEFT" hgrow="SOMETIMES" maxWidth="1.7976931348623157E308" minWidth="50" />
   <ColumnConstraints halignment="LEFT" hgrow="ALWAYS" />
   <ColumnConstraints halignment="RIGHT" hgrow="SOMETIMES" maxWidth="1.7976931348623157E308" minWidth="-Infinity" />
</columnConstraints>
<rowConstraints>
   <RowConstraints vgrow="ALWAYS" />
</rowConstraints>
<children>
   <Label fx:id="lineNum" text="Label" GridPane.halignment="LEFT" GridPane.valignment="TOP" />
   <Label fx:id="description" text="Label" wrapText="true" GridPane.columnIndex="1" GridPane.halignment="LEFT" GridPane.valignment="TOP" />
   <Label fx:id="time" text="Label" textAlignment="RIGHT" GridPane.columnIndex="2" GridPane.halignment="RIGHT" GridPane.valignment="TOP" />
</children>
</GridPane>
```
###### procrastinate\ui\views\TitleBar.fxml
``` fxml
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.geometry.*?>
<?import javafx.scene.image.*?>
<?import javafx.scene.*?>
<?import javafx.scene.control.*?>
<?import java.lang.*?>
<?import javafx.scene.layout.*?>

<HBox styleClass="titleBar" xmlns="http://javafx.com/javafx/8.0.40" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <HBox HBox.hgrow="ALWAYS">
         <children>
            <ImageView fitHeight="20.0" fitWidth="20.0" pickOnBounds="true" preserveRatio="true">
               <image>
                  <Image url="/procrastinate/ui/images/icon.png" />
               </image>
            </ImageView>
         </children>
      </HBox>
      <HBox alignment="TOP_CENTER" HBox.hgrow="ALWAYS">
         <children>
            <Label fx:id="title" alignment="TOP_CENTER" focusTraversable="false" text="Procrastinate" />
         </children>
         <HBox.margin>
            <Insets left="25.0" />
         </HBox.margin>
      </HBox>
      <HBox alignment="TOP_RIGHT" HBox.hgrow="ALWAYS">
         <children>
            <Label fx:id="minimise" focusTraversable="false" text="Minimise">
               <cursor>
                  <Cursor fx:constant="HAND" />
               </cursor>
            </Label>
            <Label fx:id="close" focusTraversable="false" text="Close">
               <cursor>
                  <Cursor fx:constant="HAND" />
               </cursor>
            </Label>
         </children>
      </HBox>
   </children>
</HBox>
```
###### procrastinate\ui\WindowHandler.java
``` java
package procrastinate.ui;

import javafx.beans.property.BooleanProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.image.Image;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;
import javafx.stage.StageStyle;

import java.awt.SystemTray;
import java.io.IOException;

public class WindowHandler {

    // ================================================================================
    // Fixed variables
    // ================================================================================

    private static final String LOCATION_CSS_STYLESHEET = "views/procrastinate.css";
    private static final String LOCATION_MAIN_WINDOW_LAYOUT = "views/MainWindowLayout.fxml";
    private static final String LOCATION_TITLE_BAR_FXML = "views/TitleBar.fxml";
    private static final String LOCATION_WINDOW_ICON = "images/icon.png";

    private static final String WINDOW_TITLE = "Procrastinate";
    private static final double WINDOW_WIDTH = 500;
    private static final double WINDOW_MIN_WIDTH = 500;
    private static final double WINDOW_HEIGHT = 600;
    private static final double WINDOW_MIN_HEIGHT = 600;

    private static final String ICON_CLOSE = "\uf00d";
    private static final String ICON_MINIMISE = "\uf068";
    private static final String SELECTOR_CENTER_SCREEN = "#centerScreen";
    private static final String STYLE_CLASS_MAIN_WINDOW = "mainWindow";
    private static final int WRAPPER_PREF_WIDTH = 800;
    private static final int WRAPPER_PREF_HEIGHT = 800;

    // ================================================================================
    // Class variables
    // ================================================================================

    private Stage primaryStage;
    private Parent root;
    private SystemTray systemTray;
    private SystemTrayHandler systemTrayHandler;

    private BooleanProperty exitIndicator = new SimpleBooleanProperty(false);

    private static double xOffset, yOffset;

    // ================================================================================
    // FXML field variables
    // ================================================================================

    @FXML private BorderPane mainBorderPane;
    @FXML private Label close;
    @FXML private Label minimise;
    @FXML private Label statusLabel;
    @FXML private StackPane centerScreen;
    @FXML private TextField userInputField;

    // ================================================================================
    // WindowHandler methods
    // ================================================================================

    protected WindowHandler(Stage stage) {
        this.primaryStage = stage;
    }

    protected void loadWindowConfigurations(boolean showTray) {
        loadMainWindowLayout();
        if (showTray) {
            initTray();
        }
        overwriteDecorations();
        configurePrimaryStage();
    }

    protected void bindAsExitIndicator(BooleanProperty isExit) {
        exitIndicator.bindBidirectional(isExit);
        systemTrayHandler.bindExitIndicator(isExit);
    }

    private void loadMainWindowLayout() {
        FXMLLoader loader = new FXMLLoader(getClass().getResource(LOCATION_MAIN_WINDOW_LAYOUT));
        loader.setController(this); // Required due to different package declaration from Main
        try {
            root = loader.load();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void configurePrimaryStage() {
        primaryStage.setTitle(WINDOW_TITLE);
        primaryStage.setMinHeight(WINDOW_MIN_HEIGHT);
        primaryStage.setMinWidth(WINDOW_MIN_WIDTH);
        primaryStage.getIcons().addAll(
                new Image(WindowHandler.class.getResource(LOCATION_WINDOW_ICON).toExternalForm())
        );
        Scene primaryScene = new Scene(root, WINDOW_WIDTH, WINDOW_HEIGHT);  // This is the 'primary window' that consists of the user input field
        primaryScene.setFill(Color.TRANSPARENT);
        primaryScene.getStylesheets().add(getClass().getResource(LOCATION_CSS_STYLESHEET).toExternalForm());
        primaryStage.setScene(primaryScene);
    }

    private void initTray() {
        if (isSysTraySupported()) {
            systemTrayHandler = new SystemTrayHandler(primaryStage, userInputField);
            // userInputField is passed to SystemTrayHandler to request for focus whenever the window is shown
            systemTray = systemTrayHandler.initialiseTray();
            assert (systemTray != null);
        }
    }

    /**
     * Removes all window decorations, replacing a custom title bar and allow dragging of window
     */
    private void overwriteDecorations() {
        createTitleBar();
        setStyleAndMouseEvents();
    }

    /**
     * Removes all window decorations sets mouse events to enable dragging of window
     */
```
